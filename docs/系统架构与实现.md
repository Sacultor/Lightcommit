### ç³»ç»Ÿæ¶æ„ä¸å®ç°

æœ¬æ–‡é¢å‘è®ºæ–‡â€œç³»ç»Ÿæ¶æ„ä¸å®ç°â€ç« èŠ‚ï¼ŒåŸºäºå½“å‰ä»£ç ä»“åº“ï¼Œå®Œæ•´æè¿° LightCommit çš„æ€»ä½“æ¶æ„ã€å…³é”®ç»„ä»¶ã€ç«¯åˆ°ç«¯æµç¨‹ã€å®‰å…¨ä¸æ€§èƒ½è®¾è®¡ã€ä»¥åŠå®ç°ç»†èŠ‚ã€‚å†…å®¹ä»¥ç²¾å‡†ä¸ºä¸»ï¼Œå°‘åºŸè¯ï¼Œå¯ç›´æ¥ä½œä¸ºè®ºæ–‡æ­£æ–‡ä½¿ç”¨ã€‚


## ä¸€ã€æ€»ä½“æ¶æ„

- æ ¸å¿ƒç›®æ ‡ï¼šåŸºäº ERC-8004 æ€æƒ³ï¼Œå°† GitHub è´¡çŒ®å¯ä¿¡ä¸Šé“¾ï¼Œå½¢æˆå¯éªŒè¯çš„ä¿¡èª‰åˆ†ä¸ NFT è¯æ˜ï¼Œæœ€å°åŒ–ä¿¡ä»»ã€å…¼é¡¾å¯ç”¨æ€§ä¸æ€§èƒ½ã€‚
- åˆ†å±‚è®¾è®¡ï¼ˆå››å±‚ï¼‰ï¼š
  - å‰ç«¯å®¢æˆ·ç«¯ï¼ˆNext.js App Routerï¼‰ï¼šé’±åŒ…è¿æ¥ã€è´¡çŒ®æµè§ˆã€éªŒè¯ä¸è§¦å‘æ“ä½œã€‚
  - é“¾ä¸‹æœåŠ¡ï¼ˆNext API routesï¼‰ï¼šGitHub Webhook å…¥ç«™ã€è´¡çŒ®å…¥åº“ã€è¯„åˆ†ä¸ç­¾åã€IPFS ä¸Šé“¾ã€åŒºå—é“¾äº¤äº’ã€‚
  - æ•°æ®å±‚ï¼ˆSupabase/Postgresï¼‰ï¼šç”¨æˆ·ã€ä»“åº“ã€è´¡çŒ®å…ƒæ•°æ®ä¸çŠ¶æ€ç®¡ç†ã€RLS ç»†ç²’åº¦æƒé™æ§åˆ¶ã€‚
  - é“¾ä¸Šåˆçº¦ï¼ˆHardhat éƒ¨ç½²ï¼‰ï¼šä¿¡èª‰æ³¨å†Œç°¿ã€éªŒè¯ä¸é˜ˆå€¼æ§åˆ¶ã€NFT é“¸é€ ã€Agent èº«ä»½æ³¨å†Œã€‚

æ¶æ„æ–‡å­—å›¾ï¼ˆæŠ½è±¡ï¼‰ï¼š
- Client(Next.js) â†” API(Next routes)
- API â†” Supabase(Postgres, RLS)
- API â†” GitHub(Webhook, REST)
- API â†” IPFS/Web3.Storage
- API â†” EVM(ethers RPC) â†” Contracts{ReputationRegistry, ValidationRegistry, CommitNFT, AgentIdentityRegistry}


## äºŒã€æ¨¡å—åˆ’åˆ†ä¸èŒè´£

### 2.1 é“¾ä¸Šåˆçº¦

- AgentIdentityRegistryï¼šç»‘å®šé’±åŒ…ä¸ GitHub èº«ä»½ï¼Œç™»è®° Agent å¡ç‰‡ã€‚

```42:64:hardhat/contracts/AgentIdentityRegistry.sol
    function registerAgent(
        string memory githubUsername,
        string memory agentCardURI
    ) external whenNotPaused {
        require(!isRegistered[msg.sender], "Agent already registered");
        require(githubToWallet[githubUsername] == address(0), "GitHub username already bound");
        require(bytes(githubUsername).length > 0, "Invalid GitHub username");
        require(bytes(agentCardURI).length > 0, "Invalid agent card URI");
        
        agents[msg.sender] = AgentProfile({
            wallet: msg.sender,
            githubUsername: githubUsername,
            agentCardURI: agentCardURI,
            registeredAt: block.timestamp,
            active: true
        });
        
        githubToWallet[githubUsername] = msg.sender;
        isRegistered[msg.sender] = true;
        totalAgents++;
        
        emit AgentRegistered(msg.sender, githubUsername, agentCardURI, block.timestamp);
    }
```

- ReputationRegistryï¼šEIP-712 ç­¾åçš„ä¿¡èª‰åé¦ˆæäº¤ã€ç´¯è®¡ä¸äº‹ä»¶ã€‚

```85:105:hardhat/contracts/ReputationRegistry.sol
    function submitFeedback(
        SubmitParams calldata params,
        bytes calldata signature
    ) external whenNotPaused nonReentrant {
        if (params.contributor == address(0)) revert InvalidContributorAddress();
        if (params.score > 100) revert ScoreTooHigh();
        if (bytes(params.repo).length == 0) revert EmptyRepo();
        if (bytes(params.commitSha).length == 0) revert EmptyCommitSHA();

        bytes32 commitHash = keccak256(abi.encodePacked(params.repo, params.commitSha));
        
        if (feedbacks[commitHash].exists) revert CommitAlreadyProcessed();

        address signer = _verifySignature(params, signature);

        _storeFeedback(commitHash, params, signer);
        _updateReputation(params.contributor, params.score);
        _emitEvents(commitHash, params, signer);
    }
```

å…³é”®æ ¡éªŒï¼ˆç­¾å+æ—¶æ•ˆ+nonceï¼Œ5 åˆ†é’Ÿ TTLï¼‰ï¼š

```107:136:hardhat/contracts/ReputationRegistry.sol
    function _verifySignature(
        SubmitParams calldata params,
        bytes calldata signature
    ) internal returns (address) {
        bytes32 digest = _hashTypedDataV4(
            keccak256(
                abi.encode(
                    FEEDBACK_TYPEHASH,
                    params.contributor,
                    keccak256(bytes(params.repo)),
                    keccak256(bytes(params.commitSha)),
                    params.score,
                    params.feedbackHash,
                    params.timestamp,
                    params.nonce
                )
            )
        );
        
        address signer = digest.recover(signature);
        
        if (!hasRole(EVALUATOR_ROLE, signer)) revert InvalidSignature();
        if (block.timestamp < params.timestamp) revert SignatureExpired();
        if (block.timestamp - params.timestamp > 300) revert SignatureExpired();

        if (params.nonce != nonces[signer]) revert InvalidNonce();
        nonces[signer]++;

        return signer;
    }
```

- ValidationRegistryï¼šä»ä¿¡èª‰åé¦ˆè¯»å–åˆ†æ•°ï¼Œä¸é˜ˆå€¼æ¯”è¾ƒï¼Œè§¦å‘ CommitNFT é“¸é€ ã€‚

```88:153:hardhat/contracts/ValidationRegistry.sol
    function requestValidation(
        string calldata repo,
        string calldata commitSha,
        address contributor,
        string calldata metadataURI
    ) external whenNotPaused nonReentrant returns (bool didMint) {
        if (bytes(repo).length == 0) revert InvalidInput();
        if (bytes(commitSha).length == 0) revert InvalidInput();
        if (contributor == address(0)) revert InvalidAddress();
        
        bytes32 commitHash = keccak256(abi.encodePacked(repo, commitSha));
        
        if (isMinted[commitHash]) revert AlreadyMinted();
        
        IReputationRegistry.Feedback memory feedback = reputationRegistry.getFeedbackByCommit(repo, commitSha);
        
        if (!feedback.exists) revert FeedbackNotFound();
        emit ValidationRequested(commitHash, contributor, repo, commitSha, feedback.score, block.timestamp);
        
        totalValidations++;

        bool shouldMint = feedback.score >= mintThreshold;
        
        emit ValidationCompleted(commitHash, shouldMint, feedback.score, mintThreshold, block.timestamp);
        
        if (shouldMint) {
            isMinted[commitHash] = true;

            uint256 tokenId = _triggerMint(contributor, repo, commitSha, feedback, metadataURI);
            
            commitToTokenId[commitHash] = tokenId;
            totalMints++;
            
            emit MintTriggered(commitHash, tokenId, contributor, feedback.score, metadataURI, block.timestamp);

            return true;
        }
        
        return false;
    }
```

è¯´æ˜ï¼š`getFeedbackByCommit` åœ¨ `ReputationRegistry` æœªå‘½ä¸­ä¼šç›´æ¥ revertï¼ˆå³ä¸ä¼šè¿”å› `exists=false` çš„ç»“æ„ä½“ï¼‰ï¼Œå› æ­¤ `if (!feedback.exists)` çš„æ£€æŸ¥åœ¨å®è´¨ä¸Šä¸ºå†—ä½™ï¼Œå¯åç»­ç®€åŒ–ï¼ˆä¸å½±å“æ­£ç¡®æ€§ï¼‰ã€‚

- CommitNFTï¼šå¯éªŒè¯è´¡çŒ®çš„ ERC-721 èµ„äº§ï¼Œæ”¯æŒ onlyOwner é“¸é€ ä¸æ‰¹é‡é“¸é€ ã€‚

```119:154:hardhat/contracts/mint.sol
    function mintCommit(
        address to,
        CommitData memory commitData,
        string memory metadataURI
    ) external onlyOwner whenNotPaused nonReentrant {
        require(to != address(0), "Invalid recipient address");
        require(!_mintedCommits[commitData.commit], "Commit already minted");
        require(_tokenIdCounter.current() <= MAX_SUPPLY, "Max supply exceeded");
        require(bytes(commitData.commit).length > 0, "Commit hash required");
        require(bytes(commitData.commit).length <= 256, "Commit hash too long");
        require(bytes(metadataURI).length > 0, "metadataURI required");
        require(_userTokenCount[to] + 1 <= MAX_MINTS_PER_ADDRESS, "Recipient mint limit exceeded");
        
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();
        
        _commitData[tokenId] = commitData;
        _mintedCommits[commitData.commit] = true;
        _userTokenCount[to]++;
        
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, metadataURI);
        
        emit CommitMinted(tokenId, to, commitData.repo, commitData.commit, commitData.linesAdded, commitData.testsPass, commitData.merged);
    }
```

éƒ¨ç½²è¦æ±‚ï¼šä¸ºä½¿ `ValidationRegistry` èƒ½è°ƒç”¨ `CommitNFT.mintCommit`ï¼Œéœ€è¦å°† `CommitNFT` æ‰€æœ‰æƒè½¬ç§»ç»™ `ValidationRegistry`ï¼Œæˆ–é€šè¿‡å…¶ä»–å—æ§é“¸é€ å…¥å£ï¼ˆæœ¬é¡¹ç›®æ¨èå‰è€…ï¼Œå·²åœ¨éƒ¨ç½²æŒ‡å¼•ä¸­çº¦å®šï¼‰ã€‚


### 2.2 é“¾ä¸‹æœåŠ¡ï¼ˆNext API routesï¼‰

- GitHub Webhook å…¥ç«™ï¼ŒéªŒç­¾åæ´¾å‘äº‹ä»¶ï¼š

```5:69:frontend/src/app/api/github/webhook/route.ts
export async function POST(request: NextRequest) {
  console.log('ğŸ”” Webhook received');
  try {
    const signature = request.headers.get('x-hub-signature-256');
    const event = request.headers.get('x-github-event');
    if (!signature) return NextResponse.json({ error: 'Missing signature' }, { status: 400 });
    if (!event) return NextResponse.json({ error: 'Missing event type' }, { status: 400 });

    let payload;
    try { payload = await request.json(); } catch (error) {
      return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
    }

    const payloadString = JSON.stringify(payload);
    const isValid = GitHubService.verifyWebhookSignature(payloadString, signature);
    if (!isValid) return NextResponse.json({ error: 'Invalid signature' }, { status: 400 });

    await GitHubService.handleWebhook(event, payload);
    return NextResponse.json({ success: true });
  } catch (error) {
    return NextResponse.json({ error: 'Failed to process webhook' }, { status: 500 });
  }
}
```

- GitHubServiceï¼šå¤„ç† push/PR äº‹ä»¶ï¼Œè§„èŒƒåŒ–è´¡çŒ®å¹¶å…¥åº“ï¼›æä¾› GitHub API æ‹‰å–ä»“åº“/æäº¤ç­‰èƒ½åŠ›ã€‚

```78:115:frontend/src/lib/services/github.service.ts
  private static async handlePushEvent(payload: GitHubPushPayload): Promise<void> {
    const commits = payload.commits || [];
    const repository = payload.repository;

    for (const commit of commits) {
      const repo = await this.findOrCreateRepository(repository);
      const user = await this.findUserByGithubUsername(commit.author.username);

      if (!user) continue;

      const existingContribution = await ContributionRepository.findByGithubId(commit.id);
      if (existingContribution) continue;

      const contributionData: CreateContributionData = {
        githubId: commit.id,
        type: ContributionType.COMMIT,
        userId: user.id,
        repositoryId: repo.id,
        contributor: commit.author.username,
        title: commit.message.split('\n')[0],
        description: commit.message,
        url: commit.url,
        metadata: { sha: commit.id, timestamp: commit.timestamp, additions: commit.added?.length || 0, deletions: commit.removed?.length || 0, modifications: commit.modified?.length || 0 },
      };

      const contribution = await ContributionRepository.create(contributionData);
      console.log(`Created contribution ${contribution.id} for commit ${commit.id}`);
    }
  }
```

- ScoringServiceï¼šå¤šç»´åº¦è¯„åˆ†ä¸åŠ æƒèšåˆï¼ˆå¸¸è§„æ€§ã€å¤§å°ã€æ–‡ä»¶å½±å“ã€åˆå¹¶ä¿¡å·ã€å…ƒæ•°æ®å®Œæ•´åº¦ï¼‰ã€‚

```9:24:frontend/src/lib/services/scoring.service.ts
export class ScoringService {
  static conventionalScore(message: string): number {
    const prefixOk = /^(feat|fix|docs|refactor|test|chore|perf|style|build|ci)(\(.+\))?:\s+/.test(message);
    const lengthOk = message.split('\n')[0].trim().length >= 8;
    return Math.round((prefixOk ? 70 : 30) + (lengthOk ? 30 : 0));
  }
  static sizeScore(additions: number, deletions: number): number {
    const total = additions + deletions;
    if (total === 0) return 40;
    if (total <= 50) return 95;
    if (total <= 200) return 85;
    if (total <= 500) return 70;
    if (total <= 1000) return 55;
    return 40;
  }
}
```

- ERC8004Serviceï¼šæ„é€ åé¦ˆå“ˆå¸Œã€ç”Ÿæˆ/æ ¡éªŒ EIP-712 ç­¾åã€IPFS å…ƒæ•°æ®ä¸Šä¼ ä¸è§£æã€‚

```28:43:frontend/src/lib/services/erc8004.service.ts
export class ERC8004Service {
  static generateFeedbackHash(repo: string, commitSha: string, score: number, timestamp: number): string {
    const data = JSON.stringify({ repo, commitSha, score, timestamp });
    return ethers.keccak256(ethers.toUtf8Bytes(data));
  }
```

```85:105:frontend/src/lib/services/erc8004.service.ts
  static async signFeedback(feedback: ERC8004Feedback, signer: ethers.Signer, chainId: number, verifyingContract: string): Promise<string> {
    const domain = this.getEIP712Domain(chainId, verifyingContract);
    const types = this.getEIP712Types();
    const signature = await signer.signTypedData(domain, types, {
      contributor: feedback.contributor,
      repo: feedback.repo,
      commitSha: feedback.commitSha,
      score: feedback.score,
      feedbackHash: feedback.feedbackHash,
      timestamp: feedback.timestamp,
      nonce: feedback.nonce,
    });
    return signature;
  }
```

- BlockchainServiceï¼šä¸ RPC/åˆçº¦äº¤äº’ã€é“¸é€ è´¡çŒ® NFTã€ä¸Šä¼ å…ƒæ•°æ®åˆ° IPFSï¼ˆWeb3.Storage ä¼˜å…ˆã€Pinata å¤‡é€‰ï¼‰ã€æ›´æ–°è´¡çŒ®çŠ¶æ€ã€‚

```62:99:frontend/src/lib/services/blockchain.service.ts
  static async mintContribution(contributionId: string): Promise<string> {
    await this.ensureInitialized();
    if (!this.contract || !this.wallet) throw new Error('Contract or wallet not initialized');

    const contribution = await ContributionRepository.findById(contributionId);
    if (!contribution) throw new Error('Contribution not found');
    if (contribution.status === ContributionStatus.MINTED) throw new Error('Contribution already minted');

    const metadataUri = await this.uploadMetadataToIPFS(contribution);

    const repoFullName = contribution.repository?.fullName || (contribution.metadata as any)?.repo || '';
    const commitHash = (contribution.metadata as any)?.sha || contribution.githubId;
    const linesAdded = (contribution.metadata as any)?.additions || 0;
    const linesDeleted = (contribution.metadata as any)?.deletions || 0;
    const merged = contribution.type === 'pull_request' ? true : !!(contribution.metadata as any)?.merged;
    const testsPass = !!(contribution.metadata as any)?.testsPass;
    const timestampSec = Math.floor(new Date(contribution.createdAt as any).getTime() / 1000);
    const author = contribution.contributor;
    const message = contribution.title || contribution.description || '';

    const commitData = { repo: repoFullName, commit: commitHash, linesAdded, linesDeleted, testsPass, timestamp: timestampSec, author, message, merged };
    const toAddress = this.wallet?.address || author;

    const tx = await (this.contract as any).mintCommit(toAddress, commitData, metadataUri);
    const receipt = await tx.wait();
    // è§£æäº‹ä»¶å¹¶å›å†™æ•°æ®åº“ï¼ˆçœç•¥ï¼‰
    return receipt.hash;
  }
```


### 2.3 æ•°æ®å±‚ï¼ˆSupabase / Postgresï¼‰

- è¡¨ç»“æ„ï¼ˆusers / repositories / contributionsï¼‰ï¼Œè¡Œçº§å®‰å…¨ï¼ˆRLSï¼‰ç­–ç•¥ä¸è§¦å‘å™¨ï¼š

```6:16:frontend/supabase/migrations/20241018_initial_schema.sql
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    "githubId" VARCHAR NOT NULL UNIQUE,
    username VARCHAR NOT NULL,
    email VARCHAR,
    "avatarUrl" VARCHAR,
    "accessToken" VARCHAR,
    "walletAddress" VARCHAR,
    "createdAt" TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    "updatedAt" TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

```48:65:frontend/supabase/migrations/20241018_initial_schema.sql
CREATE TABLE IF NOT EXISTS contributions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    "githubId" VARCHAR NOT NULL UNIQUE,
    type contribution_type NOT NULL,
    "userId" UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    "repositoryId" UUID NOT NULL REFERENCES repositories(id) ON DELETE CASCADE,
    contributor VARCHAR NOT NULL,
    title VARCHAR,
    description TEXT,
    url VARCHAR,
    status contribution_status DEFAULT 'pending',
    "transactionHash" VARCHAR,
    "tokenId" VARCHAR,
    "metadataUri" VARCHAR,
    metadata JSONB,
    "createdAt" TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    "updatedAt" TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

RLS è¦ç‚¹ï¼š
- usersï¼šä»…æœ¬äººå¯è¯»å†™ï¼Œservice_role å…¨æƒã€‚
- repositoriesï¼šè®¤è¯ç”¨æˆ·å¯è¯»ï¼Œservice_role å…¨æƒã€‚
- contributionsï¼šè®¤è¯ç”¨æˆ·å¯è¯»ï¼Œæœ¬äººå¯æ›´æ–°ï¼Œservice_role å…¨æƒã€‚


## ä¸‰ã€ç«¯åˆ°ç«¯æµç¨‹ï¼ˆE2Eï¼‰

1) GitHub â†’ Webhookï¼ˆå…¥ç«™ï¼‰
- GitHub æ¨é€ push/PR åˆå¹¶äº‹ä»¶åˆ° `/api/github/webhook`ï¼›æœåŠ¡ç«¯éªŒç­¾é€šè¿‡ååˆ†å‘äº‹ä»¶ã€‚

2) Webhook â†’ æ•°æ®å…¥åº“
- é€šè¿‡ `GitHubService` è§£æäº‹ä»¶ï¼Œè¡¥å…¨/åˆ›å»ºä»“åº“ä¸è´¡çŒ®è®°å½•å†™å…¥ Supabaseã€‚

3) è¯„åˆ†ä¸ç­¾åï¼ˆERC-8004ï¼‰
- æ‹‰å–æäº¤è¯¦æƒ…ä¸å…ƒæ•°æ®ï¼Œä½¿ç”¨ `ScoringService` è®¡ç®—å„ç»´åº¦åˆ†ä¸åŠ æƒç»“æœã€‚
- ä½¿ç”¨ `ERC8004Service.generateFeedbackHash` ç”Ÿæˆåé¦ˆæ‘˜è¦ï¼›ç”±å…·å¤‡è¯„å®¡è§’è‰²çš„é’±åŒ…ï¼ˆEvaluatorï¼‰å¯¹ç»“æ„åŒ–æ•°æ®è¿›è¡Œ EIP-712 ç­¾åã€‚

4) ä¸Šé“¾ä¿¡èª‰åé¦ˆ
- å‰ç«¯æˆ–æœåŠ¡ç«¯è°ƒç”¨ `ReputationRegistry.submitFeedback(params, signature)`ï¼›åˆçº¦æ ¡éªŒç­¾åäººè§’è‰²ã€æ—¶é—´çª—å£ï¼ˆâ‰¤5 åˆ†é’Ÿï¼‰ã€nonce å¹¶è½åº“æ˜ å°„ä¸äº‹ä»¶ã€‚

5) éªŒè¯ä¸ NFT é“¸é€ 
- è°ƒç”¨ `ValidationRegistry.requestValidation(repo, commitSha, contributor, metadataURI)`ï¼›è‹¥åˆ†æ•°â‰¥é˜ˆå€¼ï¼ˆé»˜è®¤ 80ï¼‰ï¼Œåˆ™è§¦å‘ `CommitNFT.mintCommit` é“¸é€ ã€‚
- äº‹ä»¶ `MintTriggered` ä¸ `CommitMinted` å‘å‡ºï¼Œå®¢æˆ·ç«¯/æœåŠ¡ç«¯ç›‘å¬åå›å†™ Supabase çŠ¶æ€ã€‚

6) å±•ç¤ºä¸æŸ¥è¯¢
- å‰ç«¯é€šè¿‡é’±åŒ…è¿æ¥ä¸ API æ‹‰å–è´¡çŒ®ã€ä¿¡èª‰ä¸ NFT è¯¦æƒ…ï¼›IPFS å…ƒæ•°æ®é€šè¿‡ç½‘å…³è§£æå±•ç¤ºã€‚


## å››ã€å®‰å…¨è®¾è®¡

- è®¿é—®æ§åˆ¶ï¼š
  - `ReputationRegistry` ä½¿ç”¨ `AccessControl` å®šä¹‰ `DEFAULT_ADMIN_ROLE` ä¸ `EVALUATOR_ROLE`ï¼Œä»…è¯„å®¡è€…ç­¾åæœ‰æ•ˆã€‚
  - `ValidationRegistry` é€šè¿‡ `DEFAULT_ADMIN_ROLE` ç®¡ç†é˜ˆå€¼ã€æš‚åœã€‚
  - `CommitNFT.mintCommit` ä¸º `onlyOwner`ï¼Œéœ€åœ¨éƒ¨ç½²æ—¶å°† `CommitNFT` æ‰€æœ‰æƒè½¬ç§»è‡³ `ValidationRegistry`ï¼ˆæˆ–ç”±åŒä¸€æ‰€æœ‰è€…ä»¥å—æ§å…¥å£è°ƒç”¨ï¼‰ã€‚

- é˜²æŠ¤æœºåˆ¶ï¼š
  - `Pausable` å…¨é¢å¸ƒç½®ï¼Œå…³é”®å¤–éƒ¨å‡½æ•°å¯ç´§æ€¥åˆ¹è½¦ã€‚
  - `ReentrancyGuard` ç”¨äºæ¶‰åŠå¤–éƒ¨äº¤äº’çš„å‡½æ•°ï¼ˆå°½ç®¡å½“å‰å¤–éƒ¨å†™æ“ä½œæœ‰é™ï¼Œä»ä½œä¸ºåŸºçº¿é˜²æŠ¤ï¼‰ã€‚
  - EIP-712 + `nonce` + æ—¶é—´çª—ï¼ˆ5 åˆ†é’Ÿ TTLï¼‰æŠ‘åˆ¶é‡æ”¾ï¼›æ‹’ç»æœªæ¥æ—¶é—´æˆ³ä¸è¿‡æœŸç­¾åã€‚
  - äº‹ä»¶å®Œå¤‡ï¼šæäº¤ä¸ä¿¡èª‰æ›´æ–°ã€éªŒè¯ä¸é“¸é€ å„é˜¶æ®µå‡æœ‰äº‹ä»¶ï¼Œä¾¿äºé“¾ä¸‹å®¡è®¡ä¸ç´¢å¼•ã€‚

- æ³¨æ„ç‚¹ï¼ˆå¯æ”¹è¿›ï¼‰ï¼š
  - `ValidationRegistry` å¯¹ `feedback.exists` çš„æ£€æŸ¥åœ¨ `ReputationRegistry.getFeedbackByCommit` ä¼š revert çš„å‰æä¸‹å±äºå†—ä½™ï¼Œå¯ç§»é™¤ä»¥çœæ°”ã€‚
  - è‹¥éœ€è·¨åˆçº¦æƒé™æ›´ç»†ç²’åº¦æ§åˆ¶ï¼Œå¯å°† `CommitNFT` çš„é“¸é€ å…¥å£è¿ç§»ä¸º `MINTER_ROLE`ï¼ˆ`AccessControl`ï¼‰ï¼Œæ›¿ä»£ `onlyOwner`ã€‚
  - `AgentIdentityRegistry` å½“å‰ä»…ç»‘å®š GitHub ä¸é’±åŒ…ï¼Œå¯æ‰©å±•é“¾ä¸‹è¯æ˜æ ¡éªŒï¼ˆå¦‚ GitHub OAuth ç»‘å®šä¸å¯æ’¤é”€æ€§ï¼‰ã€‚


## äº”ã€æ€§èƒ½ä¸ gas è®¾è®¡

- å­˜å‚¨ä¸ç±»å‹ï¼š`Feedback` ç»“æ„ä½“ä½¿ç”¨ `uint64/uint16` ç­‰è¾ƒçª„ç±»å‹ï¼Œæœ‰åˆ©äºæ‰“åŒ…ä¸é™ä½å­˜å‚¨æˆæœ¬ï¼›æ˜ å°„è¯»å†™ O(1)ã€‚  
- è®¡ç®—ä¸å¾ªç¯ï¼šå…³é”®è·¯å¾„æ— é•¿å¾ªç¯ï¼›`ValidationRegistry` æŒ‰å•æäº¤éªŒè¯ï¼Œé¿å…æ‰¹é‡å›è·¯å¯¼è‡´çš„é«˜ gasã€‚  
- äº‹ä»¶ä¸ç´¢å¼•ï¼šäº‹ä»¶å­—æ®µåŒ…å«å…³é”®ç´¢å¼•ï¼ˆcommitHashã€contributorï¼‰ï¼Œä¾¿äºé“¾ä¸‹ç´¢å¼•å™¨å¿«é€Ÿè¿‡æ»¤ã€‚  
- å‰ç«¯ä¸ APIï¼šè¯„åˆ†ä¸å…ƒæ•°æ®æ„é€ åœ¨é“¾ä¸‹è¿›è¡Œï¼Œé“¾ä¸Šä»…ä¿å­˜å¿…è¦çš„æ‘˜è¦/åˆ†æ•°ï¼Œæ§åˆ¶ä¸Šé“¾å¼€é”€ã€‚  


## å…­ã€å®ç°ç»†èŠ‚è¦ç‚¹ï¼ˆé€æ¨¡å—ï¼‰

- ReputationRegistry
  - æ•°æ®ï¼š`feedbacks[commitHash]`ã€è´¡çŒ®è€…ç´¯è®¡åˆ†ä¸è®¡æ•°ã€`nonces[signer]`ã€‚
  - æ ¡éªŒï¼šEIP-712 ç»“æ„åŒ–æ•°æ®ç­¾åï¼›ç­¾åè€…éœ€å…·å¤‡ `EVALUATOR_ROLE`ï¼›5 åˆ†é’Ÿæœ‰æ•ˆæœŸï¼›ä¸¥æ ¼é€’å¢ nonceã€‚
  - äº‹ä»¶ï¼š`FeedbackSubmitted`ã€`ReputationUpdated`ã€‚

- ValidationRegistry
  - ä¾èµ–ï¼š`IReputationRegistry` åªè¯»æŸ¥è¯¢ã€`CommitNFT` é“¸é€ ã€‚
  - é€»è¾‘ï¼šåˆ†æ•°é˜ˆå€¼ï¼ˆé»˜è®¤ 80ï¼Œå¯ 60â€“100 è°ƒæ•´ï¼‰ï¼Œä¸€æ¬¡æ€§é“¸é€ é˜²é‡ï¼ˆ`isMinted`ï¼‰ã€‚
  - äº‹ä»¶ï¼š`ValidationRequested`ã€`ValidationCompleted`ã€`MintTriggered`ã€‚

- CommitNFT
  - æ•°æ®ï¼šæŒ‰ tokenId å­˜å‚¨ `CommitData`ï¼›`_mintedCommits` é˜²é‡å¤ï¼›ç”¨æˆ·é“¸é€ è®¡æ•°é™æµã€‚
  - èƒ½åŠ›ï¼šå•é“¸ã€æ‰¹é‡é“¸ã€ç­¾åé“¸é€ ï¼ˆåç»­å¯å¼€æ”¾ï¼‰ï¼›`BaseURI` å¯æ›´æ–°ï¼›ç´§æ€¥æå–ã€‚

- AgentIdentityRegistry
  - æ˜ å°„ï¼š`githubToWallet` ä¸ `agents` åŒå‘ç»‘å®šï¼›`isRegistered` å¿«é€Ÿåˆ¤æ–­ã€‚
  - èƒ½åŠ›ï¼šæ³¨å†Œã€æ›´æ–°å¡ç‰‡ã€åœç”¨ã€æŒ‰åœ°å€/ç”¨æˆ·åæŸ¥è¯¢ã€‚

- é“¾ä¸‹æœåŠ¡
  - Webhookï¼šä¸¥æ ¼éªŒç­¾ï¼ˆHMAC SHA-256ï¼‰ï¼Œç¡®ä¿äº‹ä»¶æ¥æºå¯ä¿¡ã€‚
  - è¯„åˆ†ï¼šå¤šç»´ã€å¯è°ƒæƒé‡ï¼Œèšåˆä¸º 0â€“100 çš„åˆ†å€¼ï¼Œä¾¿äºé˜ˆå€¼åˆ¤æ–­ã€‚
  - IPFSï¼šWeb3.Storage ä¼˜å…ˆï¼ŒPinata å¤‡é€‰ï¼›è¿”å› `ipfs://`ï¼Œå‰ç«¯è§£æä¸ºç½‘å…³ URL å±•ç¤ºã€‚
  - åŒºå—é“¾ï¼šethers v6ï¼ŒProvider/Wallet/Contract ä¸‰å…ƒåˆå§‹åŒ–ï¼Œäº¤æ˜“å‘é€ä¸ receipt è§£æï¼ŒçŠ¶æ€å›å†™æ•°æ®åº“ã€‚

- æ•°æ®å±‚ï¼ˆSupabaseï¼‰
  - è§¦å‘å™¨ï¼šç»Ÿä¸€ç»´æŠ¤ `updatedAt`ï¼›ç´¢å¼•è¦†ç›–å¸¸ç”¨æŸ¥è¯¢ï¼›RLS æä¾›å¤šç§Ÿæˆ·/ç”¨æˆ·çº§éš”ç¦»ã€‚


## ä¸ƒã€éƒ¨ç½²ä¸è¿ç»´è¦ç‚¹

- éƒ¨ç½²é¡ºåºï¼ˆåˆçº¦ä¾§ï¼‰ï¼šéƒ¨ç½² `CommitNFT` â†’ éƒ¨ç½² `ReputationRegistry`ï¼ˆæˆäºˆè¯„å®¡è€…ï¼‰â†’ éƒ¨ç½² `ValidationRegistry`ï¼ˆæŒ‡å‘å‰ä¸¤è€…ï¼‰â†’ è½¬ç§» `CommitNFT` æ‰€æœ‰æƒåˆ° `ValidationRegistry` â†’ éªŒè¯é˜ˆå€¼ä¸è§’è‰²é…ç½® â†’ æš‚åœ/è§£ç¦æ£€æŸ¥ã€‚
- ç¯å¢ƒå˜é‡ï¼ˆå‰ç«¯/æœåŠ¡ï¼‰ï¼šRPCã€ç§é’¥ã€åˆçº¦åœ°å€ã€GitHub å¯†é’¥/ç­¾åå¯†é’¥ã€Web3.Storage/Pinata å‡­æ®ã€Supabase è¿æ¥ã€‚
- ç›‘æ§ï¼šè®¢é˜…åˆçº¦äº‹ä»¶ï¼ˆåé¦ˆ/ä¿¡èª‰æ›´æ–°/é“¸é€ ï¼‰ã€API é”™è¯¯æ—¥å¿—ã€Webhook éªŒç­¾å¤±è´¥å‘Šè­¦ã€æ•°æ®åº“å¥åº·æ£€æŸ¥ï¼ˆå†…ç½® `health_check()`ï¼‰ã€‚


## å…«ã€æ‰©å±•ä¸æ¼”è¿›

- è¯„åˆ†ä¿¡å·æ‰©å±•ï¼šå¼•å…¥æµ‹è¯•è¦†ç›–ç‡ã€é™æ€åˆ†æã€è·¨ä»“åº“å£°èª‰ä¼ å¯¼ã€å®¡é˜…è€…ä¿¡èª‰åŠ æƒã€‚
- é“¾ä¸Šæ•°æ®å‹ç¼©ï¼šMerkle æ‰¹é‡æäº¤ä¿¡èª‰æ‘˜è¦ï¼Œé™ä½ä¸Šé“¾é¢‘åº¦ä¸æˆæœ¬ã€‚
-
  è·¨é“¾/äºŒå±‚ï¼šæŠ½è±¡ RPC ä¸åˆçº¦åœ°å€ï¼Œæ”¯æŒå¤šç½‘ç»œå¹¶è¡Œï¼ˆOP/Arbitrum/Baseï¼‰ã€‚
- æ²»ç†ä¸å‡†å…¥ï¼šä½¿ç”¨ `AccessControl`/`TimelockController` ç®¡ç†è¯„å®¡è€…ä¸é˜ˆå€¼æ›´æ”¹ï¼Œå¼•å…¥å¤šç­¾/æ—¶é—´é”ã€‚


## ä¹ã€å°ç»“

LightCommit ä»¥æ¸…æ™°çš„å››å±‚æ¶æ„ä¸æœ€å°ä¸Šé“¾è®¾è®¡ï¼Œå°† GitHub è´¡çŒ®æ˜ å°„ä¸ºå¯éªŒè¯çš„ä¿¡èª‰ä¸èµ„äº§ã€‚å…³é”®è·¯å¾„éµå¾ª CEI ä¸æœ€å°ä¿¡ä»»åŸåˆ™ï¼šé“¾ä¸‹è®¡ç®—ã€é“¾ä¸Šæ ¡éªŒä¸è®°è´¦ã€å®Œæ•´äº‹ä»¶ä¸æ•°æ®åº“åæŸ¥é—­ç¯ã€‚å®‰å…¨åŸºçº¿ä¸å¯æ‰©å±•æ€§å‡å·²é¢„åŸ‹ï¼Œå¯åœ¨ç”Ÿäº§ç¯å¢ƒç»§ç»­å¼•å…¥æ²»ç†ã€æ—¶é—´é”ä¸æ›´ä¸°å¯Œçš„è¯„åˆ†ä¿¡å·ã€‚


å‚è€ƒï¼ˆä»“åº“å†…æ–‡æ¡£ï¼‰ï¼š`docs/overview.md`ã€`docs/contracts.md`ã€`docs/ERC8004_IMPLEMENTATION.md`ã€`docs/deployment.md`ã€`docs/frontend.md`ã€`docs/å®éªŒå¤ç°.md`ã€‚


