# LightCommit 前端技术架构

## 一、技术栈概览

### 1.1 核心框架与库

| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **Next.js** | 15.5.4 | React 全栈框架 | 提供 SSR、SSG、API Routes、文件路由等能力 |
| **React** | 19.1.0 | UI 框架 | 最新版本，支持 Server Components |
| **TypeScript** | 5.x | 类型系统 | 提供类型安全和更好的开发体验 |
| **Tailwind CSS** | 4.1.14 | CSS 框架 | 原子化 CSS，快速构建现代 UI |

### 1.2 Web3 技术栈

| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **Wagmi** | 2.19.2 | React Hooks for Ethereum | 提供以太坊交互的 React Hooks |
| **Viem** | 2.38.0 | 以太坊 TypeScript 库 | 替代 ethers.js，更轻量、类型更安全 |
| **RainbowKit** | 2.2.9 | 钱包连接 UI | 提供美观的钱包连接界面 |
| **TanStack Query** | 5.59.0 | 数据缓存和状态管理 | 用于缓存 wagmi hooks 的查询结果 |

### 1.3 后端与数据

| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **Supabase** | 2.75.1 | BaaS 平台 | PostgreSQL 数据库 + 认证 + 实时订阅 |
| **Axios** | 1.7.7 | HTTP 客户端 | 封装 API 请求，自动处理认证 |
| **JWT (jose)** | 6.1.0 | 认证令牌 | 用户 session 管理 |

### 1.4 UI 组件与交互

| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **Radix UI** | - | 无障碍组件库 | 提供高质量的无样式组件 |
| **Lucide React** | 0.545.0 | 图标库 | 现代化的图标集 |
| **Framer Motion** | 11.11.17 | 动画库 | 声明式动画和手势交互 |
| **React Hot Toast** | 2.4.1 | 通知组件 | 全局 Toast 通知 |

### 1.5 开发工具

| 技术 | 版本 | 用途 | 说明 |
|------|------|------|------|
| **Turbopack** | - | 构建工具 | Next.js 15 内置，比 Webpack 更快 |
| **ESLint** | 9.x | 代码检查 | 保证代码质量和一致性 |
| **Storybook** | 8.6.14 | 组件开发 | 独立开发和测试 UI 组件 |

---

## 二、项目结构

```
frontend/
├── src/
│   ├── app/                    # Next.js App Router (路由 + 页面)
│   │   ├── api/               # API Routes (后端接口)
│   │   │   ├── auth/         # 认证接口 (GitHub OAuth, Session)
│   │   │   ├── contributions/ # 贡献数据接口
│   │   │   ├── github/       # GitHub API 代理
│   │   │   ├── health/       # 健康检查
│   │   │   └── ipfs/         # IPFS 上传接口
│   │   ├── collections/       # NFT 合集页面
│   │   ├── erc8004/          # ERC8004 相关页面 (Agent 注册、验证)
│   │   ├── explore/          # 探索页面
│   │   ├── mint/             # NFT 铸造页面
│   │   ├── profiles/         # 用户资料页面
│   │   ├── roadmap/          # 路线图页面
│   │   ├── layout.tsx        # 根布局 (全局 HTML 结构)
│   │   ├── page.tsx          # 首页
│   │   ├── providers.tsx     # 全局 Providers (Web3, Toast)
│   │   └── globals.css       # 全局样式
│   │
│   ├── components/            # UI 组件
│   │   ├── erc8004/          # ERC8004 相关组件 (Agent 注册、信誉展示)
│   │   ├── home/             # 首页组件 (Hero, About, FAQ)
│   │   ├── layout/           # 布局组件 (Header, Footer)
│   │   ├── nft/              # NFT 展示组件 (卡片、列表)
│   │   └── wallet/           # 钱包组件 (连接弹窗)
│   │
│   ├── hooks/                 # 自定义 React Hooks
│   │   ├── use-agent-registry.ts    # Agent 注册相关 Hook
│   │   ├── use-auth.ts              # 认证相关 Hook
│   │   └── use-contributions.ts     # 贡献数据相关 Hook
│   │
│   ├── lib/                   # 核心库和工具
│   │   ├── api.ts            # API 客户端 (axios 封装)
│   │   ├── auth/             # 认证逻辑
│   │   │   └── session.ts    # Session 管理 (JWT)
│   │   ├── config/           # 配置管理
│   │   │   └── index.ts      # 统一配置入口 (环境变量)
│   │   ├── contexts/         # React Context
│   │   │   ├── RainbowKitProvider.tsx  # RainbowKit 配置
│   │   │   └── Web3Context.tsx         # Web3 Context
│   │   ├── contracts/        # 智能合约 ABI
│   │   │   ├── AgentIdentityRegistry.json
│   │   │   ├── CommitNFT.json
│   │   │   ├── ReputationRegistry.json
│   │   │   ├── ValidationRegistry.json
│   │   │   └── index.ts
│   │   ├── database/         # 数据库访问层
│   │   │   ├── index.ts      # Supabase 客户端
│   │   │   ├── migrations/   # 数据库迁移脚本
│   │   │   └── repositories/ # 数据仓库层 (Users, Contributions, Repositories)
│   │   ├── services/         # 业务逻辑层
│   │   │   ├── auth.service.ts          # 认证服务
│   │   │   ├── contribution.service.ts  # 贡献服务
│   │   │   ├── erc8004.service.ts       # ERC8004 服务
│   │   │   ├── github.service.ts        # GitHub API 服务
│   │   │   └── scoring.service.ts       # 评分算法服务
│   │   ├── utils/            # 工具函数
│   │   └── utils.ts          # 通用工具函数 (cn, formatDate)
│   │
│   └── types/                 # TypeScript 类型定义
│       ├── api.ts            # API 响应类型
│       ├── auth.ts           # 认证类型
│       ├── blockchain.ts     # 区块链类型
│       ├── contribution.ts   # 贡献类型
│       ├── github.ts         # GitHub 类型
│       ├── repository.ts     # 仓库类型
│       ├── user.ts           # 用户类型
│       ├── index.ts          # 类型汇总导出
│       └── window.d.ts       # 全局类型扩展
│
├── public/                    # 静态资源
│   ├── assets/               # 图片、图标、背景
│   └── fonts/                # 字体文件
│
├── supabase/                  # Supabase 配置
│   ├── config.toml           # Supabase 本地配置
│   └── migrations/           # 数据库迁移
│
├── package.json              # 依赖配置
├── tsconfig.json            # TypeScript 配置
├── tailwind.config.ts       # Tailwind CSS 配置
├── next.config.ts           # Next.js 配置
└── components.json          # shadcn/ui 配置
```

---

## 三、核心架构设计

### 3.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        浏览器 (Browser)                      │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────┐   │
│  │           UI 层 (React Components)                   │   │
│  │  • 页面组件 (app/*/page.tsx)                        │   │
│  │  • 可复用组件 (components/*)                        │   │
│  │  • 自定义 Hooks (hooks/*)                           │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↕                                   │
│  ┌─────────────────────────────────────────────────────┐   │
│  │         Context 层 (Global State)                    │   │
│  │  • Web3Context - 钱包连接状态                       │   │
│  │  • RainbowKitProvider - Wagmi 配置                  │   │
│  │  • TanStack Query - 数据缓存                        │   │
│  └─────────────────────────────────────────────────────┘   │
│                          ↕                                   │
│  ┌────────────────────┬────────────────────────────────┐   │
│  │   API 客户端层     │      Web3 交互层               │   │
│  │  • apiClient       │    • Wagmi Hooks               │   │
│  │  • authApi         │    • Viem (低级 API)           │   │
│  │  • contributionsApi│    • Contract ABIs             │   │
│  └────────────────────┴────────────────────────────────┘   │
│                          ↕                                   │
└──────────────────────────┼──────────────────────────────────┘
                           ↓
      ┌────────────────────────────────────────┐
      │         后端服务层                      │
      │  ┌──────────────┬──────────────────┐  │
      │  │ Next.js API  │ 智能合约 (链上)   │  │
      │  │ Routes       │ • CommitNFT      │  │
      │  │ • 认证       │ • ERC8004 系统   │  │
      │  │ • 数据查询   │ • Agent Registry │  │
      │  │ • GitHub API │                   │  │
      │  └──────────────┴──────────────────┘  │
      │              ↓                         │
      │  ┌──────────────┬──────────────────┐  │
      │  │ Supabase DB  │ Ethereum Network │  │
      │  │ (PostgreSQL) │ (Sepolia/Local)  │  │
      │  └──────────────┴──────────────────┘  │
      └────────────────────────────────────────┘
```

### 3.2 数据流向

#### 3.2.1 用户认证流程

```
1. 用户点击「GitHub 登录」
   ↓
2. 前端: authApi.githubLogin()
   → 重定向到: /api/auth/github
   ↓
3. 后端 API Route: /api/auth/github
   → 重定向到 GitHub OAuth 授权页
   ↓
4. 用户在 GitHub 上授权
   → GitHub 回调: /api/auth/callback?code=xxx
   ↓
5. 后端 API Route: /api/auth/callback
   → 用 code 换取 access_token
   → 获取用户信息
   → 存入 Supabase 数据库
   → 生成 JWT token
   → 设置 cookie + 重定向到前端
   ↓
6. 前端: localStorage 保存 token
   → useAuth() Hook 自动更新登录状态
   → UI 显示用户信息
```

#### 3.2.2 NFT 铸造流程

```
1. 用户提交贡献 (GitHub Webhook 或手动触发)
   ↓
2. 后端: contribution.service.ts
   → 验证贡献真实性
   → 计算贡献分数 (scoring.service.ts)
   → 存入 Supabase
   → 状态: pending
   ↓
3. 用户点击「铸造 NFT」
   ↓
4. 前端: 调用智能合约
   → useWriteContract() Hook
   → 调用 CommitNFT.mint()
   → 等待交易确认
   ↓
5. 交易成功
   → 后端监听事件 (可选)
   → 更新数据库状态: minted
   → 记录 tokenId
   ↓
6. 前端刷新
   → 显示 NFT 卡片
   → 可在 OpenSea 等平台查看
```

#### 3.2.3 智能合约交互流程

```
1. 组件渲染
   ↓
2. 调用自定义 Hook (如 use-agent-registry.ts)
   ↓
3. Hook 内部使用 wagmi hooks:
   • useReadContract() - 读取链上数据
   • useWriteContract() - 调用合约方法
   • useWaitForTransactionReceipt() - 等待交易确认
   ↓
4. Wagmi → Viem → RPC Node → 智能合约
   ↓
5. 链上数据返回
   ↓
6. TanStack Query 自动缓存结果
   ↓
7. 组件自动重新渲染
```

---

## 四、核心模块详解

### 4.1 Provider 层级结构

应用的 Provider 层级结构（从外到内）：

```tsx
// app/layout.tsx
<html>
  <body>
    {/* 最外层: RainbowKit + Wagmi + TanStack Query */}
    <RainbowKitProvider>
      {/* 中间层: 自定义 Web3 Context */}
      <Web3Provider>
        {/* 应用页面 */}
        {children}
        
        {/* 全局 Toast 通知 */}
        <Toaster position="top-right" />
      </Web3Provider>
    </RainbowKitProvider>
  </body>
</html>
```

**作用说明：**

1. **RainbowKitProvider**
   - 提供钱包连接 UI
   - 配置 Wagmi (以太坊交互库)
   - 配置 TanStack Query (数据缓存)
   - 配置支持的区块链网络

2. **Web3Provider**
   - 封装 wagmi hooks，提供简化的接口
   - 提供 `useWeb3()` Hook
   - 统一管理钱包连接状态

3. **Toaster**
   - 全局通知组件
   - 用于显示成功/错误/警告消息

### 4.2 Web3 交互架构

#### 4.2.1 技术选型：Viem + Wagmi

**为什么选择 Viem 而不是 Ethers.js？**

| 对比项 | Ethers.js | Viem |
|--------|-----------|------|
| **类型安全** | 部分类型，依赖运行时检查 | 完全类型安全，编译时检查 |
| **包大小** | ~350KB | ~50KB (轻 7 倍) |
| **性能** | 较慢 | 更快 (优化的序列化/反序列化) |
| **API 设计** | 面向对象 (OOP) | 函数式 (FP) |
| **Tree Shaking** | 不支持 | 完全支持 |
| **TypeScript 优先** | 后期添加 | 原生 TypeScript |

**Viem 优势示例：**

```typescript
// Ethers.js: 类型不安全
const balance = await contract.balanceOf(address); // balance: any

// Viem: 完全类型安全
const balance = await publicClient.readContract({
  address: contractAddress,
  abi: MyABI,
  functionName: 'balanceOf', // 自动补全
  args: [address], // 类型检查
}); // balance: bigint (类型明确)
```

#### 4.2.2 Wagmi Hooks 使用模式

**读取合约数据：**

```typescript
import { useReadContract } from 'wagmi';
import { CommitNFTABI } from '@/lib/contracts';

function MyComponent() {
  // 读取 NFT 总供应量
  const { data: totalSupply, isLoading, error } = useReadContract({
    address: '0x...',
    abi: CommitNFTABI,
    functionName: 'totalSupply',
  });

  if (isLoading) return <div>加载中...</div>;
  if (error) return <div>错误: {error.message}</div>;
  return <div>总供应量: {totalSupply?.toString()}</div>;
}
```

**调用合约方法：**

```typescript
import { useWriteContract, useWaitForTransactionReceipt } from 'wagmi';
import { CommitNFTABI } from '@/lib/contracts';

function MintButton() {
  const { writeContract, data: hash } = useWriteContract();
  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({ hash });

  const mint = async () => {
    writeContract({
      address: '0x...',
      abi: CommitNFTABI,
      functionName: 'mint',
      args: [recipientAddress, tokenURI],
    });
  };

  return (
    <button onClick={mint} disabled={isConfirming}>
      {isConfirming ? '铸造中...' : isSuccess ? '铸造成功' : '铸造 NFT'}
    </button>
  );
}
```

#### 4.2.3 自定义 Hook 封装

**示例：use-agent-registry.ts**

```typescript
import { useReadContract, useWriteContract } from 'wagmi';
import { AgentIdentityRegistryABI } from '@/lib/contracts';

export function useAgentRegistry() {
  // 读取 Agent 是否已注册
  const { data: isRegistered } = useReadContract({
    address: AGENT_REGISTRY_ADDRESS,
    abi: AgentIdentityRegistryABI,
    functionName: 'isAgentRegistered',
    args: [agentAddress],
  });

  // 注册 Agent
  const { writeContract: registerAgent } = useWriteContract();

  const register = (metadata: string) => {
    registerAgent({
      address: AGENT_REGISTRY_ADDRESS,
      abi: AgentIdentityRegistryABI,
      functionName: 'registerAgent',
      args: [metadata],
    });
  };

  return { isRegistered, register };
}
```

### 4.3 API 客户端架构

#### 4.3.1 Axios 实例配置

```typescript
// lib/api.ts

// 1. 创建 axios 实例
export const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api',
  headers: {
    'Content-Type': 'application/json',
  },
});

// 2. 请求拦截器：自动添加 JWT token
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 3. 响应拦截器：统一处理 401 错误
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      window.location.href = '/';
    }
    return Promise.reject(error);
  },
);
```

#### 4.3.2 API 模块化封装

```typescript
// 认证 API
export const authApi = {
  githubLogin: () => window.location.href = `${API_BASE_URL}/auth/github`,
  getProfile: async () => (await apiClient.get('/auth/user')).data,
};

// 贡献 API
export const contributionsApi = {
  getAll: async (params) => (await apiClient.get('/contributions', { params })).data,
  getOne: async (id) => (await apiClient.get(`/contributions/${id}`)).data,
  getMy: async () => (await apiClient.get('/contributions/my')).data,
  getStats: async (userId) => (await apiClient.get('/contributions/stats', { params: { userId } })).data,
};
```

### 4.4 配置管理

#### 4.4.1 环境变量分类

**前端可访问 (NEXT_PUBLIC_*)：**
- `NEXT_PUBLIC_CHAIN_ID` - 区块链 ID
- `NEXT_PUBLIC_RPC_URL` - RPC 节点地址
- `NEXT_PUBLIC_*_ADDRESS` - 智能合约地址

**仅后端可访问：**
- `DATABASE_URL` - 数据库连接串
- `GITHUB_CLIENT_SECRET` - GitHub OAuth 密钥
- `JWT_SECRET` - JWT 签名密钥
- `SEPOLIA_PRIVATE_KEY` - 部署私钥

#### 4.4.2 配置管理模块

```typescript
// lib/config/index.ts

// 配置类型定义
export interface AppConfig {
  port: number;
  nodeEnv: string;
  database: DatabaseConfig;
  github: GitHubConfig;
  jwt: JwtConfig;
  blockchain: BlockchainConfig;
  rpc: RpcConfig;
  ipfs: IpfsConfig;
  supabase: SupabaseConfig;
}

// 获取配置 (单例模式)
let configInstance: AppConfig | null = null;

export const config = (): AppConfig => {
  if (!configInstance) {
    configInstance = getConfig(); // 从环境变量读取
  }
  return configInstance;
};

// 便捷访问函数
export const getBlockchainConfig = () => config().blockchain;
export const getGitHubConfig = () => config().github;
export const getJwtConfig = () => config().jwt;
```

### 4.5 数据库访问层

#### 4.5.1 Supabase 客户端

```typescript
// lib/database/index.ts
import { createClient } from '@supabase/supabase-js';
import { getSupabaseConfig } from '@/lib/config';

const config = getSupabaseConfig();

export const supabase = createClient(
  config.url!,
  config.anonKey!
);
```

#### 4.5.2 Repository 模式

```typescript
// lib/database/repositories/users.repository.ts

export class UsersRepository {
  // 根据 GitHub ID 查找用户
  async findByGithubId(githubId: number): Promise<User | null> {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('github_id', githubId)
      .single();
    
    if (error) throw error;
    return data;
  }

  // 创建用户
  async create(user: CreateUserDto): Promise<User> {
    const { data, error } = await supabase
      .from('users')
      .insert(user)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  }
}
```

### 4.6 服务层 (Business Logic)

#### 4.6.1 认证服务

```typescript
// lib/services/auth.service.ts

export class AuthService {
  // GitHub OAuth 登录
  async githubLogin(code: string): Promise<Session> {
    // 1. 用 code 换取 access_token
    const tokenResponse = await fetch('https://github.com/login/oauth/access_token', {
      method: 'POST',
      body: JSON.stringify({
        client_id: GITHUB_CLIENT_ID,
        client_secret: GITHUB_CLIENT_SECRET,
        code,
      }),
    });

    // 2. 获取用户信息
    const userResponse = await fetch('https://api.github.com/user', {
      headers: { Authorization: `Bearer ${accessToken}` },
    });

    // 3. 存入数据库
    const user = await usersRepo.upsert(githubUser);

    // 4. 生成 JWT
    const token = await createJWT({ userId: user.id });

    return { user, token };
  }
}
```

#### 4.6.2 贡献服务

```typescript
// lib/services/contribution.service.ts

export class ContributionService {
  // 创建贡献记录
  async createContribution(data: CreateContributionDto): Promise<Contribution> {
    // 1. 验证 GitHub 数据真实性
    await this.verifyGitHubContribution(data);

    // 2. 计算贡献分数
    const score = await scoringService.calculateScore(data);

    // 3. 存入数据库
    const contribution = await contributionsRepo.create({
      ...data,
      score,
      status: 'pending',
    });

    return contribution;
  }

  // 更新铸造状态
  async updateMintStatus(id: string, tokenId: string): Promise<void> {
    await contributionsRepo.update(id, {
      status: 'minted',
      token_id: tokenId,
      minted_at: new Date(),
    });
  }
}
```

---

## 五、路由设计

### 5.1 前端页面路由

| 路径 | 文件 | 说明 |
|------|------|------|
| `/` | `app/page.tsx` | 首页 (Hero + 功能介绍) |
| `/collections` | `app/collections/page.tsx` | NFT 合集列表 |
| `/explore` | `app/explore/page.tsx` | 探索页面 (发现贡献) |
| `/mint/new` | `app/mint/new/page.tsx` | 铸造新 NFT |
| `/roadmap` | `app/roadmap/page.tsx` | 产品路线图 |
| `/erc8004/contributions` | `app/erc8004/contributions/page.tsx` | ERC8004 贡献验证 |
| `/erc8004/validate` | `app/erc8004/validate/page.tsx` | ERC8004 验证工具 |

### 5.2 API 路由

| 方法 | 路径 | 文件 | 说明 |
|------|------|------|------|
| GET | `/api/auth/github` | `app/api/auth/github/route.ts` | 发起 GitHub OAuth |
| GET | `/api/auth/callback` | `app/api/auth/callback/route.ts` | GitHub OAuth 回调 |
| GET | `/api/auth/user` | `app/api/auth/user/route.ts` | 获取当前用户 |
| POST | `/api/auth/logout` | `app/api/auth/logout/route.ts` | 用户登出 |
| GET | `/api/contributions` | `app/api/contributions/route.ts` | 查询贡献列表 |
| POST | `/api/contributions` | `app/api/contributions/route.ts` | 创建贡献 |
| GET | `/api/contributions/[id]` | `app/api/contributions/[id]/route.ts` | 查询单个贡献 |
| PATCH | `/api/contributions/[id]` | `app/api/contributions/[id]/route.ts` | 更新贡献 |
| GET | `/api/contributions/my` | `app/api/contributions/my/route.ts` | 我的贡献 |
| GET | `/api/contributions/stats` | `app/api/contributions/stats/route.ts` | 贡献统计 |
| GET | `/api/github/repos` | `app/api/github/route.ts` | 查询用户仓库 |
| GET | `/api/health` | `app/api/health/route.ts` | 健康检查 |
| POST | `/api/ipfs/upload` | `app/api/ipfs/route.ts` | 上传到 IPFS |

---

## 六、状态管理

### 6.1 状态管理策略

LightCommit 采用**混合状态管理策略**：

| 状态类型 | 管理方式 | 用途 |
|----------|---------|------|
| **钱包状态** | Wagmi + Web3Context | 钱包地址、连接状态、网络 ID |
| **链上数据** | Wagmi + TanStack Query | 合约状态、NFT 数据、余额 |
| **服务端数据** | TanStack Query (手动) | 用户数据、贡献列表、统计信息 |
| **本地 UI 状态** | React State (useState) | 弹窗显示、表单输入、加载状态 |
| **全局 UI 状态** | React Context | 主题、语言、通知 |

### 6.2 数据缓存策略

#### 6.2.1 TanStack Query 自动缓存（链上数据）

```typescript
// Wagmi 的 useReadContract 内部使用 TanStack Query
const { data: totalSupply } = useReadContract({
  address: contractAddress,
  abi: CommitNFTABI,
  functionName: 'totalSupply',
  // 自动缓存，默认 5 分钟过期
});
```

#### 6.2.2 手动配置缓存（服务端数据）

```typescript
// hooks/use-contributions.ts
import { useQuery } from '@tanstack/react-query';

export function useContributions() {
  return useQuery({
    queryKey: ['contributions'],
    queryFn: () => contributionsApi.getAll(),
    staleTime: 5 * 60 * 1000, // 5 分钟内不重新请求
    cacheTime: 10 * 60 * 1000, // 缓存保留 10 分钟
    refetchOnWindowFocus: true, // 窗口重新聚焦时刷新
  });
}
```

### 6.3 乐观更新（Optimistic Updates）

```typescript
// 铸造 NFT 时的乐观更新
const { writeContract } = useWriteContract({
  mutation: {
    onMutate: async () => {
      // 立即更新 UI（假设成功）
      queryClient.setQueryData(['contributions'], (old) => {
        return old.map(c => 
          c.id === contributionId 
            ? { ...c, status: 'minting' } 
            : c
        );
      });
    },
    onSuccess: () => {
      // 交易成功，刷新数据
      queryClient.invalidateQueries(['contributions']);
    },
    onError: () => {
      // 交易失败，回滚 UI
      queryClient.invalidateQueries(['contributions']);
    },
  },
});
```

---

## 七、性能优化

### 7.1 代码分割（Code Splitting）

#### 7.1.1 Next.js 自动代码分割

- 每个页面自动分割成独立的 JS 文件
- 只加载当前页面需要的代码
- 路由切换时按需加载

#### 7.1.2 动态导入（Dynamic Import）

```typescript
// 懒加载大型组件
import dynamic from 'next/dynamic';

const HeavyChart = dynamic(() => import('@/components/HeavyChart'), {
  loading: () => <div>加载图表中...</div>,
  ssr: false, // 关闭 SSR（仅客户端渲染）
});
```

### 7.2 渲染优化

#### 7.2.1 React Server Components

```typescript
// app/collections/page.tsx
// 默认是 Server Component，在服务端渲染

export default async function CollectionsPage() {
  // 服务端直接查询数据库（无需 API 请求）
  const collections = await db.collections.findMany();
  
  return <CollectionList collections={collections} />;
}
```

#### 7.2.2 客户端组件按需标记

```typescript
// 只在需要交互的组件标记 'use client'
'use client';

import { useState } from 'react';

export function InteractiveButton() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

### 7.3 缓存策略

#### 7.3.1 Next.js 数据缓存

```typescript
// 使用 fetch 自动缓存（服务端）
const data = await fetch('https://api.example.com/data', {
  next: { revalidate: 3600 }, // 缓存 1 小时
});
```

#### 7.3.2 浏览器缓存

```typescript
// public/ 目录下的静态资源自动设置缓存头
// • 图片、字体: Cache-Control: public, max-age=31536000, immutable
// • HTML: Cache-Control: no-cache
```

### 7.4 图片优化

```typescript
// 使用 Next.js Image 组件
import Image from 'next/image';

<Image
  src="/assets/hero.png"
  alt="Hero"
  width={800}
  height={600}
  priority // 优先加载（首屏图片）
  placeholder="blur" // 加载时显示模糊占位符
/>
```

### 7.5 Bundle 优化

#### 7.5.1 Tree Shaking

- Viem 完全支持 Tree Shaking（只打包使用的函数）
- Lodash 使用独立导入：`import isEmpty from 'lodash/isEmpty'`

#### 7.5.2 分析工具

```bash
# 分析 Bundle 大小
npm run build
npx @next/bundle-analyzer
```

---

## 八、安全设计

### 8.1 前端安全

#### 8.1.1 XSS 防护

- React 自动转义用户输入
- 避免使用 `dangerouslySetInnerHTML`
- 使用 DOMPurify 清理 HTML（如需渲染富文本）

#### 8.1.2 CSRF 防护

- 使用 SameSite Cookie
- API 请求携带 CSRF Token

#### 8.1.3 敏感信息保护

```typescript
// ✅ 正确：私钥不暴露到前端
const PRIVATE_KEY = process.env.SEPOLIA_PRIVATE_KEY; // 仅后端可访问

// ❌ 错误：不要在前端使用私钥
const PRIVATE_KEY = process.env.NEXT_PUBLIC_PRIVATE_KEY; // 会被打包到浏览器！
```

### 8.2 Web3 安全

#### 8.2.1 交易签名验证

```typescript
// 用户签名验证（防止伪造请求）
const message = `验证钱包所有权\nNonce: ${nonce}`;
const signature = await walletClient.signMessage({ message });

// 后端验证签名
const recovered = await verifyMessage({ message, signature });
if (recovered !== address) {
  throw new Error('签名验证失败');
}
```

#### 8.2.2 合约地址白名单

```typescript
// lib/config/index.ts
export const ALLOWED_CONTRACTS = [
  process.env.NEXT_PUBLIC_COMMIT_NFT_ADDRESS,
  process.env.NEXT_PUBLIC_AGENT_REGISTRY_ADDRESS,
  // ...
];

// 调用合约前检查地址
if (!ALLOWED_CONTRACTS.includes(contractAddress)) {
  throw new Error('不允许的合约地址');
}
```

#### 8.2.3 Gas Limit 保护

```typescript
// 设置合理的 Gas Limit（防止消耗过多 Gas）
const { writeContract } = useWriteContract({
  gas: 300000n, // 最大 30 万 Gas
});
```

### 8.3 API 安全

#### 8.3.1 JWT 认证

```typescript
// lib/auth/session.ts
import { SignJWT, jwtVerify } from 'jose';

// 创建 JWT
export async function createJWT(payload: JWTPayload): Promise<string> {
  const secret = new TextEncoder().encode(JWT_SECRET);
  const jwt = await new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setExpirationTime('7d')
    .sign(secret);
  return jwt;
}

// 验证 JWT
export async function verifyJWT(token: string): Promise<JWTPayload> {
  const secret = new TextEncoder().encode(JWT_SECRET);
  const { payload } = await jwtVerify(token, secret);
  return payload;
}
```

#### 8.3.2 API 请求认证

```typescript
// app/api/contributions/route.ts
import { verifyJWT } from '@/lib/auth/session';

export async function GET(request: Request) {
  // 从请求头获取 token
  const token = request.headers.get('Authorization')?.replace('Bearer ', '');
  
  if (!token) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    // 验证 token
    const payload = await verifyJWT(token);
    const userId = payload.userId;

    // 查询用户的贡献
    const contributions = await contributionsRepo.findByUserId(userId);
    return NextResponse.json(contributions);
  } catch (error) {
    return NextResponse.json({ error: 'Invalid token' }, { status: 401 });
  }
}
```

---

## 九、测试策略

### 9.1 单元测试

```typescript
// __tests__/lib/utils.test.ts
import { cn } from '@/lib/utils';

describe('cn utility', () => {
  it('should merge class names', () => {
    expect(cn('px-4', 'py-2')).toBe('px-4 py-2');
  });

  it('should handle conditional classes', () => {
    expect(cn('base', { active: true, disabled: false })).toBe('base active');
  });
});
```

### 9.2 组件测试

```typescript
// __tests__/components/Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from '@/components/ui/button';

describe('Button', () => {
  it('should render with text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('should call onClick handler', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    fireEvent.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### 9.3 E2E 测试（Playwright）

```typescript
// e2e/login.spec.ts
import { test, expect } from '@playwright/test';

test('GitHub login flow', async ({ page }) => {
  // 1. 访问首页
  await page.goto('http://localhost:3000');

  // 2. 点击登录按钮
  await page.click('text=GitHub 登录');

  // 3. 在 GitHub 上授权（需要 mock）
  // ...

  // 4. 验证登录成功
  await expect(page.locator('text=欢迎')).toBeVisible();
});
```

---

## 十、部署与运维

### 10.1 环境配置

#### 10.1.1 开发环境（Development）

```bash
# frontend/.env
NODE_ENV=development
NEXT_PUBLIC_CHAIN_ID=31337
NEXT_PUBLIC_RPC_URL=http://localhost:8545

# Supabase (本地)
SUPABASE_URL=http://localhost:54321
SUPABASE_ANON_KEY=your-local-anon-key

# GitHub OAuth (测试应用)
GITHUB_CLIENT_ID=your-dev-client-id
GITHUB_CLIENT_SECRET=your-dev-client-secret
```

#### 10.1.2 生产环境（Production）

```bash
# Vercel 环境变量
NODE_ENV=production
NEXT_PUBLIC_CHAIN_ID=11155111 # Sepolia
NEXT_PUBLIC_RPC_URL=https://sepolia.infura.io/v3/YOUR_KEY

# Supabase (生产)
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-production-anon-key

# GitHub OAuth (生产应用)
GITHUB_CLIENT_ID=your-prod-client-id
GITHUB_CLIENT_SECRET=your-prod-client-secret

# JWT (强随机密钥)
JWT_SECRET=your-strong-random-secret-at-least-32-chars
```

### 10.2 部署平台

#### 10.2.1 Vercel（推荐）

**优势：**
- Next.js 官方支持
- 自动 CI/CD（Git Push 即部署）
- 全球 CDN
- 免费 SSL
- 自动扩容

**部署步骤：**

```bash
# 1. 安装 Vercel CLI
npm i -g vercel

# 2. 登录
vercel login

# 3. 部署
cd frontend
vercel

# 4. 设置环境变量
vercel env add NEXT_PUBLIC_CHAIN_ID
vercel env add SUPABASE_URL
# ...
```

#### 10.2.2 Docker 部署（自托管）

```dockerfile
# Dockerfile
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine AS runner
WORKDIR /app
COPY --from=builder /app/.next ./.next
COPY --from=builder /app/public ./public
COPY --from=builder /app/package*.json ./
RUN npm ci --production
EXPOSE 3000
CMD ["npm", "start"]
```

### 10.3 监控与日志

#### 10.3.1 错误监控（Sentry）

```typescript
// lib/sentry.ts
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 1.0,
  environment: process.env.NODE_ENV,
});
```

#### 10.3.2 性能监控（Vercel Analytics）

```typescript
// app/layout.tsx
import { Analytics } from '@vercel/analytics/react';

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        {children}
        <Analytics />
      </body>
    </html>
  );
}
```

---

## 十一、开发工作流

### 11.1 本地开发

```bash
# 1. 安装依赖
cd frontend
npm install

# 2. 配置环境变量
cp env.example .env
# 编辑 .env 文件

# 3. 启动 Hardhat 本地网络（另一个终端）
cd ../hardhat
npm run node

# 4. 部署合约
npm run deploy:local

# 5. 启动前端开发服务器
cd ../frontend
npm run dev

# 6. 打开浏览器
open http://localhost:3000
```

### 11.2 代码规范

#### 11.2.1 ESLint

```bash
# 检查代码
npm run lint

# 自动修复
npm run lint -- --fix
```

#### 11.2.2 TypeScript

```bash
# 类型检查
npm run type-check
```

### 11.3 Git 工作流

```bash
# 1. 创建功能分支
git checkout -b feature/agent-registry

# 2. 开发 + 提交
git add .
git commit -m "feat: 实现 Agent 注册功能"

# 3. 推送到远程
git push origin feature/agent-registry

# 4. 创建 Pull Request
# 在 GitHub 上创建 PR，等待 Review

# 5. 合并到 main
# Review 通过后，合并 PR
```

---

## 十二、常见问题

### Q1: 为什么选择 Next.js 而不是 Vite + React？

**答：**
- **SEO 友好**：Next.js 支持 SSR/SSG，有利于 SEO
- **API Routes**：无需单独的后端框架，直接在 Next.js 中写 API
- **文件路由**：约定式路由，无需手动配置
- **生产优化**：自动代码分割、图片优化、字体优化
- **Vercel 集成**：一键部署，零配置 CDN

### Q2: 为什么使用 Supabase 而不是自建 PostgreSQL？

**答：**
- **开箱即用**：无需配置服务器、数据库、备份
- **实时订阅**：内置 Realtime 功能（WebSocket）
- **认证系统**：内置 OAuth、JWT 认证
- **Row Level Security**：数据库级别的权限控制
- **免费额度**：小型项目免费，大项目再付费

### Q3: 为什么 Wagmi + Viem 而不是直接用 Ethers.js？

**答：**
- **类型安全**：Viem 完全类型安全，Ethers.js 部分类型
- **更小体积**：Viem ~50KB，Ethers.js ~350KB
- **React 集成**：Wagmi 专为 React 设计，提供优秀的 Hooks
- **现代化**：Viem 原生 TypeScript，Ethers.js 是 JS 转 TS
- **缓存优化**：Wagmi 内置 TanStack Query 缓存

### Q4: 为什么用 TanStack Query 而不是 Redux？

**答：**
- **服务端数据**：TanStack Query 专为服务端数据设计
- **自动缓存**：无需手动管理缓存失效、重新加载
- **更少代码**：无需写 actions、reducers、selectors
- **开箱即用**：loading、error、refetch 状态自动管理
- **与 Wagmi 集成**：Wagmi 内部使用 TanStack Query

### Q5: 前端如何安全地存储私钥？

**答：前端**绝不应该**存储私钥！
- **错误做法**：在前端代码中存储私钥（任何人都能看到）
- **正确做法**：
  - 用户私钥：由钱包（MetaMask）管理，前端只请求签名
  - 服务端私钥：存储在后端环境变量，前端无法访问

---

## 十三、未来规划

### 13.1 技术升级

- [ ] 升级到 React 19 Compiler（自动优化）
- [ ] 使用 Server Actions 替代部分 API Routes
- [ ] 支持 Progressive Web App (PWA)
- [ ] 实现 Incremental Static Regeneration (ISR)

### 13.2 功能扩展

- [ ] 支持多链（Polygon、Arbitrum、Optimism）
- [ ] 实现 NFT 市场（买卖、拍卖）
- [ ] 支持 DAO 治理（投票、提案）
- [ ] AI 评分系统（智能分析代码质量）

### 13.3 性能优化

- [ ] 实现虚拟滚动（大列表性能优化）
- [ ] 使用 Web Workers（计算密集任务）
- [ ] 实现 Skeleton Loading（更好的加载体验）
- [ ] 使用 Service Worker（离线支持）

---

## 参考资料

### 官方文档

- [Next.js 文档](https://nextjs.org/docs)
- [React 文档](https://react.dev/)
- [Wagmi 文档](https://wagmi.sh/)
- [Viem 文档](https://viem.sh/)
- [RainbowKit 文档](https://www.rainbowkit.com/)
- [TanStack Query 文档](https://tanstack.com/query/latest)
- [Supabase 文档](https://supabase.com/docs)
- [Tailwind CSS 文档](https://tailwindcss.com/docs)

### 相关文档

- [系统架构与实现](./系统架构与实现.md)
- [智能合约文档](./contracts.md)
- [ERC8004 实现](./ERC8004_IMPLEMENTATION.md)
- [GitHub OAuth 配置](./GITHUB_OAUTH_SETUP.md)
- [Viem 迁移指南](./VIEM_MIGRATION.md)

---

**文档维护者：** LightCommit 团队  
**最后更新：** 2025-11-14




