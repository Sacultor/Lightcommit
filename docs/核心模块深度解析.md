# LightCommit 核心模块深度解析

> 本文档提供前端核心模块的代码级详细解析，包括设计思路、实现细节和使用示例

## 目录

1. [认证系统](#一认证系统)
2. [Web3 交互层](#二web3-交互层)
3. [API 客户端层](#三api-客户端层)
4. [数据访问层](#四数据访问层)
5. [服务层](#五服务层)
6. [Hooks 层](#六hooks-层)
7. [配置管理](#七配置管理)

---

## 一、认证系统

### 1.1 JWT Session 管理（`lib/auth/session.ts`）

#### 核心概念

**JWT (JSON Web Token)** 是一种安全传输信息的标准格式：

```
JWT 结构：Header.Payload.Signature

示例：
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.    ← Header（算法、类型）
eyJ1c2VyIjp7ImlkIjoxMjMsImxvZ2luIjoib2N0b2NhdCJ9fQ.  ← Payload（数据）
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c     ← Signature（签名）
```

**特点：**
- 服务端签名，客户端无法篡改
- 无需在服务端存储 session，节省资源
- 自包含，包含所有必要信息

#### 数据结构

```typescript
/**
 * Session 数据结构
 * 
 * 存储在 JWT 中的数据（会被编码但不加密）
 * 注意：不要存储密码等敏感信息
 */
export interface SessionData {
  user: {
    id: number;              // GitHub 用户 ID
    login: string;           // GitHub 用户名（如 "octocat"）
    name: string | null;     // GitHub 显示名
    email: string | null;    // GitHub 邮箱
    avatar_url: string;      // GitHub 头像 URL
  };
  accessToken: string;       // GitHub access_token（用于调用 GitHub API）
  createdAt: number;         // Session 创建时间戳（毫秒）
  expiresAt: number;         // Session 过期时间戳（毫秒）
}
```

#### 核心函数

##### 1. 创建 JWT Token

```typescript
/**
 * 创建 JWT token
 * 
 * 将 Session 数据打包成 JWT 字符串
 * 
 * 工作流程：
 * 1. 设置 Header（alg: HS256）
 * 2. 设置 Payload（sessionData）
 * 3. 设置过期时间（30 天）
 * 4. 使用密钥签名
 */
export async function createSession(sessionData: SessionData): Promise<string> {
  const token = await new SignJWT({ ...sessionData })    // Payload
    .setProtectedHeader({ alg: 'HS256' })                // Header
    .setIssuedAt()                                        // iat（签发时间）
    .setExpirationTime(`${SESSION_CONFIG.maxAge}s`)      // exp（过期时间：30天）
    .sign(SESSION_CONFIG.secret);                        // 签名

  return token;
}
```

**安全性分析：**
- ✅ JWT 签名防篡改（需要 secret 才能伪造）
- ✅ 自动过期（30 天后失效）
- ⚠️ JWT 是编码而非加密（任何人都能解码查看内容）
- ⚠️ 无法主动撤销（只能等待过期）

##### 2. 验证 JWT Token

```typescript
/**
 * 验证 JWT token 并解析数据
 * 
 * 验证内容：
 * - 签名是否正确（防止篡改）
 * - JWT 是否过期
 * - 格式是否正确
 */
export async function verifySession(token: string): Promise<SessionData | null> {
  try {
    // jwtVerify 会自动检查签名和过期时间
    const { payload } = await jwtVerify(token, SESSION_CONFIG.secret);
    return payload as unknown as SessionData;
  } catch (error) {
    console.error('JWT 验证失败:', error);
    return null;  // 验证失败返回 null
  }
}
```

**验证失败的情况：**
- JWT 格式错误（不是三段式）
- 签名验证失败（被篡改或使用了错误的 secret）
- JWT 已过期（exp 时间早于当前时间）

##### 3. Cookie 操作

```typescript
/**
 * 从 Cookies 中获取 Session
 * 
 * 工作流程：
 * 1. 从 Cookie 中读取 JWT token
 * 2. 验证 JWT 的有效性
 * 3. 解析并返回 Session 数据
 */
export async function getSession(): Promise<SessionData | null> {
  const cookieStore = await cookies();                    // Next.js Cookie API
  const token = cookieStore.get(SESSION_CONFIG.cookieName)?.value;
  
  if (!token) return null;                                // 未登录
  
  return await verifySession(token);                      // 验证并返回
}

/**
 * 设置 Session Cookie
 * 
 * Cookie 安全属性：
 * - httpOnly: JavaScript 无法访问（防 XSS）
 * - secure: 仅 HTTPS 传输（防中间人攻击）
 * - sameSite: 防 CSRF 攻击
 * - maxAge: 30 天过期
 */
export async function setSessionCookie(sessionData: SessionData): Promise<void> {
  const token = await createSession(sessionData);
  const cookieStore = await cookies();
  
  cookieStore.set(SESSION_CONFIG.cookieName, token, {
    httpOnly: true,                                // ← 核心安全特性
    secure: process.env.NODE_ENV === 'production', // 生产环境强制 HTTPS
    sameSite: 'lax',                               // 防 CSRF
    maxAge: SESSION_CONFIG.maxAge,                 // 30 天
    path: '/',                                     // 全站可用
  });
}

/**
 * 清除 Session Cookie（登出）
 */
export async function clearSessionCookie(): Promise<void> {
  const cookieStore = await cookies();
  cookieStore.delete(SESSION_CONFIG.cookieName);
}
```

#### 使用示例

##### 场景一：GitHub OAuth 回调

```typescript
// app/api/auth/callback/route.ts
import { setSessionCookie, getGitHubUser } from '@/lib/auth/session';

export async function GET(request: Request) {
  // 1. 从 GitHub 获取 access_token
  const accessToken = await exchangeCodeForToken(code);
  
  // 2. 使用 access_token 获取用户信息
  const githubUser = await getGitHubUser(accessToken);
  
  // 3. 创建 Session 数据
  const sessionData = {
    user: {
      id: githubUser.id,
      login: githubUser.login,
      name: githubUser.name,
      email: githubUser.email,
      avatar_url: githubUser.avatar_url,
    },
    accessToken,
    createdAt: Date.now(),
    expiresAt: Date.now() + 30 * 24 * 60 * 60 * 1000,
  };
  
  // 4. 设置 Session Cookie
  await setSessionCookie(sessionData);
  
  // 5. 重定向到首页
  return NextResponse.redirect(new URL('/', request.url));
}
```

##### 场景二：API 路由鉴权

```typescript
// app/api/contributions/my/route.ts
import { getSession } from '@/lib/auth/session';

export async function GET(request: Request) {
  // 1. 获取当前用户 session
  const session = await getSession();
  
  // 2. 检查是否登录
  if (!session) {
    return NextResponse.json({ error: '未登录' }, { status: 401 });
  }
  
  // 3. 使用 session.user 获取用户信息
  const userId = session.user.id;
  const contributions = await ContributionRepository.findByUserId(userId);
  
  return NextResponse.json(contributions);
}
```

### 1.2 认证服务（`lib/services/auth.service.ts`）

#### 功能概述

封装前端调用的认证相关方法，与 `/api/auth/*` 路由配合使用。

#### 核心方法

```typescript
export class AuthService {
  /**
   * GitHub OAuth 登录
   * 
   * 重定向到 /api/auth/github，发起 GitHub OAuth 流程
   */
  static async signInWithGitHub(redirectTo?: string) {
    const url = '/api/auth/github';
    if (typeof window !== 'undefined') {
      window.location.href = url;
    }
    return { url };
  }

  /**
   * 登出
   * 
   * 调用 /api/auth/logout 清除 JWT session
   */
  static async signOut() {
    const response = await fetch('/api/auth/logout', {
      method: 'POST',
    });

    if (!response.ok) {
      throw new Error('登出失败');
    }

    return await response.json();
  }

  /**
   * 获取当前用户 session（客户端）
   * 
   * 调用 /api/auth/user 获取 JWT session
   */
  static async getSession(): Promise<{ session: SessionData | null; error: any }> {
    try {
      const response = await fetch('/api/auth/user', {
        credentials: 'include', // ← 确保发送 cookies
      });

      if (!response.ok) {
        if (response.status === 401) {
          return { session: null, error: null }; // 未登录
        }
        throw new Error('获取 session 失败');
      }

      const data = await response.json();
      return { session: data.session, error: null };
    } catch (error) {
      return { session: null, error };
    }
  }

  /**
   * 获取当前用户信息（客户端）
   */
  static async getUser(): Promise<{ user: SessionData['user'] | null; error: any }> {
    const { session, error } = await this.getSession();

    if (error || !session) {
      return { user: null, error };
    }

    return { user: session.user, error: null };
  }
}
```

---

## 二、Web3 交互层

### 2.1 RainbowKit Provider（`lib/contexts/RainbowKitProvider.tsx`）

#### 技术选型

| 库 | 作用 | 为什么选它 |
|---|------|-----------|
| **Wagmi** | React Hooks for Ethereum | 专为 React 设计，提供优秀的 Hooks API |
| **Viem** | TypeScript 以太坊库 | 类型安全、轻量（~50KB）、Tree Shaking 友好 |
| **RainbowKit** | 钱包连接 UI | 美观的钱包连接界面，支持多种钱包 |
| **TanStack Query** | 数据缓存 | 自动缓存链上数据，避免重复请求 |

#### Provider 层级结构

```tsx
export function RainbowKitProvider({ children }: { children: ReactNode }) {
  return (
    // 1. WagmiProvider：提供 Web3 能力（wagmi hooks）
    <WagmiProvider config={config}>
      {/* 2. QueryClientProvider：提供数据缓存能力 */}
      <QueryClientProvider client={queryClient}>
        {/* 3. RKProvider：提供钱包连接 UI */}
        <RKProvider modalSize="compact">
          {children}
        </RKProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

**层级说明：**
1. **WagmiProvider**（最外层）：提供以太坊交互能力
   - 配置支持的区块链网络
   - 配置钱包连接器（MetaMask）
   - 配置 RPC 传输方式

2. **QueryClientProvider**（中间层）：提供数据缓存
   - 缓存 wagmi hooks 的查询结果
   - 自动重试失败的请求
   - 自动刷新过期数据

3. **RKProvider**（内层）：提供钱包连接 UI
   - 美观的钱包选择弹窗
   - 账户信息展示
   - 网络切换功能

#### Wagmi 配置

```typescript
/**
 * 自定义链配置：Hardhat Local
 */
const hardhatLocal = defineChain({
  id: 31337,                    // 链 ID（Hardhat 默认）
  name: 'Hardhat Local',        // 显示名称
  nativeCurrency: {
    decimals: 18,               // ETH 精度
    name: 'Ethereum',
    symbol: 'ETH',
  },
  rpcUrls: {
    default: { http: ['http://127.0.0.1:8545'] },  // RPC 节点地址
  },
  testnet: true,                // 标记为测试网
});

/**
 * Wagmi 配置
 */
const config = createConfig({
  chains: [hardhatLocal],       // 支持的链
  transports: {
    [hardhatLocal.id]: http('http://127.0.0.1:8545'),  // RPC 传输
  },
  connectors: [
    injected({
      shimDisconnect: true,     // 支持断开连接
    }),
  ],
});
```

### 2.2 Web3 Context（`lib/contexts/Web3Context.tsx`）

#### 设计思路

封装 wagmi hooks，提供统一的 Web3 接口，简化组件使用。

#### 核心接口

```typescript
interface Web3ContextType {
  address: string | undefined;           // 钱包地址（viem 格式）
  isConnected: boolean;                  // 是否已连接钱包
  chainId: number | undefined;           // 当前链 ID
  isCorrectNetwork: boolean;             // 是否在正确的网络
  connect: () => void;                   // 连接钱包
  disconnect: () => void;                // 断开钱包
  switchNetwork: (chainId: number) => void;  // 切换网络
}
```

#### 实现代码

```typescript
export function Web3Provider({ children }: { children: ReactNode }) {
  // 1. Wagmi hooks
  const { address, isConnected } = useAccount();
  const { connect, connectors } = useConnect();
  const { disconnect } = useDisconnect();
  const chainId = useChainId();
  const { switchChain } = useSwitchChain();

  // 2. 连接 MetaMask 钱包
  const connectWallet = () => {
    const injected = connectors.find(c => c.type === 'injected');
    if (injected) {
      connect({ connector: injected });
    }
  };

  // 3. 切换网络
  const switchNetwork = (targetChainId: number) => {
    switchChain({ chainId: targetChainId });
  };

  // 4. 检查是否在正确的网络
  const targetChainId = parseInt(process.env.NEXT_PUBLIC_CHAIN_ID || '31337');
  const isCorrectNetwork = chainId === targetChainId;

  const value: Web3ContextType = {
    address,
    isConnected,
    chainId,
    isCorrectNetwork,
    connect: connectWallet,
    disconnect,
    switchNetwork,
  };

  return <Web3Context.Provider value={value}>{children}</Web3Context.Provider>;
}
```

#### 使用示例

```typescript
// 在组件中使用
function MyComponent() {
  const { address, isConnected, connect, disconnect } = useWeb3();

  if (!isConnected) {
    return <button onClick={connect}>连接钱包</button>;
  }

  return (
    <div>
      <p>地址: {address}</p>
      <button onClick={disconnect}>断开连接</button>
    </div>
  );
}
```

### 2.3 智能合约交互

#### 读取合约数据

```typescript
import { useReadContract } from 'wagmi';
import { CommitNFTABI } from '@/lib/contracts';

function MyComponent() {
  // 读取 NFT 总供应量
  const { data: totalSupply, isLoading, error } = useReadContract({
    address: '0x...',
    abi: CommitNFTABI,
    functionName: 'totalSupply',
  });

  if (isLoading) return <div>加载中...</div>;
  if (error) return <div>错误: {error.message}</div>;
  return <div>总供应量: {totalSupply?.toString()}</div>;
}
```

**Viem 类型安全：**
```typescript
// ✅ Viem：完全类型安全
const { data: balance } = useReadContract({
  address: contractAddress,
  abi: MyABI,
  functionName: 'balanceOf',  // ← 自动补全，类型检查
  args: [address],            // ← 自动检查参数类型
});
// balance: bigint（类型明确）

// ❌ Ethers.js：类型不安全
const balance = await contract.balanceOf(address);
// balance: any（需要运行时检查）
```

#### 调用合约方法

```typescript
import { useWriteContract, useWaitForTransactionReceipt } from 'wagmi';
import { CommitNFTABI } from '@/lib/contracts';

function MintButton() {
  // 1. 获取 writeContract 函数和交易哈希
  const { writeContract, data: hash } = useWriteContract();
  
  // 2. 等待交易确认
  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({ hash });

  // 3. 铸造 NFT
  const mint = async () => {
    writeContract({
      address: '0x...',
      abi: CommitNFTABI,
      functionName: 'mint',
      args: [recipientAddress, tokenURI],
    });
  };

  return (
    <button onClick={mint} disabled={isConfirming}>
      {isConfirming ? '铸造中...' : isSuccess ? '铸造成功' : '铸造 NFT'}
    </button>
  );
}
```

---

## 三、API 客户端层

### 3.1 Axios 实例配置（`lib/api.ts`）

#### 创建实例

```typescript
/**
 * apiClient：统一的 HTTP 客户端实例
 * 
 * 配置：
 * - baseURL: API 基础 URL
 * - headers: 默认请求头
 */
export const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api',
  headers: {
    'Content-Type': 'application/json',
  },
});
```

#### 请求拦截器

```typescript
/**
 * 请求拦截器：自动添加认证 Token
 */
apiClient.interceptors.request.use((config) => {
  // 从 localStorage 读取 token
  const token = typeof window !== 'undefined' ? localStorage.getItem('token') : null;
  
  // 如果 token 存在，添加到请求头
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  
  return config;
});
```

**工作原理：**
1. 每次发送请求前自动执行
2. 从 localStorage 读取 token
3. 添加到 `Authorization` 请求头
4. 后端通过这个 header 识别用户身份

#### 响应拦截器

```typescript
/**
 * 响应拦截器：统一处理 401 错误
 */
apiClient.interceptors.response.use(
  (response) => response,  // 成功响应直接返回
  (error) => {
    // 检测到 401 错误（未授权）
    if (error.response?.status === 401) {
      if (typeof window !== 'undefined') {
        // 清除失效的 token
        localStorage.removeItem('token');
        // 重定向到首页
        window.location.href = '/';
      }
    }
    return Promise.reject(error);
  },
);
```

**工作原理：**
1. 收到 401 响应（未授权/登录过期）
2. 清除本地的 token
3. 重定向到首页（触发重新登录）

### 3.2 API 模块化封装

#### 认证 API

```typescript
export const authApi = {
  /**
   * GitHub OAuth 登录
   * 
   * 重定向到后端 API：/api/auth/github
   */
  githubLogin: () => {
    window.location.href = `${API_BASE_URL}/auth/github`;
  },

  /**
   * 获取当前用户信息
   * 
   * 请求：GET /api/auth/user
   * 返回：{ session: { user: {...}, accessToken: '...' } }
   */
  getProfile: async () => {
    const response = await apiClient.get('/auth/user');
    return response.data;
  },
};
```

#### 贡献 API

```typescript
export const contributionsApi = {
  /**
   * 获取所有贡献列表（支持筛选）
   */
  getAll: async (params?: {
    type?: string;
    status?: string;
    userId?: string;
    repositoryId?: string;
  }) => {
    // params 会自动转换为查询字符串
    // { type: 'commit', status: 'pending' } → ?type=commit&status=pending
    const response = await apiClient.get('/contributions', { params });
    return response.data;
  },

  /**
   * 获取单个贡献详情
   */
  getOne: async (id: string) => {
    const response = await apiClient.get(`/contributions/${id}`);
    return response.data;
  },

  /**
   * 获取当前用户的贡献列表
   */
  getMy: async () => {
    const response = await apiClient.get('/contributions/my');
    return response.data;
  },

  /**
   * 获取贡献统计信息
   */
  getStats: async (userId?: string) => {
    const response = await apiClient.get('/contributions/stats', {
      params: { userId },
    });
    return response.data;
  },
};
```

---

## 四、数据访问层

### 4.1 数据库抽象层（`lib/database/index.ts`）

#### 设计模式：Repository Pattern

**Repository 模式的优势：**
1. 隔离数据库实现细节
2. 便于单元测试（可以 mock repository）
3. 便于未来迁移数据库（只需修改 repository 层）
4. 提供统一的数据访问接口

#### 统一查询接口

```typescript
/**
 * 数据库查询结果接口
 * 
 * 兼容 pg (node-postgres) 的 QueryResult 格式
 */
export interface QueryResult<T = any> {
  rows: T[];            // 查询结果行
  rowCount: number;     // 结果行数
  command: string;      // SQL 命令类型（SELECT/INSERT/UPDATE/DELETE）
  oid: number;          // 对象 ID（PostgreSQL 特有）
  fields: any[];        // 字段信息
}

/**
 * 执行数据库查询
 * 
 * 使用示例：
 * ```typescript
 * const result = await query<User>(
 *   'SELECT * FROM users WHERE id = $1',
 *   [userId]
 * );
 * const users = result.rows;
 * ```
 */
export const query = async <T = any>(text: string, params?: unknown[]): Promise<QueryResult<T>> => {
  const start = Date.now();  // 记录开始时间

  try {
    // 1. 获取 Supabase 服务实例
    const supabaseService = getSupabaseService();
    
    // 2. 执行查询
    const result = await supabaseService.query(text, params);

    // 3. 转换为标准 QueryResult 格式
    const res: QueryResult<T> = {
      rows: Array.isArray(result) ? result : (result ? [result] : []),
      rowCount: Array.isArray(result) ? result.length : (result ? 1 : 0),
      command: text.trim().split(' ')[0].toUpperCase(),
      oid: 0,
      fields: [],
    };

    // 4. 性能日志（仅开发环境）
    const duration = Date.now() - start;
    if (process.env.NODE_ENV === 'development') {
      console.log('Executed query', {
        text: text.substring(0, 100),
        duration,
        rows: res.rowCount,
        connectionType: 'supabase',
      });
    }

    return res;
  } catch (error) {
    console.error('Database query error:', error);
    throw error;
  }
};
```

#### 事务支持

```typescript
/**
 * 在事务中执行多个查询
 * 
 * 使用示例：
 * ```typescript
 * await transaction(async (client) => {
 *   await client.from('users').insert({ ... });
 *   await client.from('contributions').insert({ ... });
 * });
 * ```
 */
export const transaction = async <T>(callback: (client: SupabaseClient) => Promise<T>): Promise<T> => {
  const supabaseService = getSupabaseService();
  const client = supabaseService.getClient();

  try {
    const result = await callback(client);
    return result;
  } catch (error) {
    console.error('Transaction error:', error);
    throw error;
  }
};
```

### 4.2 Repository 模式示例

#### 用户数据仓库（`lib/database/repositories/user.repository.ts`）

```typescript
/**
 * 用户数据仓库类
 * 
 * 提供所有与 users 表相关的数据操作
 */
export class UserRepository {
  /**
   * 根据 ID 查找用户
   */
  static async findById(id: string): Promise<User | null> {
    const supabase = getDatabaseClient();
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', id)
      .maybeSingle();

    if (error) {
      if (error.code === 'PGRST116') return null; // Not found
      throw error;
    }

    return data ? this.mapRowToUser(data) : null;
  }

  /**
   * 根据 GitHub ID 查找用户
   */
  static async findByGithubId(githubId: string): Promise<User | null> {
    const supabase = getDatabaseClient();
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .eq('githubId', githubId)
      .maybeSingle();

    if (error) throw error;

    return data ? this.mapRowToUser(data) : null;
  }

  /**
   * 创建用户
   */
  static async create(userData: CreateUserData): Promise<User> {
    const supabase = getDatabaseClient();

    // 从当前登录用户获取ID
    const { user } = await AuthService.getUser();
    if (!user) {
      throw new Error('未登录或无法获取用户信息');
    }

    const { data, error } = await supabase
      .from('users')
      .insert({
        id: user.id,
        githubId: userData.githubId,
        username: userData.username,
        email: userData.email,
        avatarUrl: userData.avatarUrl,
        accessToken: userData.accessToken,
        walletAddress: userData.walletAddress,
      })
      .select()
      .single();

    if (error) throw error;

    return this.mapRowToUser(data);
  }

  /**
   * 更新用户信息
   */
  static async update(id: string, userData: UpdateUserData): Promise<User | null> {
    const supabase = getDatabaseClient();

    const updateData: any = {};
    if (userData.username !== undefined) updateData.username = userData.username;
    if (userData.email !== undefined) updateData.email = userData.email;
    if (userData.avatarUrl !== undefined) updateData.avatarUrl = userData.avatarUrl;
    if (userData.walletAddress !== undefined) updateData.walletAddress = userData.walletAddress;

    if (Object.keys(updateData).length === 0) {
      return this.findById(id);
    }

    const { data, error } = await supabase
      .from('users')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;

    return data ? this.mapRowToUser(data) : null;
  }

  /**
   * 将数据库行映射为 User 对象
   */
  private static mapRowToUser(row: any): User {
    return {
      id: row.id,
      githubId: row.githubId,
      username: row.username,
      email: row.email,
      avatarUrl: row.avatarUrl,
      accessToken: row.accessToken,
      walletAddress: row.walletAddress,
      createdAt: row.createdAt,
      updatedAt: row.updatedAt,
    };
  }
}
```

**Repository 模式的好处：**
1. **封装性**：隐藏数据库操作细节
2. **可测试性**：可以轻松 mock Repository
3. **可维护性**：数据库变更只需修改 Repository
4. **可复用性**：统一的数据访问接口

---

## 五、服务层

### 5.1 贡献服务（`lib/services/contribution.service.ts`）

#### 职责

服务层负责业务逻辑，协调 Repository 层和外部 API。

#### 核心方法

```typescript
export class ContributionService {
  /**
   * 获取所有贡献
   */
  static async findAll(query: QueryContributionParams = {}, limit = 50, offset = 0): Promise<Contribution[]> {
    return ContributionRepository.findAll(query, limit, offset);
  }

  /**
   * 根据 ID 获取单个贡献
   */
  static async findOne(id: string): Promise<Contribution | null> {
    return ContributionRepository.findById(id);
  }

  /**
   * 获取用户贡献统计
   */
  static async getUserContributionStats(userId: string): Promise<ContributionStats> {
    const stats = await ContributionRepository.getStats(userId);
    const contributions = await ContributionRepository.findByUserId(userId);

    // 计算额外的统计信息
    const monthlyStats = this.calculateMonthlyStats(contributions);
    const typeDistribution = this.calculateTypeDistribution(contributions);
    const statusDistribution = this.calculateStatusDistribution(contributions);

    return {
      ...stats,
      monthlyStats,
      typeDistribution,
      statusDistribution,
      totalContributions: contributions.length,
    };
  }

  /**
   * 计算月度统计
   */
  private static calculateMonthlyStats(contributions: Contribution[]): MonthlyStats[] {
    const monthlyData: { [key: string]: number } = {};

    contributions.forEach(contribution => {
      const date = new Date(contribution.createdAt);
      const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
      monthlyData[monthKey] = (monthlyData[monthKey] || 0) + 1;
    });

    return Object.entries(monthlyData)
      .map(([month, count]) => ({ month, count }))
      .sort((a, b) => a.month.localeCompare(b.month));
  }

  /**
   * 计算类型分布
   */
  private static calculateTypeDistribution(contributions: Contribution[]): TypeDistribution[] {
    const typeCount: { [key in ContributionType]?: number } = {};

    contributions.forEach(contribution => {
      typeCount[contribution.type] = (typeCount[contribution.type] || 0) + 1;
    });

    return Object.entries(typeCount).map(([type, count]) => ({ type, count }));
  }

  /**
   * 获取贡献趋势
   */
  static async getContributionTrends(days = 30): Promise<ContributionTrends> {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const allContributions = await ContributionRepository.findAll({});

    const filteredContributions = allContributions.filter(contribution => {
      const contributionDate = new Date(contribution.createdAt);
      return contributionDate >= startDate && contributionDate <= endDate;
    });

    const dailyStats: { [key: string]: number } = {};

    for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
      const dateKey = d.toISOString().split('T')[0];
      dailyStats[dateKey] = 0;
    }

    filteredContributions.forEach(contribution => {
      const dateKey = new Date(contribution.createdAt).toISOString().split('T')[0];
      if (dailyStats[dateKey] !== undefined) {
        dailyStats[dateKey]++;
      }
    });

    const dailyContributions = Object.entries(dailyStats).map(([date, count]) => ({ date, count }));
    const totalContributions = filteredContributions.length;
    const averageDaily = totalContributions / days;

    return {
      dailyContributions,
      totalContributions,
      averageDaily,
    };
  }
}
```

### 5.2 GitHub 服务（`lib/services/github.service.ts`）

#### 功能概述

处理 GitHub Webhook、调用 GitHub API、同步数据到数据库。

#### 核心方法

```typescript
export class GitHubService {
  /**
   * 验证 webhook 签名
   * 
   * 使用 HMAC-SHA256 验证签名，防止伪造请求
   */
  static verifyWebhookSignature(payload: string, signature: string): boolean {
    try {
      const config = getConfig();
      const secret = config.github.webhookSecret;

      if (!secret) {
        console.error('Webhook secret not configured');
        return false;
      }

      // 使用 HMAC-SHA256 计算签名
      const hmac = crypto.createHmac('sha256', secret);
      hmac.update(payload);
      const digest = `sha256=${hmac.digest('hex')}`;

      // 确保输入的签名格式正确
      if (!signature.startsWith('sha256=')) {
        console.error('Invalid signature format');
        return false;
      }

      // 使用时间安全比较（防止时序攻击）
      return crypto.timingSafeEqual(
        Buffer.from(signature.trim()),
        Buffer.from(digest.trim()),
      );
    } catch (error) {
      console.error('Signature verification failed:', error);
      return false;
    }
  }

  /**
   * 处理 webhook 事件
   */
  static async handleWebhook(event: string, payload: GitHubWebhookEvent): Promise<void> {
    try {
      switch (event) {
        case 'push':
          await this.handlePushEvent(payload as unknown as GitHubPushPayload);
          break;
        case 'pull_request':
          await this.handlePullRequestEvent(payload as unknown as GitHubPullRequestPayload);
          break;
        default:
          console.log(`⚠️ Unhandled event type: ${event}`);
      }
    } catch (error) {
      console.error('Failed to handle webhook:', error);
      throw error;
    }
  }

  /**
   * 处理 push 事件
   */
  private static async handlePushEvent(payload: GitHubPushPayload): Promise<void> {
    const commits = payload.commits || [];
    const repository = payload.repository;

    for (const commit of commits) {
      const repo = await this.findOrCreateRepository(repository);
      const user = await this.findUserByGithubUsername(commit.author.username);

      if (!user) continue;

      // 检查是否已存在
      const existingContribution = await ContributionRepository.findByGithubId(commit.id);
      if (existingContribution) continue;

      // 创建贡献记录
      const contributionData: CreateContributionData = {
        githubId: commit.id,
        type: ContributionType.COMMIT,
        userId: user.id,
        repositoryId: repo.id,
        contributor: commit.author.username,
        title: commit.message.split('\n')[0],
        description: commit.message,
        url: commit.url,
        metadata: {
          sha: commit.id,
          timestamp: commit.timestamp,
          additions: commit.added?.length || 0,
          deletions: commit.removed?.length || 0,
          modifications: commit.modified?.length || 0,
        },
      };

      const contribution = await ContributionRepository.create(contributionData);
      console.log(`Created contribution ${contribution.id} for commit ${commit.id}`);
    }
  }

  /**
   * 获取用户的仓库列表
   */
  static async getUserRepositories(username: string, accessToken?: string): Promise<GitHubApiRepository[]> {
    const config = getConfig();
    const token = accessToken || config.github.clientSecret || '';

    const url = `https://api.github.com/users/${username}/repos`;

    const response = await fetch(url, {
      headers: {
        'Authorization': `token ${token}`,
        'Accept': 'application/vnd.github.v3+json',
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch user repositories: ${response.statusText}`);
    }

    return response.json();
  }
}
```

---

## 六、Hooks 层

### 6.1 认证 Hook（`hooks/use-auth.ts`）

#### 功能

提供认证状态和方法的 React Hook。

#### 实现

```typescript
/**
 * GitHub 认证状态 Hook
 * 
 * 返回值：
 * - user: GitHub 用户对象
 * - isAuthenticated: 是否已登录
 * - isLoading: 是否正在加载
 * - error: 错误信息
 * - login(): 触发 GitHub OAuth 登录
 * - logout(): 退出登录
 */
export function useAuth() {
  // 使用 React Query 获取用户信息
  const { data: authData, isLoading, error } = useQuery({
    queryKey: ['user'],
    queryFn: AuthService.getUser,
    retry: false,
  });

  // 提取 user
  const user = authData?.user || null;
  const isAuthenticated = !!user;

  // 登录方法
  const login = () => {
    AuthService.signInWithGitHub();
  };

  // 登出方法
  const logout = () => {
    AuthService.signOut().then(() => {
      window.location.href = '/';
    });
  };

  return {
    user,
    isAuthenticated,
    isLoading,
    error: error || authData?.error,
    login,
    logout,
  };
}
```

#### 使用示例

```typescript
function Header() {
  const { user, isAuthenticated, login, logout, isLoading } = useAuth();

  if (isLoading) {
    return <div>加载中...</div>;
  }

  if (!isAuthenticated) {
    return <button onClick={login}>GitHub 登录</button>;
  }

  return (
    <div>
      <img src={user.avatar_url} alt={user.login} />
      <span>{user.login}</span>
      <button onClick={logout}>登出</button>
    </div>
  );
}
```

### 6.2 贡献 Hook（`hooks/use-contributions.ts`）

#### 功能

提供贡献数据的 React Hook，支持筛选和统计。

#### 实现

```typescript
/**
 * 获取贡献列表（支持筛选）
 */
export function useContributions(params?: {
  type?: string;
  status?: string;
  userId?: string;
  repositoryId?: string;
}) {
  return useQuery({
    queryKey: ['contributions', params],
    queryFn: () => contributionsApi.getAll(params),
  });
}

/**
 * 获取单个贡献详情
 */
export function useContribution(id: string) {
  return useQuery({
    queryKey: ['contribution', id],
    queryFn: () => contributionsApi.getOne(id),
    enabled: !!id,  // 仅当 id 存在时才执行查询
  });
}

/**
 * 获取当前用户的贡献列表
 */
export function useMyContributions() {
  return useQuery({
    queryKey: ['my-contributions'],
    queryFn: () => contributionsApi.getMy(),
  });
}

/**
 * 获取贡献统计数据
 */
export function useContributionStats(userId?: string) {
  return useQuery({
    queryKey: ['contribution-stats', userId],
    queryFn: () => contributionsApi.getStats(userId),
  });
}
```

#### 使用示例

```typescript
function ContributionList() {
  const { data: contributions, isLoading, error, refetch } = useContributions({
    type: 'commit',
    status: 'minted',
  });

  if (isLoading) return <div>加载中...</div>;
  if (error) return <div>错误: {error.message}</div>;

  return (
    <div>
      <button onClick={() => refetch()}>刷新</button>
      {contributions.map(contribution => (
        <ContributionCard key={contribution.id} contribution={contribution} />
      ))}
    </div>
  );
}
```

### 6.3 Agent Registry Hook（`hooks/use-agent-registry.ts`）

#### 功能

管理 ERC-8004 Agent 注册状态。

#### 实现

```typescript
/**
 * ERC-8004 代理注册状态 Hook
 */
export function useAgentRegistry() {
  // 1. 获取钱包地址
  const { address } = useAccount();
  
  // 2. 获取 GitHub 用户信息
  const { user } = useAuth();
  
  // 3. Hook 状态
  const [isRegistered, setIsRegistered] = useState<boolean>(false);
  const [loading, setLoading] = useState(true);
  const [agentProfile, setAgentProfile] = useState<AgentProfile | null>(null);

  // 4. 合约地址
  const identityRegistryAddress = process.env.NEXT_PUBLIC_IDENTITY_REGISTRY_ADDRESS as `0x${string}`;

  // 5. 读取链上注册状态
  const { data: isRegisteredData, refetch: refetchIsRegistered } = useReadContract({
    address: identityRegistryAddress,
    abi: AgentIdentityRegistryABI,
    functionName: 'isRegistered',
    args: address ? [address] : undefined,
    query: {
      enabled: !!address && !!identityRegistryAddress,
    },
  });

  // 6. 读取代理资料
  const { data: profileData, refetch: refetchProfile } = useReadContract({
    address: identityRegistryAddress,
    abi: AgentIdentityRegistryABI,
    functionName: 'getAgentByAddress',
    args: address ? [address] : undefined,
    query: {
      enabled: !!address && !!identityRegistryAddress && isRegisteredData === true,
    },
  });

  // 7. 更新状态
  useEffect(() => {
    if (!address) {
      setIsRegistered(false);
      setAgentProfile(null);
      setLoading(false);
      return;
    }

    setIsRegistered(isRegisteredData === true);

    if (isRegisteredData && profileData) {
      setAgentProfile({
        wallet: (profileData as any).wallet,
        githubUsername: (profileData as any).githubUsername,
        agentCardURI: (profileData as any).agentCardURI,
        registeredAt: (profileData as any).registeredAt,
        active: (profileData as any).active,
      });
    } else {
      setAgentProfile(null);
    }

    setLoading(false);
  }, [address, isRegisteredData, profileData]);

  // 8. 注册代理
  const { writeContract, data: hash, isPending } = useWriteContract();
  const { isSuccess } = useWaitForTransactionReceipt({ hash });

  const registerAgent = async (githubUsername?: string) => {
    if (!address) {
      throw new Error('钱包未连接，请先连接钱包');
    }

    if (!identityRegistryAddress) {
      throw new Error('IDENTITY_REGISTRY_ADDRESS 环境变量未配置');
    }

    // 准备 GitHub 用户名
    const username = githubUsername || 
      (user as any)?.login || 
      'unknown';

    // 生成 Agent Card
    const agentCard = {
      name: username,
      version: '1.0.0',
      description: `LightCommit agent for ${username}`,
      capabilities: ['code-review', 'commit-scoring'],
      contact: {
        github: username,
      },
      createdAt: new Date().toISOString(),
    };

    // 转换为 Base64 编码的 Data URI
    const agentCardJSON = JSON.stringify(agentCard, null, 2);
    const agentCardURI = `data:application/json;base64,${btoa(agentCardJSON)}`;

    // 调用合约
    await writeContract({
      address: identityRegistryAddress,
      abi: AgentIdentityRegistryABI,
      functionName: 'registerAgent',
      args: [username, agentCardURI],
    });
  };

  // 9. 重新检查注册状态
  const checkRegistration = async () => {
    await refetchIsRegistered();
    if (isRegisteredData) {
      await refetchProfile();
    }
  };

  // 10. 监听注册成功
  useEffect(() => {
    if (isSuccess) {
      checkRegistration();
    }
  }, [isSuccess]);

  return {
    isRegistered,
    loading,
    agentProfile,
    registerAgent,
    checkRegistration,
    isPending,
  };
}
```

#### 使用示例

```typescript
function RegisterAgentButton() {
  const { isRegistered, loading, registerAgent, isPending } = useAgentRegistry();

  if (loading) return <div>加载中...</div>;
  if (isRegistered) return <div>已注册为 Agent</div>;

  return (
    <button onClick={() => registerAgent()} disabled={isPending}>
      {isPending ? '注册中...' : '注册为 Agent'}
    </button>
  );
}
```

---

## 七、配置管理

### 7.1 配置结构（`lib/config/index.ts`）

#### 配置类型定义

```typescript
/**
 * 应用总配置
 */
export interface AppConfig {
  port: number;                    // 应用端口（默认 3000）
  nodeEnv: string;                 // 运行环境（development/production）
  database: DatabaseConfig;        // 数据库配置
  github: GitHubConfig;            // GitHub 配置
  jwt: JwtConfig;                  // JWT 配置
  blockchain: BlockchainConfig;    // 区块链配置
  rpc: RpcConfig;                  // RPC 配置（前端）
  ipfs: IpfsConfig;                // IPFS 配置
  supabase: SupabaseConfig;        // Supabase 配置
}
```

#### 配置获取

```typescript
/**
 * 获取应用配置
 */
export const getConfig = (): AppConfig => ({
  // 应用基础配置
  port: parseInt(process.env.PORT || '3000', 10),
  nodeEnv: process.env.NODE_ENV || 'development',

  // 数据库配置
  database: {
    url: process.env.DATABASE_URL,
    host: process.env.DATABASE_HOST || 'localhost',
    port: parseInt(process.env.DATABASE_PORT || '5432', 10),
    username: process.env.DATABASE_USER,
    password: process.env.DATABASE_PASSWORD,
    database: process.env.DATABASE_NAME,
  },

  // GitHub OAuth 配置
  github: {
    clientId: process.env.GITHUB_CLIENT_ID,
    clientSecret: process.env.GITHUB_CLIENT_SECRET,
    callbackUrl: process.env.GITHUB_CALLBACK_URL,
    webhookSecret: process.env.GITHUB_WEBHOOK_SECRET,
  },

  // JWT 配置
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRATION || '7d',
  },

  // 区块链配置
  blockchain: {
    rpcUrl: process.env.SEPOLIA_RPC_URL,
    privateKey: process.env.SEPOLIA_PRIVATE_KEY,
    contractAddress: process.env.CONTRACT_ADDRESS,
    chainId: parseInt(process.env.NEXT_PUBLIC_CHAIN_ID || '11155111', 10),
    identityRegistry: process.env.NEXT_PUBLIC_IDENTITY_REGISTRY_ADDRESS || '',
    reputationRegistry: process.env.NEXT_PUBLIC_REPUTATION_REGISTRY_ADDRESS || '',
    validationRegistry: process.env.NEXT_PUBLIC_VALIDATION_REGISTRY_ADDRESS || '',
    commitNFT: process.env.NEXT_PUBLIC_COMMIT_NFT_ADDRESS || '',
  },

  // RPC 配置（前端）
  rpc: {
    url: process.env.NEXT_PUBLIC_RPC_URL || 'http://localhost:8545',
    chainId: parseInt(process.env.NEXT_PUBLIC_CHAIN_ID || '31337', 10),
  },

  // IPFS 配置
  ipfs: {
    apiUrl: process.env.IPFS_API_URL,
    apiKey: process.env.IPFS_API_KEY,
    secretKey: process.env.IPFS_SECRET_KEY,
  },

  // Supabase 配置
  supabase: {
    url: process.env.SUPABASE_URL,
    anonKey: process.env.SUPABASE_ANON_KEY,
  },
});
```

#### 单例模式

```typescript
/**
 * 配置实例缓存（单例模式）
 */
let configInstance: AppConfig | null = null;

/**
 * 获取配置（单例模式）
 * 
 * 避免重复读取环境变量
 */
export const config = (): AppConfig => {
  if (!configInstance) {
    configInstance = getConfig();
  }
  return configInstance;
};
```

#### 便捷访问函数

```typescript
// 获取区块链配置
export const getBlockchainConfig = () => config().blockchain;

// 获取 GitHub 配置
export const getGitHubConfig = () => config().github;

// 获取 JWT 配置
export const getJwtConfig = () => config().jwt;

// 获取 Supabase 配置
export const getSupabaseConfig = () => config().supabase;
```

#### 使用示例

```typescript
// 在服务层使用配置
import { getBlockchainConfig } from '@/lib/config';

const blockchainConfig = getBlockchainConfig();
console.log('Chain ID:', blockchainConfig.chainId);
console.log('CommitNFT 地址:', blockchainConfig.commitNFT);
```

---

## 八、总结

### 8.1 架构特点

1. **分层清晰**
   - Hooks 层 → 服务层 → Repository 层 → 数据库
   - 职责明确，便于维护和测试

2. **类型安全**
   - 全面使用 TypeScript
   - Viem 提供完全的类型安全
   - 减少运行时错误

3. **模块化设计**
   - 每个模块职责单一
   - 易于复用和扩展
   - 支持独立测试

4. **现代化技术栈**
   - Viem + Wagmi（替代 Ethers.js）
   - TanStack Query（自动缓存）
   - Next.js 15（App Router + Server Components）

5. **安全可靠**
   - JWT 认证（httpOnly Cookie）
   - 签名验证（GitHub Webhook）
   - 类型安全（TypeScript + Viem）

### 8.2 最佳实践

1. **认证系统**
   - 使用 JWT + httpOnly Cookie
   - 服务端验证，客户端无感知
   - 30 天自动过期

2. **Web3 交互**
   - 使用 Viem 而不是 Ethers.js
   - Wagmi Hooks 自动缓存
   - 完全类型安全

3. **数据管理**
   - Repository 模式隔离数据库
   - Service 层处理业务逻辑
   - Hooks 层封装 React 逻辑

4. **配置管理**
   - 单例模式避免重复读取
   - 环境变量分类（前端/后端）
   - 类型安全的配置接口

5. **错误处理**
   - API 拦截器统一处理 401
   - Webhook 签名验证防伪造
   - 链上交易状态追踪

---

## 相关文档

- [前端技术架构](./前端技术架构.md)
- [系统架构与实现](./系统架构与实现.md)
- [智能合约文档](./contracts.md)
- [ERC8004 实现](./ERC8004_IMPLEMENTATION.md)

---

**文档维护者：** LightCommit 团队  
**最后更新：** 2025-11-14

