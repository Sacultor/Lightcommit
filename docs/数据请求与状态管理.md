# LightCommit 数据请求与状态管理

## 概述

LightCommit 采用多层架构的数据管理方案，结合了 React Query、Context API、自定义 Hooks 等多种技术，实现了高效、可维护的状态管理和数据请求。

## 架构总览

```
┌─────────────────────────────────────────────────────────────┐
│                        React 组件层                          │
│  (页面、UI 组件 - 使用 Hooks 和 Context 消费数据)            │
└────────────────────┬────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────┐
│                   自定义 Hooks 层                            │
│  (useAuth, useContributions, useAgentRegistry 等)           │
│   - 封装业务逻辑                                             │
│   - 集成 React Query                                        │
│   - 管理局部状态                                             │
└────────────────────┬────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────┐
│              状态管理层 (React Query + Context)              │
│  - React Query: 服务端数据缓存和同步                         │
│  - Context API: 全局状态 (Web3, Auth)                       │
└────────────────────┬────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────┐
│                    API 客户端层                              │
│  - Axios 客户端 (带拦截器)                                   │
│  - API 封装函数 (authApi, contributionsApi)                 │
└────────────────────┬────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────┐
│                  Next.js API 路由层                          │
│  - 请求验证和授权                                            │
│  - 参数解析和校验                                            │
│  - 错误处理                                                  │
└────────────────────┬────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────┐
│                      服务层 (Services)                       │
│  - 业务逻辑封装                                              │
│  - 数据转换和聚合                                            │
│  - 外部 API 调用                                            │
└────────────────────┬────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────┐
│                  数据访问层 (Repositories)                   │
│  - 数据库查询                                                │
│  - ORM 操作                                                 │
│  - 数据映射                                                  │
└────────────────────┬────────────────────────────────────────┘
                     │
┌────────────────────┴────────────────────────────────────────┐
│                  数据库层 (Supabase)                         │
│  - PostgreSQL 数据库                                        │
│  - 认证服务                                                  │
│  - 实时订阅                                                  │
└─────────────────────────────────────────────────────────────┘
```

## 1. 数据请求方式

### 1.1 Axios HTTP 客户端

#### 配置：`src/lib/api.ts`

```typescript
// Axios 实例配置
const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api';

export const apiClient = axios.create({
  baseURL: API_BASE_URL,              // API 基础 URL
  headers: {
    'Content-Type': 'application/json', // 默认 JSON 格式
  },
});
```

**功能说明：**
- 创建统一的 Axios 实例
- 设置基础 URL，支持环境变量配置
- 配置默认请求头

#### 请求拦截器

```typescript
// 自动添加认证 Token
apiClient.interceptors.request.use((config) => {
  // 从 localStorage 获取 token
  const token = typeof window !== 'undefined' ? localStorage.getItem('token') : null;
  
  // 如果 token 存在，添加到请求头
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  
  return config;
});
```

**工作流程：**
1. 每次发起请求前自动执行
2. 从浏览器 localStorage 读取 token
3. 将 token 添加到 `Authorization` 请求头
4. 返回修改后的配置

#### 响应拦截器

```typescript
// 统一错误处理
apiClient.interceptors.response.use(
  (response) => response,  // 成功响应直接返回
  (error) => {
    // 处理 401 未授权错误
    if (error.response?.status === 401) {
      if (typeof window !== 'undefined') {
        localStorage.removeItem('token');  // 清除无效 token
        window.location.href = '/';        // 重定向到首页
      }
    }
    return Promise.reject(error);
  },
);
```

**错误处理逻辑：**
- **401 未授权**：清除本地 token，重定向到首页
- **其他错误**：向上抛出，由调用方处理

### 1.2 API 封装函数

#### 认证 API

```typescript
// src/lib/api.ts
export const authApi = {
  // GitHub 登录（重定向）
  githubLogin: () => {
    window.location.href = `${API_BASE_URL}/auth/github`;
  },

  // 获取当前用户信息
  getProfile: async () => {
    const response = await apiClient.get('/auth/user');
    return response.data;
  },
};
```

**使用场景：**
- `githubLogin()`：用户点击"GitHub 登录"按钮时调用
- `getProfile()`：页面加载时获取当前登录用户

#### 贡献 API

```typescript
export const contributionsApi = {
  // 获取所有贡献（带过滤）
  getAll: async (params?: {
    type?: string;        // 贡献类型：commit, pull_request, issue
    status?: string;      // 状态：pending, scored, minted
    userId?: string;      // 用户 ID
    repositoryId?: string; // 仓库 ID
  }) => {
    const response = await apiClient.get('/contributions', { params });
    return response.data;
  },

  // 获取单个贡献详情
  getOne: async (id: string) => {
    const response = await apiClient.get(`/contributions/${id}`);
    return response.data;
  },

  // 获取当前用户的贡献
  getMy: async () => {
    const response = await apiClient.get('/contributions/my');
    return response.data;
  },

  // 获取统计信息
  getStats: async (userId?: string) => {
    const response = await apiClient.get('/contributions/stats', {
      params: { userId },
    });
    return response.data;
  },
};
```

**参数说明：**
- **params**：查询参数对象，会自动转换为 URL 查询字符串
- **返回值**：统一返回 `response.data`，去除 Axios 包装

### 1.3 Next.js API 路由

#### 请求处理流程

以 `GET /api/contributions/my` 为例：

```typescript
// src/app/api/contributions/my/route.ts
export async function GET(request: NextRequest) {
  try {
    // 1. 验证用户身份
    const authorization = request.headers.get('authorization');

    if (!authorization || !authorization.startsWith('Bearer ')) {
      return NextResponse.json(
        { error: 'Missing or invalid authorization header' },
        { status: 401 },
      );
    }

    // 2. 获取当前用户
    const { user, error } = await AuthService.getServerUser();

    if (error || !user) {
      return NextResponse.json(
        { error: 'Invalid or expired token' },
        { status: 401 },
      );
    }

    // 3. 解析查询参数
    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get('limit') || '50', 10);
    const offset = parseInt(searchParams.get('offset') || '0', 10);

    // 4. 调用服务层获取数据
    const contributions = await ContributionService.findByUser(user.id, limit, offset);

    // 5. 返回结构化响应
    return NextResponse.json({
      data: contributions,
      pagination: {
        limit,
        offset,
        total: contributions.length,
      },
      user: {
        id: user.id,
        username: user.user_metadata?.user_name || 'unknown',
      },
    });

  } catch (error) {
    // 6. 错误处理
    console.error('Get my contributions error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch user contributions' },
      { status: 500 },
    );
  }
}
```

**关键步骤：**
1. **身份验证**：检查 Authorization 头
2. **用户识别**：从 Supabase 获取当前用户
3. **参数解析**：从 URL 提取查询参数
4. **数据获取**：调用服务层方法
5. **响应格式化**：返回统一的 JSON 格式
6. **错误处理**：捕获异常，返回错误信息

#### 获取单个贡献

```typescript
// src/app/api/contributions/[id]/route.ts
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> },
) {
  try {
    // 验证身份
    const authorization = request.headers.get('authorization');
    if (!authorization || !authorization.startsWith('Bearer ')) {
      return NextResponse.json(
        { error: 'Missing or invalid authorization header' },
        { status: 401 },
      );
    }

    // 获取用户
    const { user, error } = await AuthService.getServerUser();
    if (error || !user) {
      return NextResponse.json(
        { error: 'Invalid or expired token' },
        { status: 401 },
      );
    }

    // 获取路径参数
    const { id } = await params;
    
    if (!id) {
      return NextResponse.json(
        { error: 'Missing contribution ID' },
        { status: 400 },
      );
    }

    // 获取贡献详情
    const contribution = await ContributionService.findOne(id);

    if (!contribution) {
      return NextResponse.json(
        { error: 'Contribution not found' },
        { status: 404 },
      );
    }

    return NextResponse.json(contribution);

  } catch (error) {
    console.error('Get contribution error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch contribution' },
      { status: 500 },
    );
  }
}
```

**动态路由参数：**
- 文件路径：`[id]/route.ts` 表示动态参数
- 参数获取：`await params` 获取异步参数对象
- 路径示例：`/api/contributions/123` → `id = "123"`

### 1.4 Supabase 客户端

#### 客户端配置

```typescript
// src/lib/supabase/client.ts
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '';

// 配置检查
const isSupabaseConfigured =
  supabaseUrl &&
  supabaseAnonKey &&
  !supabaseUrl.includes('placeholder') &&
  !supabaseAnonKey.includes('placeholder') &&
  supabaseUrl.startsWith('https://');

if (!isSupabaseConfigured) {
  console.warn('⚠️ Supabase 未正确配置，GitHub OAuth 功能将不可用');
}

// 创建 Supabase 客户端实例
export const supabase = createClient(
  supabaseUrl || 'https://placeholder.supabase.co',
  supabaseAnonKey || 'placeholder-key',
  {
    auth: {
      autoRefreshToken: true,   // 自动刷新 token
      persistSession: true,     // 持久化会话
      detectSessionInUrl: true, // 从 URL 检测会话（OAuth 回调）
    },
  },
);
```

**配置选项说明：**
- **autoRefreshToken**：token 过期前自动刷新
- **persistSession**：会话保存到 localStorage
- **detectSessionInUrl**：支持 OAuth 回调流程

#### 直接查询示例

```typescript
// 使用 Supabase 客户端查询
const { data, error } = await supabase
  .from('contributions')          // 表名
  .select('*')                    // 选择字段
  .eq('status', 'pending')        // WHERE status = 'pending'
  .order('created_at', { ascending: false })  // ORDER BY created_at DESC
  .limit(10);                     // LIMIT 10

if (error) {
  console.error('查询失败:', error);
  throw error;
}

console.log('查询结果:', data);
```

**常用查询方法：**
- `.select(fields)`：选择字段
- `.eq(column, value)`：等于条件
- `.neq(column, value)`：不等于
- `.gt(column, value)`：大于
- `.gte(column, value)`：大于等于
- `.lt(column, value)`：小于
- `.lte(column, value)`：小于等于
- `.like(column, pattern)`：模糊匹配
- `.in(column, values)`：IN 查询
- `.is(column, null)`：IS NULL
- `.order(column, options)`：排序
- `.limit(count)`：限制数量
- `.range(from, to)`：范围查询

## 2. 状态管理方案

### 2.1 React Query

#### 配置

```typescript
// src/lib/contexts/RainbowKitProvider.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,   // 5 分钟内数据视为新鲜
      cacheTime: 1000 * 60 * 10,  // 缓存保留 10 分钟
      refetchOnWindowFocus: false, // 窗口聚焦时不自动重新获取
      retry: 1,                    // 失败重试 1 次
    },
  },
});

export function RainbowKitProvider({ children }) {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <RKProvider modalSize="compact">
          {children}
        </RKProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

**配置选项说明：**
- **staleTime**：数据新鲜时长，期间不重新请求
- **cacheTime**：缓存保留时长，超时后清除
- **refetchOnWindowFocus**：窗口聚焦时是否重新获取
- **retry**：请求失败后的重试次数

#### 自定义 Hook：useAuth

```typescript
// src/hooks/use-auth.ts
import { useQuery } from '@tanstack/react-query';
import { AuthService } from '@/lib/services/auth.service';

export function useAuth() {
  // 使用 React Query 获取用户信息
  const { data: authData, isLoading, error } = useQuery({
    queryKey: ['user'],              // 缓存 key
    queryFn: AuthService.getUser,    // 查询函数
    retry: false,                    // 失败不重试（未登录不是错误）
  });

  // 从返回的数据中提取 user
  const user = authData?.user || null;
  const isAuthenticated = !!user;

  // 登录方法
  const login = () => {
    AuthService.signInWithGitHub();
  };

  // 登出方法
  const logout = () => {
    AuthService.signOut().then(() => {
      window.location.href = '/';
    });
  };

  return {
    user,                // 用户对象
    isAuthenticated,     // 是否已登录
    isLoading,          // 加载状态
    error: error || authData?.error,  // 错误信息
    login,              // 登录方法
    logout,             // 登出方法
  };
}
```

**使用示例：**
```typescript
function MyComponent() {
  const { user, isAuthenticated, isLoading, login, logout } = useAuth();

  if (isLoading) {
    return <div>加载中...</div>;
  }

  if (!isAuthenticated) {
    return <button onClick={login}>登录</button>;
  }

  return (
    <div>
      <p>欢迎，{user.user_metadata.user_name}</p>
      <button onClick={logout}>退出</button>
    </div>
  );
}
```

#### 自定义 Hook：useContributions

```typescript
// src/hooks/use-contributions.ts
import { useQuery } from '@tanstack/react-query';
import { contributionsApi } from '@/lib/api';

// 获取所有贡献（带过滤）
export function useContributions(params?: {
  type?: string;
  status?: string;
  userId?: string;
  repositoryId?: string;
}) {
  return useQuery({
    queryKey: ['contributions', params],  // 缓存 key（包含参数）
    queryFn: () => contributionsApi.getAll(params),  // 查询函数
  });
}

// 获取单个贡献
export function useContribution(id: string) {
  return useQuery({
    queryKey: ['contribution', id],       // 缓存 key（包含 ID）
    queryFn: () => contributionsApi.getOne(id),  // 查询函数
    enabled: !!id,                        // 仅当 ID 存在时才查询
  });
}

// 获取当前用户的贡献
export function useMyContributions() {
  return useQuery({
    queryKey: ['my-contributions'],
    queryFn: () => contributionsApi.getMy(),
  });
}

// 获取贡献统计
export function useContributionStats(userId?: string) {
  return useQuery({
    queryKey: ['contribution-stats', userId],
    queryFn: () => contributionsApi.getStats(userId),
  });
}
```

**使用示例：**
```typescript
function ContributionsList() {
  const { data, isLoading, error, refetch } = useContributions({
    status: 'pending',
    type: 'commit',
  });

  if (isLoading) return <Spinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <div>
      <button onClick={() => refetch()}>刷新</button>
      {data.map(contribution => (
        <ContributionCard key={contribution.id} data={contribution} />
      ))}
    </div>
  );
}
```

**React Query 返回的状态：**
- **data**：查询结果数据
- **isLoading**：首次加载中
- **isFetching**：获取数据中（包括后台刷新）
- **error**：错误对象
- **refetch**：手动重新获取数据
- **isSuccess**：查询成功
- **isError**：查询失败

### 2.2 Context API

#### Web3 Context

```typescript
// src/lib/contexts/Web3Context.tsx
import { createContext, useContext, ReactNode } from 'react';
import { useRainbowKitAdapter } from '@/hooks/use-rainbowkit-adapter';
import { ethers } from 'ethers';

// 定义 Context 类型
interface Web3ContextType {
  provider: ethers.BrowserProvider | null;  // 以太坊提供者
  signer: ethers.JsonRpcSigner | null;      // 签名器
  account: string | null;                    // 当前账户地址
  chainId: number | null;                    // 当前链 ID
  isConnected: boolean;                      // 是否已连接
  isCorrectNetwork: boolean;                 // 是否在正确的网络
  connect: () => Promise<void>;              // 连接钱包
  disconnect: () => void;                    // 断开连接
  switchNetwork: (targetChainId: number) => Promise<void>;  // 切换网络
}

// 创建 Context
const Web3Context = createContext<Web3ContextType | undefined>(undefined);

// Provider 组件
export function Web3Provider({ children }: { children: ReactNode }) {
  // 使用适配器获取 Web3 状态
  const rainbowKit = useRainbowKitAdapter();

  const value = {
    provider: rainbowKit.provider,
    signer: rainbowKit.signer,
    account: rainbowKit.account,
    chainId: rainbowKit.chainId,
    isConnected: rainbowKit.isConnected,
    isCorrectNetwork: rainbowKit.isCorrectNetwork,
    connect: rainbowKit.connect,
    disconnect: rainbowKit.disconnect,
    switchNetwork: rainbowKit.switchNetwork,
  };

  return <Web3Context.Provider value={value}>{children}</Web3Context.Provider>;
}

// 自定义 Hook
export function useWeb3() {
  const context = useContext(Web3Context);
  if (context === undefined) {
    throw new Error('useWeb3 must be used within a Web3Provider');
  }
  return context;
}
```

**使用示例：**
```typescript
function ConnectWalletButton() {
  const { isConnected, account, connect, disconnect } = useWeb3();

  if (isConnected) {
    return (
      <div>
        <p>已连接: {account?.slice(0, 6)}...{account?.slice(-4)}</p>
        <button onClick={disconnect}>断开连接</button>
      </div>
    );
  }

  return <button onClick={connect}>连接钱包</button>;
}
```

#### RainbowKit 适配器

```typescript
// src/hooks/use-rainbowkit-adapter.ts
import { useAccount, useConnect, useDisconnect, useChainId, useSwitchChain } from 'wagmi';
import { useWalletClient, usePublicClient } from 'wagmi';
import { useMemo } from 'react';
import { walletClientToSigner, publicClientToProvider } from '@/lib/utils/rainbowkit-adapter';

export function useRainbowKitAdapter() {
  // Wagmi Hooks
  const { address, isConnected } = useAccount();
  const { connect, connectors } = useConnect();
  const { disconnect } = useDisconnect();
  const chainId = useChainId();
  const { switchChain } = useSwitchChain();

  const { data: walletClient } = useWalletClient();
  const publicClient = usePublicClient();

  // 转换为 Ethers.js 格式
  const provider = useMemo(() => {
    if (!publicClient) return null;
    return publicClientToProvider(publicClient);
  }, [publicClient]);

  const signer = useMemo(() => {
    if (!walletClient) return null;
    return walletClientToSigner(walletClient);
  }, [walletClient]);

  // 连接钱包方法
  const connectWallet = async () => {
    const metamask = connectors.find(c => c.name === 'MetaMask');
    if (metamask) {
      connect({ connector: metamask });
    }
  };

  // 切换网络方法
  const switchNetwork = async (targetChainId: number) => {
    switchChain({ chainId: targetChainId });
  };

  // 更可靠的连接状态判断
  const walletConnected = isConnected || !!address;

  return {
    provider,
    signer,
    account: address || null,
    chainId,
    isConnected: walletConnected,
    isCorrectNetwork: chainId === parseInt(process.env.NEXT_PUBLIC_CHAIN_ID || '31337'),
    connect: connectWallet,
    disconnect,
    switchNetwork,
  };
}
```

**适配器作用：**
- 将 Wagmi 的 viem 格式转换为 Ethers.js 格式
- 统一钱包连接接口
- 处理状态同步问题

### 2.3 自定义 Hook：useAgentRegistry

```typescript
// src/hooks/use-agent-registry.ts
import { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useWeb3 } from '@/lib/contexts/Web3Context';
import { useAuth } from './use-auth';
import { AgentIdentityRegistryABI } from '@/lib/contracts';

export function useAgentRegistry() {
  const { account, signer } = useWeb3();
  const { user } = useAuth();
  const [isRegistered, setIsRegistered] = useState<boolean>(false);
  const [loading, setLoading] = useState(true);
  const [agentProfile, setAgentProfile] = useState<any>(null);

  const identityRegistryAddress = process.env.NEXT_PUBLIC_IDENTITY_REGISTRY_ADDRESS;

  // 检查注册状态
  useEffect(() => {
    checkRegistration();
  }, [account]);

  const checkRegistration = async () => {
    if (!account || !identityRegistryAddress || !window.ethereum) {
      setLoading(false);
      setIsRegistered(false);
      return;
    }

    try {
      const provider = new ethers.BrowserProvider(window.ethereum as any);
      const contract = new ethers.Contract(
        identityRegistryAddress,
        AgentIdentityRegistryABI,
        provider,
      );

      // 调用合约方法检查注册状态
      const registered = await contract.isRegistered(account);
      setIsRegistered(registered);

      // 如果已注册，获取档案
      if (registered) {
        const profile = await contract.getAgentByAddress(account);
        setAgentProfile({
          wallet: profile.wallet,
          githubUsername: profile.githubUsername,
          agentCardURI: profile.agentCardURI,
          registeredAt: profile.registeredAt,
          active: profile.active,
        });
      }
    } catch (error) {
      console.error('检查代理注册失败:', error);
      setIsRegistered(false);
    } finally {
      setLoading(false);
    }
  };

  // 注册代理
  const registerAgent = async (githubUsername?: string) => {
    if (!account) {
      throw new Error('钱包未连接，请先连接钱包');
    }

    if (!identityRegistryAddress) {
      throw new Error('IDENTITY_REGISTRY_ADDRESS 环境变量未配置');
    }

    // 获取签名器
    let agentSigner = signer;
    if (!agentSigner) {
      if (!window.ethereum) {
        throw new Error('MetaMask 未安装或未检测到');
      }
      const provider = new ethers.BrowserProvider(window.ethereum as any);
      agentSigner = await provider.getSigner();
    }

    // 准备 Agent Card
    const username = githubUsername || 
      (user as any)?.user_metadata?.user_name || 
      'unknown';

    const agentCard = {
      name: username,
      version: '1.0.0',
      description: `LightCommit agent for ${username}`,
      capabilities: ['code-review', 'commit-scoring'],
      contact: {
        github: username,
      },
      createdAt: new Date().toISOString(),
    };

    const agentCardJSON = JSON.stringify(agentCard, null, 2);
    const agentCardURI = `data:application/json;base64,${btoa(agentCardJSON)}`;

    // 调用合约注册
    const contract = new ethers.Contract(
      identityRegistryAddress,
      AgentIdentityRegistryABI,
      agentSigner,
    );

    const tx = await contract.registerAgent(username, agentCardURI);
    await tx.wait();

    // 重新检查注册状态
    await checkRegistration();

    return tx;
  };

  return {
    isRegistered,        // 是否已注册
    loading,            // 加载状态
    agentProfile,       // 代理档案
    registerAgent,      // 注册方法
    checkRegistration,  // 检查方法
  };
}
```

**使用示例：**
```typescript
function RegisterAgentPage() {
  const { isRegistered, loading, registerAgent } = useAgentRegistry();
  const [registering, setRegistering] = useState(false);

  const handleRegister = async () => {
    setRegistering(true);
    try {
      await registerAgent();
      toast.success('注册成功！');
    } catch (error) {
      toast.error('注册失败: ' + error.message);
    } finally {
      setRegistering(false);
    }
  };

  if (loading) return <Spinner />;
  if (isRegistered) return <div>您已注册</div>;

  return <button onClick={handleRegister} disabled={registering}>
    {registering ? '注册中...' : '注册代理'}
  </button>;
}
```

## 3. 服务层架构

### 3.1 认证服务

```typescript
// src/lib/services/auth.service.ts
import { supabase } from '@/lib/supabase/client';
import { createClient } from '@/lib/supabase/server';
import type { User, Session } from '@supabase/supabase-js';

export class AuthService {
  /**
   * 使用 GitHub OAuth 登录
   */
  static async signInWithGitHub(redirectTo?: string) {
    const baseUrl = redirectTo ||
      (typeof window !== 'undefined' ? window.location.origin : 
        process.env.NEXT_PUBLIC_FRONTEND_URL || 'http://localhost:3000');

    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: 'github',
      options: {
        redirectTo: `${baseUrl}/auth/callback`,
        scopes: 'user:email read:user',
      },
    });

    if (error) {
      console.error('GitHub OAuth 初始化失败:', error);
      throw error;
    }

    return data;
  }

  /**
   * 登出
   */
  static async signOut() {
    const { error } = await supabase.auth.signOut();
    if (error) {
      console.error('登出失败:', error);
      throw error;
    }
  }

  /**
   * 获取当前用户 session (客户端)
   */
  static async getSession(): Promise<{ session: Session | null; error: any }> {
    const { data, error } = await supabase.auth.getSession();
    return { session: data.session, error };
  }

  /**
   * 获取当前用户信息 (客户端)
   */
  static async getUser(): Promise<{ user: User | null; error: any }> {
    const { data, error } = await supabase.auth.getUser();
    return { user: data.user, error };
  }

  /**
   * 获取当前用户信息 (服务端)
   */
  static async getServerUser(): Promise<{ user: User | null; error: any }> {
    const supabaseServer = createClient();
    const { data, error } = await supabaseServer.auth.getUser();
    return { user: data.user, error };
  }

  /**
   * 监听认证状态变化
   */
  static onAuthStateChange(callback: (event: string, session: Session | null) => void) {
    return supabase.auth.onAuthStateChange(callback);
  }

  /**
   * 同步用户信息到应用数据库
   */
  static async syncUserToDatabase(user: User) {
    try {
      const userData = {
        id: user.id,
        email: user.email,
        githubId: user.user_metadata?.user_name,
        username: user.user_metadata?.user_name,
        avatarUrl: user.user_metadata?.avatar_url,
        accessToken: null,
        walletAddress: null,
        updatedAt: new Date().toISOString(),
      };

      const { error } = await supabase
        .from('users')
        .upsert(userData, {
          onConflict: 'id',
        });

      if (error) {
        console.error('同步用户信息失败:', error);
      }
    } catch (error) {
      console.error('同步用户信息到数据库失败:', error);
    }
  }
}
```

**方法说明：**
- **signInWithGitHub()**：发起 GitHub OAuth 流程
- **signOut()**：登出并清除会话
- **getSession()**：获取当前会话（客户端）
- **getUser()**：获取当前用户（客户端）
- **getServerUser()**：获取当前用户（服务端）
- **onAuthStateChange()**：监听认证状态变化
- **syncUserToDatabase()**：将用户信息同步到数据库

### 3.2 贡献服务

```typescript
// src/lib/services/contribution.service.ts
import { ContributionRepository } from '@/lib/database/repositories/contribution.repository';
import {
  Contribution,
  QueryContributionParams,
  ContributionStats,
} from '@/types/contribution';

export class ContributionService {
  // 获取所有贡献
  static async findAll(
    query: QueryContributionParams = {}, 
    limit = 50, 
    offset = 0
  ): Promise<Contribution[]> {
    return ContributionRepository.findAll(query, limit, offset);
  }

  // 根据 ID 获取单个贡献
  static async findOne(id: string): Promise<Contribution | null> {
    return ContributionRepository.findById(id);
  }

  // 根据用户 ID 获取贡献
  static async findByUser(
    userId: string, 
    limit = 50, 
    offset = 0
  ): Promise<Contribution[]> {
    return ContributionRepository.findByUserId(userId, limit, offset);
  }

  // 根据仓库 ID 获取贡献
  static async findByRepository(
    repositoryId: string, 
    limit = 50, 
    offset = 0
  ): Promise<Contribution[]> {
    const query: QueryContributionParams = { repositoryId };
    return ContributionRepository.findAll(query, limit, offset);
  }

  // 获取统计信息
  static async getStats(userId?: string): Promise<ContributionStats> {
    return ContributionRepository.getStats(userId);
  }

  // 获取用户贡献统计
  static async getUserContributionStats(userId: string): Promise<ContributionStats> {
    const stats = await ContributionRepository.getStats(userId);
    const contributions = await ContributionRepository.findByUserId(userId);

    // 计算额外的统计信息
    const monthlyStats = this.calculateMonthlyStats(contributions);
    const typeDistribution = this.calculateTypeDistribution(contributions);
    const statusDistribution = this.calculateStatusDistribution(contributions);

    return {
      ...stats,
      monthlyStats,
      typeDistribution,
      statusDistribution,
      totalContributions: contributions.length,
    };
  }

  // 搜索贡献
  static async searchContributions(
    searchTerm: string,
    filters: QueryContributionParams = {},
    limit = 50,
    offset = 0,
  ): Promise<Contribution[]> {
    const allContributions = await ContributionRepository.findAll(filters, 1000, 0);

    const filteredContributions = allContributions.filter(contribution =>
      contribution.title?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      contribution.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      contribution.contributor.toLowerCase().includes(searchTerm.toLowerCase()),
    );

    return filteredContributions.slice(offset, offset + limit);
  }

  // 计算月度统计
  private static calculateMonthlyStats(contributions: Contribution[]) {
    const monthlyData: { [key: string]: number } = {};

    contributions.forEach(contribution => {
      const date = new Date(contribution.createdAt);
      const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
      monthlyData[monthKey] = (monthlyData[monthKey] || 0) + 1;
    });

    return Object.entries(monthlyData)
      .map(([month, count]) => ({ month, count }))
      .sort((a, b) => a.month.localeCompare(b.month));
  }

  // 计算类型分布
  private static calculateTypeDistribution(contributions: Contribution[]) {
    const typeCount: { [key: string]: number } = {};

    contributions.forEach(contribution => {
      typeCount[contribution.type] = (typeCount[contribution.type] || 0) + 1;
    });

    return Object.entries(typeCount).map(([type, count]) => ({ type, count }));
  }

  // 计算状态分布
  private static calculateStatusDistribution(contributions: Contribution[]) {
    const statusCount: { [key: string]: number } = {};

    contributions.forEach(contribution => {
      statusCount[contribution.status] = (statusCount[contribution.status] || 0) + 1;
    });

    return Object.entries(statusCount).map(([status, count]) => ({ status, count }));
  }
}
```

**服务层职责：**
1. 封装业务逻辑
2. 调用数据访问层
3. 数据转换和聚合
4. 计算衍生数据（统计、分布等）

## 4. 数据访问层（Repository）

### 4.1 贡献 Repository

```typescript
// src/lib/database/repositories/contribution.repository.ts
import { getDatabaseClient, query } from '@/lib/database/index';
import { Contribution } from '@/types/contribution';

export class ContributionRepository {
  // 通用查询（基于 Supabase 客户端）
  static async findMany(params: {
    status?: string;
    eligibility?: string;
    whereScoreNull?: boolean;
    limit?: number;
  } = {}) {
    const supabase = getDatabaseClient();
    let q = supabase.from('contributions').select('*');

    // 构建查询条件
    if (params.status) q = q.eq('status', params.status);
    if (params.eligibility) q = q.eq('eligibility', params.eligibility);
    if (params.whereScoreNull) q = q.is('score', null);
    if (params.limit) q = q.limit(params.limit);

    const { data, error } = await q;
    if (error) throw error;
    return (data || []).map(this.mapRowToContribution);
  }

  // 根据 ID 查找贡献（使用原生 SQL）
  static async findById(id: string): Promise<Contribution | null> {
    const result = await query(
      `SELECT c.*, u.username, u.avatar_url, r.name as repo_name, r.full_name as repo_full_name
       FROM contributions c
       LEFT JOIN users u ON c.user_id = u.id
       LEFT JOIN repositories r ON c.repository_id = r.id
       WHERE c.id = $1`,
      [id],
    );

    return result.rows.length > 0 ? this.mapRowToContribution(result.rows[0]) : null;
  }

  // 查询贡献列表
  static async findAll(
    params: QueryContributionParams = {}, 
    limit = 50, 
    offset = 0
  ): Promise<Contribution[]> {
    let whereClause = '';
    const values: unknown[] = [];
    let paramIndex = 1;

    const conditions = [];

    // 构建 WHERE 子句
    if (params.type) {
      conditions.push(`c.type = $${paramIndex++}`);
      values.push(params.type);
    }

    if (params.status) {
      conditions.push(`c.status = $${paramIndex++}`);
      values.push(params.status);
    }

    if (params.userId) {
      conditions.push(`c.user_id = $${paramIndex++}`);
      values.push(params.userId);
    }

    if (params.repositoryId) {
      conditions.push(`c.repository_id = $${paramIndex++}`);
      values.push(params.repositoryId);
    }

    if (conditions.length > 0) {
      whereClause = `WHERE ${conditions.join(' AND ')}`;
    }

    values.push(limit, offset);

    // 执行查询
    const result = await query(
      `SELECT c.*, u.username, u.avatar_url, r.name as repo_name, r.full_name as repo_full_name
       FROM contributions c
       LEFT JOIN users u ON c.user_id = u.id
       LEFT JOIN repositories r ON c.repository_id = r.id
       ${whereClause}
       ORDER BY c.created_at DESC
       LIMIT $${paramIndex++} OFFSET $${paramIndex++}`,
      values,
    );

    return result.rows.map(this.mapRowToContribution);
  }

  // 根据用户 ID 查找贡献
  static async findByUserId(
    userId: string, 
    limit = 50, 
    offset = 0
  ): Promise<Contribution[]> {
    const result = await query(
      `SELECT c.*, u.username, u.avatar_url, r.name as repo_name, r.full_name as repo_full_name
       FROM contributions c
       LEFT JOIN users u ON c.user_id = u.id
       LEFT JOIN repositories r ON c.repository_id = r.id
       WHERE c.user_id = $1
       ORDER BY c.created_at DESC
       LIMIT $2 OFFSET $3`,
      [userId, limit, offset],
    );

    return result.rows.map(this.mapRowToContribution);
  }

  // 创建贡献
  static async create(contributionData: CreateContributionData): Promise<Contribution> {
    const supabase = getDatabaseClient();
    const { data, error } = await supabase
      .from('contributions')
      .insert({
        githubId: contributionData.githubId,
        type: contributionData.type,
        userId: contributionData.userId,
        repositoryId: contributionData.repositoryId,
        contributor: contributionData.contributor,
        title: contributionData.title,
        description: contributionData.description,
        url: contributionData.url,
        metadata: contributionData.metadata || {},
      })
      .select()
      .single();

    if (error) throw error;

    return this.mapRowToContribution(data);
  }

  // 更新贡献
  static async update(
    id: string, 
    contributionData: UpdateContributionData
  ): Promise<Contribution | null> {
    const supabase = getDatabaseClient();

    const updateData: any = {};
    if (contributionData.status !== undefined) updateData.status = contributionData.status;
    if (contributionData.transactionHash !== undefined) updateData.transactionHash = contributionData.transactionHash;
    if (contributionData.tokenId !== undefined) updateData.tokenId = contributionData.tokenId;
    if (contributionData.metadataUri !== undefined) updateData.metadataUri = contributionData.metadataUri;
    if (contributionData.metadata !== undefined) updateData.metadata = contributionData.metadata;
    if ((contributionData as any).score !== undefined) (updateData as any).score = (contributionData as any).score;
    if ((contributionData as any).scoreBreakdown !== undefined) (updateData as any).scoreBreakdown = (contributionData as any).scoreBreakdown;

    if (Object.keys(updateData).length === 0) {
      return this.findById(id);
    }

    const { data, error } = await supabase
      .from('contributions')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;

    return data ? this.mapRowToContribution(data) : null;
  }

  // 获取统计信息
  static async getStats(userId?: string): Promise<ContributionStats> {
    let whereClause = '';
    const values: unknown[] = [];

    if (userId) {
      whereClause = 'WHERE user_id = $1';
      values.push(userId);
    }

    const result = await query(
      `SELECT 
        COUNT(*) as total,
        COUNT(CASE WHEN status = 'minted' THEN 1 END) as minted,
        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending,
        COUNT(CASE WHEN status = 'minting' THEN 1 END) as minting,
        COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed,
        COUNT(CASE WHEN type = 'commit' THEN 1 END) as commits,
        COUNT(CASE WHEN type = 'pull_request' THEN 1 END) as pull_requests,
        COUNT(CASE WHEN type = 'issue' THEN 1 END) as issues
       FROM contributions ${whereClause}`,
      values,
    );

    const dbStats = result.rows[0];

    return {
      totalContributions: parseInt(dbStats.total),
      mintedContributions: parseInt(dbStats.minted),
      pendingContributions: parseInt(dbStats.pending),
      monthlyStats: [],
      typeDistribution: [
        { type: 'commit', count: parseInt(dbStats.commits) },
        { type: 'pull_request', count: parseInt(dbStats.pull_requests) },
        { type: 'issue', count: parseInt(dbStats.issues) },
      ],
      statusDistribution: [
        { status: 'minted', count: parseInt(dbStats.minted) },
        { status: 'pending', count: parseInt(dbStats.pending) },
        { status: 'minting', count: parseInt(dbStats.minting) },
        { status: 'failed', count: parseInt(dbStats.failed) },
      ],
    };
  }

  // 将数据库行映射为 Contribution 对象
  private static mapRowToContribution(row: any): Contribution {
    // 兼容 snake_case 与 camelCase 两种风格
    const get = (a: any, ...keys: string[]) => 
      keys.reduce((v, k) => (v !== undefined ? v : (row as any)[k]), undefined);

    const metadataRaw = get(row, 'metadata', 'metadata');
    const metadata = typeof metadataRaw === 'string' ? 
      JSON.parse(metadataRaw) : (metadataRaw || {});

    return {
      id: get(row, 'id') as string,
      githubId: (get(row, 'github_id', 'githubId') as string) || '',
      type: get(row, 'type'),
      user: get(row, 'username') ? {
        id: (get(row, 'user_id', 'userId') as string) || '',
        githubId: (get(row, 'user_github_id', 'userGithubId') as string) || '',
        username: get(row, 'username') as string,
        avatarUrl: (get(row, 'avatar_url', 'avatarUrl') as string) || undefined,
      } : undefined,
      userId: (get(row, 'user_id', 'userId') as string) || '',
      repository: get(row, 'repo_name') ? {
        id: (get(row, 'repository_id', 'repositoryId') as string) || '',
        githubId: (get(row, 'repository_github_id', 'repositoryGithubId') as string) || '',
        name: get(row, 'repo_name') as string,
        fullName: (get(row, 'repo_full_name', 'repoFullName') as string) || '',
        description: (get(row, 'repo_description') as string) || undefined,
        url: (get(row, 'repo_url') as string) || undefined,
      } : undefined,
      repositoryId: (get(row, 'repository_id', 'repositoryId') as string) || '',
      contributor: (get(row, 'contributor') as string) || '',
      title: (get(row, 'title') as string) || undefined,
      description: (get(row, 'description') as string) || undefined,
      url: (get(row, 'url') as string) || undefined,
      status: get(row, 'status'),
      transactionHash: (get(row, 'transaction_hash', 'transactionHash') as string) || undefined,
      tokenId: (get(row, 'token_id', 'tokenId') as string) || undefined,
      metadataUri: (get(row, 'metadata_uri', 'metadataUri') as string) || undefined,
      metadata,
      score: (get(row, 'score') as number) || undefined,
      scoreBreakdown: (get(row, 'scoreBreakdown') as any) || undefined,
      eligibility: (get(row, 'eligibility') as string) || undefined,
      aiVersion: (get(row, 'aiVersion') as string) || undefined,
      createdAt: (get(row, 'created_at', 'createdAt') as Date) as any,
      updatedAt: (get(row, 'updated_at', 'updatedAt') as Date) as any,
    };
  }
}
```

**Repository 层职责：**
1. 直接操作数据库
2. 执行 CRUD 操作
3. 数据映射（数据库格式 ↔ 应用格式）
4. 查询优化

## 5. 数据流完整示例

### 示例：获取用户贡献列表

#### 1. 组件层

```typescript
// src/app/erc8004/contributions/page.tsx
export default function ERC8004ContributionsPage() {
  const { isAuthenticated } = useAuth();
  const [contributions, setContributions] = useState<Contribution[]>([]);
  const [loading, setLoading] = useState(true);

  const loadContributions = async () => {
    try {
      setLoading(true);

      // 获取认证 token
      const authResponse = await fetch('/api/auth/user');
      const authData = await authResponse.json();
      
      if (!authData?.session?.access_token) {
        console.log('未登录，跳过加载贡献');
        setLoading(false);
        return;
      }

      // 调用 API 获取贡献
      const response = await fetch('/api/contributions/my', {
        headers: {
          'Authorization': `Bearer ${authData.session.access_token}`,
        },
      });

      if (!response.ok) {
        throw new Error('获取贡献失败');
      }

      const data = await response.json();
      setContributions(data.data || []);
    } catch (error) {
      console.error('加载贡献失败:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (isAuthenticated) {
      loadContributions();
    }
  }, [isAuthenticated]);

  // 渲染 UI...
}
```

#### 2. API 路由层

```typescript
// src/app/api/contributions/my/route.ts
export async function GET(request: NextRequest) {
  try {
    // 验证身份
    const authorization = request.headers.get('authorization');
    if (!authorization || !authorization.startsWith('Bearer ')) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // 获取用户
    const { user, error } = await AuthService.getServerUser();
    if (error || !user) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 });
    }

    // 解析参数
    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get('limit') || '50', 10);
    const offset = parseInt(searchParams.get('offset') || '0', 10);

    // 调用服务层
    const contributions = await ContributionService.findByUser(user.id, limit, offset);

    // 返回响应
    return NextResponse.json({
      data: contributions,
      pagination: { limit, offset, total: contributions.length },
      user: { id: user.id, username: user.user_metadata?.user_name || 'unknown' },
    });

  } catch (error) {
    console.error('Get my contributions error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch user contributions' },
      { status: 500 },
    );
  }
}
```

#### 3. 服务层

```typescript
// src/lib/services/contribution.service.ts
export class ContributionService {
  static async findByUser(
    userId: string, 
    limit = 50, 
    offset = 0
  ): Promise<Contribution[]> {
    // 调用 Repository 层
    return ContributionRepository.findByUserId(userId, limit, offset);
  }
}
```

#### 4. Repository 层

```typescript
// src/lib/database/repositories/contribution.repository.ts
export class ContributionRepository {
  static async findByUserId(
    userId: string, 
    limit = 50, 
    offset = 0
  ): Promise<Contribution[]> {
    // 执行数据库查询
    const result = await query(
      `SELECT c.*, u.username, u.avatar_url, r.name as repo_name, r.full_name as repo_full_name
       FROM contributions c
       LEFT JOIN users u ON c.user_id = u.id
       LEFT JOIN repositories r ON c.repository_id = r.id
       WHERE c.user_id = $1
       ORDER BY c.created_at DESC
       LIMIT $2 OFFSET $3`,
      [userId, limit, offset],
    );

    // 映射数据
    return result.rows.map(this.mapRowToContribution);
  }
}
```

#### 5. 数据库层

```typescript
// src/lib/database/index.ts
export const query = async <T = any>(
  text: string, 
  params?: unknown[]
): Promise<QueryResult<T>> => {
  const start = Date.now();

  try {
    const supabaseService = getSupabaseService();
    const result = await supabaseService.query(text, params);

    const res: QueryResult<T> = {
      rows: Array.isArray(result) ? result : (result ? [result] : []),
      rowCount: Array.isArray(result) ? result.length : (result ? 1 : 0),
      command: text.trim().split(' ')[0].toUpperCase(),
      oid: 0,
      fields: [],
    };

    const duration = Date.now() - start;
    console.log('Executed query', { duration, rows: res.rowCount });

    return res;
  } catch (error) {
    console.error('Database query error:', error);
    throw error;
  }
};
```

### 数据流向图

```
用户交互
    ↓
React 组件 (useEffect + fetch)
    ↓
API 路由 (/api/contributions/my)
    ↓ 验证身份
    ↓ 解析参数
    ↓
服务层 (ContributionService.findByUser)
    ↓
Repository 层 (ContributionRepository.findByUserId)
    ↓
数据库查询 (query + SQL)
    ↓
Supabase Client
    ↓
PostgreSQL 数据库
    ↓ 返回数据
    ↓
Repository 映射数据
    ↓
服务层处理数据
    ↓
API 路由格式化响应
    ↓
组件更新状态
    ↓
UI 重新渲染
```

## 6. 缓存策略

### 6.1 React Query 缓存

```typescript
// 配置
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,   // 5 分钟内数据视为新鲜
      cacheTime: 1000 * 60 * 10,  // 缓存保留 10 分钟
      refetchOnWindowFocus: false, // 窗口聚焦不自动刷新
      retry: 1,                    // 失败重试 1 次
    },
  },
});
```

**工作机制：**
1. **首次查询**：发起网络请求，缓存结果
2. **5 分钟内再次查询**：直接返回缓存（staleTime）
3. **5-10 分钟内再次查询**：返回缓存，后台刷新数据
4. **10 分钟后**：缓存被清除，重新请求

**手动控制缓存：**
```typescript
const queryClient = useQueryClient();

// 使缓存失效（触发重新获取）
queryClient.invalidateQueries({ queryKey: ['contributions'] });

// 设置缓存数据
queryClient.setQueryData(['contribution', id], newData);

// 获取缓存数据
const cachedData = queryClient.getQueryData(['contributions']);

// 预取数据
queryClient.prefetchQuery({
  queryKey: ['contribution', id],
  queryFn: () => contributionsApi.getOne(id),
});
```

### 6.2 localStorage 缓存

```typescript
// 存储 token
localStorage.setItem('token', accessToken);

// 读取 token
const token = localStorage.getItem('token');

// 删除 token
localStorage.removeItem('token');

// 清空所有
localStorage.clear();
```

**使用场景：**
- 认证 token
- 用户偏好设置
- 主题配置
- 最近查看记录

### 6.3 Supabase 会话缓存

```typescript
// Supabase 自动管理会话缓存
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,   // 自动刷新 token
    persistSession: true,     // 持久化会话到 localStorage
    detectSessionInUrl: true, // 从 URL 检测会话
  },
});
```

**工作机制：**
1. 登录成功后，会话保存到 `localStorage`
2. 页面刷新时，自动恢复会话
3. Token 过期前，自动刷新
4. 登出时，清除本地会话

## 7. 错误处理

### 7.1 API 层错误处理

```typescript
// API 路由统一错误处理
export async function GET(request: NextRequest) {
  try {
    // 业务逻辑
    const data = await fetchData();
    return NextResponse.json({ success: true, data });
  } catch (error) {
    console.error('API Error:', error);
    
    // 根据错误类型返回不同状态码
    if (error instanceof AuthError) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }
    
    if (error instanceof ValidationError) {
      return NextResponse.json(
        { error: error.message },
        { status: 400 }
      );
    }
    
    // 默认 500 错误
    return NextResponse.json(
      { error: 'Internal Server Error' },
      { status: 500 }
    );
  }
}
```

### 7.2 React Query 错误处理

```typescript
const { data, isError, error } = useQuery({
  queryKey: ['contributions'],
  queryFn: contributionsApi.getAll,
  // 错误回调
  onError: (error) => {
    console.error('Query failed:', error);
    toast.error('获取数据失败');
  },
  // 错误重试策略
  retry: (failureCount, error) => {
    // 401 不重试
    if (error.response?.status === 401) {
      return false;
    }
    // 其他错误最多重试 3 次
    return failureCount < 3;
  },
  // 重试延迟
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
});

// 组件中处理错误
if (isError) {
  return <ErrorMessage error={error} />;
}
```

### 7.3 组件层错误处理

```typescript
function MyComponent() {
  const [error, setError] = useState<Error | null>(null);

  const handleAction = async () => {
    try {
      await someAsyncAction();
    } catch (error) {
      setError(error as Error);
      
      // 显示用户友好的错误消息
      if (error instanceof NetworkError) {
        toast.error('网络连接失败，请检查网络');
      } else if (error instanceof ValidationError) {
        toast.error(error.message);
      } else {
        toast.error('操作失败，请稍后重试');
      }
    }
  };

  if (error) {
    return (
      <ErrorBoundary error={error} reset={() => setError(null)} />
    );
  }

  return <div>...</div>;
}
```

### 7.4 全局错误边界

```typescript
// src/app/error.tsx
'use client';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div className="error-container">
      <h2>出错了！</h2>
      <p>{error.message}</p>
      <button onClick={reset}>重试</button>
    </div>
  );
}
```

## 8. 最佳实践总结

### 8.1 数据请求最佳实践

1. **使用 React Query 管理服务端状态**
   - 自动缓存和刷新
   - 统一的加载和错误状态
   - 后台数据同步

2. **API 路由层进行权限验证**
   - 每个请求验证 token
   - 检查用户权限
   - 防止未授权访问

3. **分层架构清晰分离关注点**
   - 组件层：UI 渲染和用户交互
   - Hooks 层：状态管理和业务逻辑
   - API 层：请求验证和路由
   - 服务层：业务逻辑封装
   - Repository 层：数据访问
   - 数据库层：数据存储

4. **统一的错误处理**
   - API 层捕获异常
   - 返回标准错误格式
   - 组件层显示友好提示

### 8.2 状态管理最佳实践

1. **服务端状态使用 React Query**
   - 贡献列表
   - 用户信息
   - 统计数据

2. **全局状态使用 Context API**
   - Web3 连接状态
   - 认证状态
   - 主题配置

3. **组件状态使用 useState**
   - 表单输入
   - UI 交互状态
   - 临时数据

4. **URL 状态使用搜索参数**
   - 分页参数
   - 过滤条件
   - 排序方式

### 8.3 性能优化最佳实践

1. **合理设置缓存时间**
   - 频繁变化的数据：短缓存
   - 稳定的数据：长缓存

2. **按需加载数据**
   - 分页加载
   - 懒加载
   - 虚拟滚动

3. **减少不必要的请求**
   - 使用 enabled 条件
   - 合并请求
   - 防抖节流

4. **优化数据结构**
   - 扁平化数据
   - 规范化状态
   - 索引优化

### 8.4 安全最佳实践

1. **敏感信息不存储在客户端**
   - 私钥、密码
   - API 密钥
   - 用户隐私数据

2. **API 请求带认证 token**
   - 每个请求验证身份
   - Token 存储在 httpOnly Cookie（推荐）或 localStorage

3. **防止 CSRF 攻击**
   - 使用 SameSite Cookie
   - 验证 Origin 和 Referer

4. **输入验证和清理**
   - 前端验证用户输入
   - 后端再次验证
   - 防止 SQL 注入和 XSS

## 9. 总结

LightCommit 的数据请求与状态管理采用了现代化的最佳实践：

**核心优势：**
1. **分层架构**：清晰的职责分离，易于维护
2. **React Query**：自动化的服务端状态管理
3. **Context API**：简洁的全局状态共享
4. **类型安全**：TypeScript 提供完整的类型检查
5. **错误处理**：统一的错误处理机制
6. **性能优化**：智能缓存和按需加载

**技术栈：**
- Axios：HTTP 客户端
- React Query：服务端状态管理
- Context API：全局状态
- Next.js API Routes：后端 API
- Supabase：数据库和认证
- TypeScript：类型安全

这种架构设计确保了应用的可扩展性、可维护性和高性能。





